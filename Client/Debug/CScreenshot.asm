; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\vice-players-master\Client\CScreenshot.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	??0CScreenshot@@QAE@PAUIDirect3DDevice8@@@Z	; CScreenshot::CScreenshot
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT rtc$TMZ
; File d:\vice-players-master\client\cscreenshot.cpp
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu /ZI
rtc$IMZ	ENDS
;	COMDAT ??0CScreenshot@@QAE@PAUIDirect3DDevice8@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pD3DDevice$ = 8					; size = 4
??0CScreenshot@@QAE@PAUIDirect3DDevice8@@@Z PROC	; CScreenshot::CScreenshot, COMDAT
; _this$ = ecx

; 22   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 23   : 	m_pD3DDevice = pD3DDevice;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pD3DDevice$[ebp]
	mov	DWORD PTR [eax], ecx

; 24   : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0CScreenshot@@QAE@PAUIDirect3DDevice8@@@Z ENDP	; CScreenshot::CScreenshot
_TEXT	ENDS
PUBLIC	?FreeDib@CScreenshot@@AAEXPAX@Z			; CScreenshot::FreeDib
PUBLIC	?CreateJpegFileFromDib@CScreenshot@@AAEHPAXHPAD@Z ; CScreenshot::CreateJpegFileFromDib
PUBLIC	?CreateDibFromCurrentSurface@CScreenshot@@AAEPAXXZ ; CScreenshot::CreateDibFromCurrentSurface
PUBLIC	?TakeScreenShot@CScreenshot@@QAEHPAD@Z		; CScreenshot::TakeScreenShot
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_UninitUse:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?TakeScreenShot@CScreenshot@@QAEHPAD@Z
_TEXT	SEGMENT
$T209381 = -233						; size = 1
_bRet$ = -32						; size = 4
_hDib$ = -20						; size = 4
_this$ = -8						; size = 4
_szFileName$ = 8					; size = 4
?TakeScreenShot@CScreenshot@@QAEHPAD@Z PROC		; CScreenshot::TakeScreenShot, COMDAT
; _this$ = ecx

; 29   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	BYTE PTR $T209381[ebp], 0

; 30   : 	HANDLE hDib;
; 31   : 	BOOL bRet=FALSE;

	mov	DWORD PTR _bRet$[ebp], 0

; 32   : 
; 33   : 	if(m_pD3DDevice)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@TakeScreen

; 34   : 	{
; 35   : 		hDib = CreateDibFromCurrentSurface();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CreateDibFromCurrentSurface@CScreenshot@@AAEPAXXZ ; CScreenshot::CreateDibFromCurrentSurface
	mov	BYTE PTR $T209381[ebp], 1
	mov	DWORD PTR _hDib$[ebp], eax

; 36   : 		if(NULL == hDib) return FALSE;

	cmp	BYTE PTR $T209381[ebp], 0
	jne	SHORT $LN5@TakeScreen
	push	OFFSET $LN6@TakeScreen
	call	__RTC_UninitUse
	add	esp, 4
$LN5@TakeScreen:
	cmp	DWORD PTR _hDib$[ebp], 0
	jne	SHORT $LN2@TakeScreen
	xor	eax, eax
	jmp	SHORT $LN3@TakeScreen
$LN2@TakeScreen:

; 37   : 	}	
; 38   : 
; 39   : 	bRet = CreateJpegFileFromDib(hDib,90,szFileName);

	cmp	BYTE PTR $T209381[ebp], 0
	jne	SHORT $LN7@TakeScreen
	push	OFFSET $LN6@TakeScreen
	call	__RTC_UninitUse
	add	esp, 4
$LN7@TakeScreen:
	mov	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	push	90					; 0000005aH
	mov	ecx, DWORD PTR _hDib$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CreateJpegFileFromDib@CScreenshot@@AAEHPAXHPAD@Z ; CScreenshot::CreateJpegFileFromDib
	mov	DWORD PTR _bRet$[ebp], eax

; 40   : 	FreeDib(hDib);

	cmp	BYTE PTR $T209381[ebp], 0
	jne	SHORT $LN8@TakeScreen
	push	OFFSET $LN6@TakeScreen
	call	__RTC_UninitUse
	add	esp, 4
$LN8@TakeScreen:
	mov	eax, DWORD PTR _hDib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FreeDib@CScreenshot@@AAEXPAX@Z		; CScreenshot::FreeDib

; 41   : 
; 42   : 	return bRet;

	mov	eax, DWORD PTR _bRet$[ebp]
$LN3@TakeScreen:

; 43   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$LN9@TakeScreen:
$LN6@TakeScreen:
	DB	104					; 00000068H
	DB	68					; 00000044H
	DB	105					; 00000069H
	DB	98					; 00000062H
	DB	0
?TakeScreenShot@CScreenshot@@QAEHPAD@Z ENDP		; CScreenshot::TakeScreenShot
_TEXT	ENDS
EXTRN	_memcpy:PROC
EXTRN	_calloc:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?CreateDibFromCurrentSurface@CScreenshot@@AAEPAXXZ
_TEXT	SEGMENT
_x$209283 = -204					; size = 4
_y$209278 = -192					; size = 4
_lpDest$ = -180						; size = 4
_lpSrc$ = -168						; size = 4
_LockedRect$ = -156					; size = 8
_bmih$ = -140						; size = 40
_dm$ = -92						; size = 16
_dcp$ = -68						; size = 16
_pbyteDibBuffer$ = -44					; size = 4
_pD3D$ = -32						; size = 4
_pSurface$ = -20					; size = 4
_this$ = -8						; size = 4
?CreateDibFromCurrentSurface@CScreenshot@@AAEPAXXZ PROC	; CScreenshot::CreateDibFromCurrentSurface, COMDAT
; _this$ = ecx

; 48   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 400				; 00000190H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-400]
	mov	ecx, 100				; 00000064H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 49   : 	LPDIRECT3DSURFACE8		pSurface = 0;

	mov	DWORD PTR _pSurface$[ebp], 0

; 50   :     LPDIRECT3D8				pD3D = 0;

	mov	DWORD PTR _pD3D$[ebp], 0

; 51   :     BYTE					*pbyteDibBuffer = 0;

	mov	DWORD PTR _pbyteDibBuffer$[ebp], 0

; 52   : 
; 53   :     D3DDEVICE_CREATION_PARAMETERS dcp;
; 54   : 
; 55   :     dcp.AdapterOrdinal = D3DADAPTER_DEFAULT;

	mov	DWORD PTR _dcp$[ebp], 0

; 56   :     m_pD3DDevice->GetCreationParameters(&dcp);

	mov	esi, esp
	lea	eax, DWORD PTR _dcp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+36]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 57   : 
; 58   :     D3DDISPLAYMODE dm;
; 59   :     dm.Width = dm.Height = 0;

	mov	DWORD PTR _dm$[ebp+4], 0
	mov	eax, DWORD PTR _dm$[ebp+4]
	mov	DWORD PTR _dm$[ebp], eax

; 60   : 
; 61   :     m_pD3DDevice->GetDirect3D(&pD3D);

	mov	esi, esp
	lea	eax, DWORD PTR _pD3D$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+24]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 62   :     if(pD3D) {   

	cmp	DWORD PTR _pD3D$[ebp], 0
	je	SHORT $LN11@CreateDibF

; 63   : 		// get the current screen dimensions
; 64   :         pD3D->GetAdapterDisplayMode(dcp.AdapterOrdinal, &dm);

	mov	esi, esp
	lea	eax, DWORD PTR _dm$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dcp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pD3D$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pD3D$[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax+32]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 65   :         SAFERELEASE(pD3D);

	cmp	DWORD PTR _pD3D$[ebp], 0
	je	SHORT $LN10@CreateDibF
	mov	eax, DWORD PTR _pD3D$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	esi, esp
	mov	edx, DWORD PTR _pD3D$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+8]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _pD3D$[ebp], 0
$LN10@CreateDibF:

; 66   :     }
; 67   : 	else {

	jmp	SHORT $LN9@CreateDibF
$LN11@CreateDibF:

; 68   : 		return NULL;

	xor	eax, eax
	jmp	$LN12@CreateDibF
$LN9@CreateDibF:

; 69   : 	}
; 70   : 	
; 71   : 	// Grab the ARBG surface.
; 72   :     m_pD3DDevice->CreateImageSurface(dm.Width,dm.Height,D3DFMT_A8R8G8B8,&pSurface);

	mov	esi, esp
	lea	eax, DWORD PTR _pSurface$[ebp]
	push	eax
	push	21					; 00000015H
	mov	ecx, DWORD PTR _dm$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _dm$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+108]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 73   : 	m_pD3DDevice->GetFrontBuffer(pSurface);

	mov	esi, esp
	mov	eax, DWORD PTR _pSurface$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+120]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 74   : 
; 75   :     // Setup the dib header.
; 76   :     BITMAPINFOHEADER bmih;
; 77   :     bmih.biSize = sizeof(bmih);

	mov	DWORD PTR _bmih$[ebp], 40		; 00000028H

; 78   :     bmih.biWidth = dm.Width;

	mov	eax, DWORD PTR _dm$[ebp]
	mov	DWORD PTR _bmih$[ebp+4], eax

; 79   :     bmih.biHeight = dm.Height;

	mov	eax, DWORD PTR _dm$[ebp+4]
	mov	DWORD PTR _bmih$[ebp+8], eax

; 80   :     bmih.biPlanes = 1;

	mov	eax, 1
	mov	WORD PTR _bmih$[ebp+12], ax

; 81   :     bmih.biBitCount = 24;

	mov	eax, 24					; 00000018H
	mov	WORD PTR _bmih$[ebp+14], ax

; 82   :     bmih.biCompression = BI_RGB;

	mov	DWORD PTR _bmih$[ebp+16], 0

; 83   :     bmih.biSizeImage = dm.Width * dm.Height * 3;

	mov	eax, DWORD PTR _dm$[ebp]
	imul	eax, DWORD PTR _dm$[ebp+4]
	imul	eax, 3
	mov	DWORD PTR _bmih$[ebp+20], eax

; 84   :     bmih.biXPelsPerMeter = 0;

	mov	DWORD PTR _bmih$[ebp+24], 0

; 85   :     bmih.biYPelsPerMeter = 0;

	mov	DWORD PTR _bmih$[ebp+28], 0

; 86   :     bmih.biClrUsed = 0;

	mov	DWORD PTR _bmih$[ebp+32], 0

; 87   :     bmih.biClrImportant = 0;

	mov	DWORD PTR _bmih$[ebp+36], 0

; 88   : 
; 89   :    	pbyteDibBuffer = (PBYTE)calloc((bmih.biSizeImage+sizeof(BITMAPINFOHEADER)+1),1);

	push	1
	mov	eax, DWORD PTR _bmih$[ebp+20]
	add	eax, 41					; 00000029H
	push	eax
	call	_calloc
	add	esp, 8
	mov	DWORD PTR _pbyteDibBuffer$[ebp], eax

; 90   :     if(!pbyteDibBuffer) return NULL;

	cmp	DWORD PTR _pbyteDibBuffer$[ebp], 0
	jne	SHORT $LN8@CreateDibF
	xor	eax, eax
	jmp	$LN12@CreateDibF
$LN8@CreateDibF:

; 91   : 
; 92   : 	// Lock the surface.
; 93   :     D3DLOCKED_RECT LockedRect;
; 94   :     pSurface->LockRect(&LockedRect,NULL,D3DLOCK_READONLY);

	mov	esi, esp
	push	16					; 00000010H
	push	0
	lea	eax, DWORD PTR _LockedRect$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pSurface$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pSurface$[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+36]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 95   : 	
; 96   : 	// Copy the bitmap info header into the dib buffer.
; 97   :     memcpy(pbyteDibBuffer,&bmih,sizeof(BITMAPINFOHEADER));

	push	40					; 00000028H
	lea	eax, DWORD PTR _bmih$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pbyteDibBuffer$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 98   : 
; 99   :     PDWORD lpSrc;
; 100  :     PBYTE lpDest = pbyteDibBuffer+sizeof(BITMAPINFOHEADER);

	mov	eax, DWORD PTR _pbyteDibBuffer$[ebp]
	add	eax, 40					; 00000028H
	mov	DWORD PTR _lpDest$[ebp], eax

; 101  : 
; 102  :     for(int y = dm.Height - 1; y >= 0; y--) 

	mov	eax, DWORD PTR _dm$[ebp+4]
	sub	eax, 1
	mov	DWORD PTR _y$209278[ebp], eax
	jmp	SHORT $LN7@CreateDibF
$LN6@CreateDibF:
	mov	eax, DWORD PTR _y$209278[ebp]
	sub	eax, 1
	mov	DWORD PTR _y$209278[ebp], eax
$LN7@CreateDibF:
	cmp	DWORD PTR _y$209278[ebp], 0
	jl	SHORT $LN5@CreateDibF

; 103  : 	{
; 104  :         lpSrc = (PDWORD)(LockedRect.pBits) + y * dm.Width;

	mov	eax, DWORD PTR _y$209278[ebp]
	imul	eax, DWORD PTR _dm$[ebp]
	mov	ecx, DWORD PTR _LockedRect$[ebp+4]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _lpSrc$[ebp], edx

; 105  : 		for(int x = 0; x < (signed)dm.Width; x++) 

	mov	DWORD PTR _x$209283[ebp], 0
	jmp	SHORT $LN4@CreateDibF
$LN3@CreateDibF:
	mov	eax, DWORD PTR _x$209283[ebp]
	add	eax, 1
	mov	DWORD PTR _x$209283[ebp], eax
$LN4@CreateDibF:
	mov	eax, DWORD PTR _x$209283[ebp]
	cmp	eax, DWORD PTR _dm$[ebp]
	jge	SHORT $LN2@CreateDibF

; 106  : 		{
; 107  : 			// Store the pixels
; 108  :             *(DWORD *)(lpDest) = *lpSrc;

	mov	eax, DWORD PTR _lpDest$[ebp]
	mov	ecx, DWORD PTR _lpSrc$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 109  :             lpSrc++;

	mov	eax, DWORD PTR _lpSrc$[ebp]
	add	eax, 4
	mov	DWORD PTR _lpSrc$[ebp], eax

; 110  :             lpDest += 3;

	mov	eax, DWORD PTR _lpDest$[ebp]
	add	eax, 3
	mov	DWORD PTR _lpDest$[ebp], eax

; 111  :         }

	jmp	SHORT $LN3@CreateDibF
$LN2@CreateDibF:

; 112  :     }

	jmp	$LN6@CreateDibF
$LN5@CreateDibF:

; 113  : 
; 114  :     // we can unlock and release the surface
; 115  :     pSurface->UnlockRect();

	mov	eax, DWORD PTR _pSurface$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	esi, esp
	mov	edx, DWORD PTR _pSurface$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+40]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 116  :     SAFERELEASE(pSurface);

	cmp	DWORD PTR _pSurface$[ebp], 0
	je	SHORT $LN1@CreateDibF
	mov	eax, DWORD PTR _pSurface$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	esi, esp
	mov	edx, DWORD PTR _pSurface$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+8]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _pSurface$[ebp], 0
$LN1@CreateDibF:

; 117  : 
; 118  : 	return pbyteDibBuffer;

	mov	eax, DWORD PTR _pbyteDibBuffer$[ebp]
$LN12@CreateDibF:

; 119  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN21@CreateDibF
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 400				; 00000190H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN21@CreateDibF:
	DD	6
	DD	$LN20@CreateDibF
$LN20@CreateDibF:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN14@CreateDibF
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN15@CreateDibF
	DD	-68					; ffffffbcH
	DD	16					; 00000010H
	DD	$LN16@CreateDibF
	DD	-92					; ffffffa4H
	DD	16					; 00000010H
	DD	$LN17@CreateDibF
	DD	-140					; ffffff74H
	DD	40					; 00000028H
	DD	$LN18@CreateDibF
	DD	-156					; ffffff64H
	DD	8
	DD	$LN19@CreateDibF
$LN19@CreateDibF:
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	82					; 00000052H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	0
$LN18@CreateDibF:
	DB	98					; 00000062H
	DB	109					; 0000006dH
	DB	105					; 00000069H
	DB	104					; 00000068H
	DB	0
$LN17@CreateDibF:
	DB	100					; 00000064H
	DB	109					; 0000006dH
	DB	0
$LN16@CreateDibF:
	DB	100					; 00000064H
	DB	99					; 00000063H
	DB	112					; 00000070H
	DB	0
$LN15@CreateDibF:
	DB	112					; 00000070H
	DB	68					; 00000044H
	DB	51					; 00000033H
	DB	68					; 00000044H
	DB	0
$LN14@CreateDibF:
	DB	112					; 00000070H
	DB	83					; 00000053H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	102					; 00000066H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	0
?CreateDibFromCurrentSurface@CScreenshot@@AAEPAXXZ ENDP	; CScreenshot::CreateDibFromCurrentSurface
_TEXT	ENDS
EXTRN	_free:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?FreeDib@CScreenshot@@AAEXPAX@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_hDib$ = 8						; size = 4
?FreeDib@CScreenshot@@AAEXPAX@Z PROC			; CScreenshot::FreeDib, COMDAT
; _this$ = ecx

; 124  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 125  : 	free(hDib);

	mov	eax, DWORD PTR _hDib$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 126  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?FreeDib@CScreenshot@@AAEXPAX@Z ENDP			; CScreenshot::FreeDib
_TEXT	ENDS
PUBLIC	?ConvertDibToSamps@CScreenshot@@AAEXPAXHUjpeg_compress_struct@@PAPAE@Z ; CScreenshot::ConvertDibToSamps
PUBLIC	??_C@_02GMLFBBN@wb?$AA@				; `string'
PUBLIC	__$ArrayPad$
EXTRN	_fclose:PROC
EXTRN	_jpeg_finish_compress:PROC
EXTRN	_jpeg_write_scanlines:PROC
EXTRN	_jpeg_start_compress:PROC
EXTRN	_jpeg_set_quality:PROC
EXTRN	_jpeg_set_defaults:PROC
EXTRN	_jpeg_stdio_dest:PROC
EXTRN	_jpeg_destroy_compress:PROC
EXTRN	_fopen:PROC
EXTRN	_jpeg_CreateCompress:PROC
EXTRN	_jpeg_std_error:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_02GMLFBBN@wb?$AA@
CONST	SEGMENT
??_C@_02GMLFBBN@wb?$AA@ DB 'wb', 00H			; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?CreateJpegFileFromDib@CScreenshot@@AAEHPAXHPAD@Z
_TEXT	SEGMENT
_jsmpArray$ = -580					; size = 4
_nSampsPerRow$ = -568					; size = 4
_pOutFile$ = -556					; size = 4
_jerr$ = -544						; size = 132
_cinfo$ = -404						; size = 360
_buf2$ = -36						; size = 4
_lpbi$ = -24						; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_hDib$ = 8						; size = 4
_nQuality$ = 12						; size = 4
_szJpegFile$ = 16					; size = 4
?CreateJpegFileFromDib@CScreenshot@@AAEHPAXHPAD@Z PROC	; CScreenshot::CreateJpegFileFromDib, COMDAT
; _this$ = ecx

; 131  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 776				; 00000308H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-776]
	mov	ecx, 194				; 000000c2H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 132  :     LPBITMAPINFOHEADER lpbi = (LPBITMAPINFOHEADER)hDib;

	mov	eax, DWORD PTR _hDib$[ebp]
	mov	DWORD PTR _lpbi$[ebp], eax

; 133  :     byte *buf2 = 0;

	mov	DWORD PTR _buf2$[ebp], 0

; 134  : 
; 135  :     struct jpeg_compress_struct cinfo;
; 136  :     struct jpeg_error_mgr       jerr;
; 137  : 
; 138  :     FILE		*pOutFile;
; 139  :     int         nSampsPerRow;
; 140  :     JSAMPARRAY  jsmpArray;
; 141  : 
; 142  :     cinfo.err = jpeg_std_error(&jerr);

	lea	eax, DWORD PTR _jerr$[ebp]
	push	eax
	call	_jpeg_std_error
	add	esp, 4
	mov	DWORD PTR _cinfo$[ebp], eax

; 143  :     jpeg_create_compress(&cinfo);

	push	360					; 00000168H
	push	62					; 0000003eH
	lea	eax, DWORD PTR _cinfo$[ebp]
	push	eax
	call	_jpeg_CreateCompress
	add	esp, 12					; 0000000cH

; 144  : 
; 145  :     if((pOutFile = fopen(szJpegFile, "wb")) == NULL) {

	push	OFFSET ??_C@_02GMLFBBN@wb?$AA@
	mov	eax, DWORD PTR _szJpegFile$[ebp]
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _pOutFile$[ebp], eax
	cmp	DWORD PTR _pOutFile$[ebp], 0
	jne	SHORT $LN1@CreateJpeg

; 146  : 		jpeg_destroy_compress(&cinfo);

	lea	eax, DWORD PTR _cinfo$[ebp]
	push	eax
	call	_jpeg_destroy_compress
	add	esp, 4

; 147  :         return FALSE;

	xor	eax, eax
	jmp	$LN2@CreateJpeg
$LN1@CreateJpeg:

; 148  :     }
; 149  : 
; 150  :     jpeg_stdio_dest(&cinfo, pOutFile);

	mov	eax, DWORD PTR _pOutFile$[ebp]
	push	eax
	lea	ecx, DWORD PTR _cinfo$[ebp]
	push	ecx
	call	_jpeg_stdio_dest
	add	esp, 8

; 151  : 
; 152  :     cinfo.image_width      = lpbi->biWidth;

	mov	eax, DWORD PTR _lpbi$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _cinfo$[ebp+28], ecx

; 153  :     cinfo.image_height     = lpbi->biHeight;

	mov	eax, DWORD PTR _lpbi$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _cinfo$[ebp+32], ecx

; 154  :     cinfo.input_components = 3;

	mov	DWORD PTR _cinfo$[ebp+36], 3

; 155  :     cinfo.in_color_space   = JCS_RGB;

	mov	DWORD PTR _cinfo$[ebp+40], 2

; 156  : 
; 157  :     jpeg_set_defaults(&cinfo);

	lea	eax, DWORD PTR _cinfo$[ebp]
	push	eax
	call	_jpeg_set_defaults
	add	esp, 4

; 158  :     jpeg_set_quality(&cinfo,nQuality,TRUE);

	push	1
	mov	eax, DWORD PTR _nQuality$[ebp]
	push	eax
	lea	ecx, DWORD PTR _cinfo$[ebp]
	push	ecx
	call	_jpeg_set_quality
	add	esp, 12					; 0000000cH

; 159  :     jpeg_start_compress(&cinfo, TRUE);

	push	1
	lea	eax, DWORD PTR _cinfo$[ebp]
	push	eax
	call	_jpeg_start_compress
	add	esp, 8

; 160  : 
; 161  :     //JSAMPLEs per row in output buffer
; 162  :     nSampsPerRow = cinfo.image_width * cinfo.input_components; 

	mov	eax, DWORD PTR _cinfo$[ebp+28]
	imul	eax, DWORD PTR _cinfo$[ebp+36]
	mov	DWORD PTR _nSampsPerRow$[ebp], eax

; 163  : 
; 164  :     //Allocate array of pixel RGB values
; 165  :     jsmpArray = (*cinfo.mem->alloc_sarray)((j_common_ptr)&cinfo,JPOOL_IMAGE,
; 166  : 		nSampsPerRow,cinfo.image_height);

	mov	esi, esp
	mov	eax, DWORD PTR _cinfo$[ebp+32]
	push	eax
	mov	ecx, DWORD PTR _nSampsPerRow$[ebp]
	push	ecx
	push	1
	lea	edx, DWORD PTR _cinfo$[ebp]
	push	edx
	mov	eax, DWORD PTR _cinfo$[ebp+4]
	mov	ecx, DWORD PTR [eax+8]
	call	ecx
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _jsmpArray$[ebp], eax

; 167  : 
; 168  : 	ConvertDibToSamps(hDib,nSampsPerRow,cinfo,jsmpArray);

	mov	eax, DWORD PTR _jsmpArray$[ebp]
	push	eax
	sub	esp, 360				; 00000168H
	mov	ecx, 90					; 0000005aH
	lea	esi, DWORD PTR _cinfo$[ebp]
	mov	edi, esp
	rep movsd
	mov	ecx, DWORD PTR _nSampsPerRow$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hDib$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ConvertDibToSamps@CScreenshot@@AAEXPAXHUjpeg_compress_struct@@PAPAE@Z ; CScreenshot::ConvertDibToSamps

; 169  :     jpeg_write_scanlines(&cinfo,jsmpArray,cinfo.image_height);

	mov	eax, DWORD PTR _cinfo$[ebp+32]
	push	eax
	mov	ecx, DWORD PTR _jsmpArray$[ebp]
	push	ecx
	lea	edx, DWORD PTR _cinfo$[ebp]
	push	edx
	call	_jpeg_write_scanlines
	add	esp, 12					; 0000000cH

; 170  : 
; 171  :     jpeg_finish_compress(&cinfo);

	lea	eax, DWORD PTR _cinfo$[ebp]
	push	eax
	call	_jpeg_finish_compress
	add	esp, 4

; 172  : 	fclose(pOutFile);

	mov	eax, DWORD PTR _pOutFile$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 173  :     jpeg_destroy_compress(&cinfo);

	lea	eax, DWORD PTR _cinfo$[ebp]
	push	eax
	call	_jpeg_destroy_compress
	add	esp, 4

; 174  : 	return TRUE;

	mov	eax, 1
$LN2@CreateJpeg:

; 175  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@CreateJpeg
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 776				; 00000308H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN7@CreateJpeg:
	DD	2
	DD	$LN6@CreateJpeg
$LN6@CreateJpeg:
	DD	-404					; fffffe6cH
	DD	360					; 00000168H
	DD	$LN4@CreateJpeg
	DD	-544					; fffffde0H
	DD	132					; 00000084H
	DD	$LN5@CreateJpeg
$LN5@CreateJpeg:
	DB	106					; 0000006aH
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	0
$LN4@CreateJpeg:
	DB	99					; 00000063H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	102					; 00000066H
	DB	111					; 0000006fH
	DB	0
?CreateJpegFileFromDib@CScreenshot@@AAEHPAXHPAD@Z ENDP	; CScreenshot::CreateJpegFileFromDib
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ?ConvertDibToSamps@CScreenshot@@AAEXPAXHUjpeg_compress_struct@@PAPAE@Z
_TEXT	SEGMENT
_wPixels$ = -272					; size = 4
_pRgbQs$ = -260						; size = 4
_lpPixels$ = -248					; size = 4
_lpBits$ = -236						; size = 4
_pCTab$ = -224						; size = 4
_dwCTab$ = -212						; size = 4
_pbBmHdr$ = -200					; size = 4
_bytCTEnt$ = -185					; size = 1
_nPixel$ = -176						; size = 4
_nByte$ = -164						; size = 4
_nRow$ = -152						; size = 4
_nCTEntries$ = -140					; size = 4
_nLastNibs$ = -128					; size = 4
_nLastBits$ = -116					; size = 4
_nUsed$ = -104						; size = 4
_nBytesWide$ = -92					; size = 4
_nUnused$ = -80						; size = 4
_n$ = -68						; size = 4
_b$ = -56						; size = 4
_q$ = -44						; size = 4
_p$ = -32						; size = 4
_r$ = -20						; size = 4
_this$ = -8						; size = 4
_hDib$ = 8						; size = 4
_nSampsPerRow$ = 12					; size = 4
_cinfo$ = 16						; size = 360
_jsmpPixels$ = 376					; size = 4
?ConvertDibToSamps@CScreenshot@@AAEXPAXHUjpeg_compress_struct@@PAPAE@Z PROC ; CScreenshot::ConvertDibToSamps, COMDAT
; _this$ = ecx

; 182  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 480				; 000001e0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-480]
	mov	ecx, 120				; 00000078H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 183  :    int r=0, p=0, q=0, b=0, n=0, 

	mov	DWORD PTR _r$[ebp], 0
	mov	DWORD PTR _p$[ebp], 0
	mov	DWORD PTR _q$[ebp], 0
	mov	DWORD PTR _b$[ebp], 0
	mov	DWORD PTR _n$[ebp], 0

; 184  :        nUnused=0, nBytesWide=0, nUsed=0, nLastBits=0, nLastNibs=0, nCTEntries=0,

	mov	DWORD PTR _nUnused$[ebp], 0
	mov	DWORD PTR _nBytesWide$[ebp], 0
	mov	DWORD PTR _nUsed$[ebp], 0
	mov	DWORD PTR _nLastBits$[ebp], 0
	mov	DWORD PTR _nLastNibs$[ebp], 0
	mov	DWORD PTR _nCTEntries$[ebp], 0

; 185  :        nRow=0, nByte=0, nPixel=0;

	mov	DWORD PTR _nRow$[ebp], 0
	mov	DWORD PTR _nByte$[ebp], 0
	mov	DWORD PTR _nPixel$[ebp], 0

; 186  : 
; 187  :    BYTE bytCTEnt=0;

	mov	BYTE PTR _bytCTEnt$[ebp], 0

; 188  :    LPBITMAPINFOHEADER pbBmHdr= (LPBITMAPINFOHEADER)hDib; //The bit count tells you the format of the bitmap: //Decide how many entries will be in the color table (if any) 

	mov	eax, DWORD PTR _hDib$[ebp]
	mov	DWORD PTR _pbBmHdr$[ebp], eax

; 189  : 
; 190  :    nCTEntries = 0;   //No color table needed

	mov	DWORD PTR _nCTEntries$[ebp], 0

; 191  : 
; 192  :    //Point to the color table and pixels
; 193  :    DWORD     dwCTab = (DWORD)pbBmHdr + pbBmHdr->biSize;

	mov	eax, DWORD PTR _pbBmHdr$[ebp]
	mov	ecx, DWORD PTR _pbBmHdr$[ebp]
	add	ecx, DWORD PTR [eax]
	mov	DWORD PTR _dwCTab$[ebp], ecx

; 194  :    LPRGBQUAD pCTab  = (LPRGBQUAD)(dwCTab);

	mov	eax, DWORD PTR _dwCTab$[ebp]
	mov	DWORD PTR _pCTab$[ebp], eax

; 195  :    LPSTR     lpBits = (LPSTR)pbBmHdr +
; 196  :                       (WORD)pbBmHdr->biSize +
; 197  :                       (WORD)(nCTEntries * sizeof(RGBQUAD));

	mov	eax, DWORD PTR _pbBmHdr$[ebp]
	movzx	ecx, WORD PTR [eax]
	add	ecx, DWORD PTR _pbBmHdr$[ebp]
	mov	edx, DWORD PTR _nCTEntries$[ebp]
	shl	edx, 2
	movzx	eax, dx
	add	ecx, eax
	mov	DWORD PTR _lpBits$[ebp], ecx

; 198  : 
; 199  :    LPBYTE   lpPixels = (LPBYTE)  lpBits;

	mov	eax, DWORD PTR _lpBits$[ebp]
	mov	DWORD PTR _lpPixels$[ebp], eax

; 200  :    RGBQUAD* pRgbQs   = (RGBQUAD*)lpBits;

	mov	eax, DWORD PTR _lpBits$[ebp]
	mov	DWORD PTR _pRgbQs$[ebp], eax

; 201  :    WORD*    wPixels  = (WORD*)   lpBits;

	mov	eax, DWORD PTR _lpBits$[ebp]
	mov	DWORD PTR _wPixels$[ebp], eax

; 202  : 
; 203  :    nBytesWide =  (pbBmHdr->biWidth*3);

	mov	eax, DWORD PTR _pbBmHdr$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 3
	mov	DWORD PTR _nBytesWide$[ebp], ecx

; 204  :    nUnused    =  (((nBytesWide + 3) / 4) * 4) - nBytesWide;

	mov	eax, DWORD PTR _nBytesWide$[ebp]
	add	eax, 3
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	shl	eax, 2
	sub	eax, DWORD PTR _nBytesWide$[ebp]
	mov	DWORD PTR _nUnused$[ebp], eax

; 205  :    nBytesWide += nUnused;

	mov	eax, DWORD PTR _nBytesWide$[ebp]
	add	eax, DWORD PTR _nUnused$[ebp]
	mov	DWORD PTR _nBytesWide$[ebp], eax

; 206  : 
; 207  :    for(r=0; r < (pbBmHdr->biHeight);r++)

	mov	DWORD PTR _r$[ebp], 0
	jmp	SHORT $LN6@ConvertDib
$LN5@ConvertDib:
	mov	eax, DWORD PTR _r$[ebp]
	add	eax, 1
	mov	DWORD PTR _r$[ebp], eax
$LN6@ConvertDib:
	mov	eax, DWORD PTR _pbBmHdr$[ebp]
	mov	ecx, DWORD PTR _r$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jge	$LN7@ConvertDib

; 208  :    {
; 209  :       for(p=0,q=0;p < (nBytesWide-nUnused); p+=3,q+=3)

	mov	DWORD PTR _p$[ebp], 0
	mov	DWORD PTR _q$[ebp], 0
	jmp	SHORT $LN3@ConvertDib
$LN2@ConvertDib:
	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 3
	mov	DWORD PTR _p$[ebp], eax
	mov	ecx, DWORD PTR _q$[ebp]
	add	ecx, 3
	mov	DWORD PTR _q$[ebp], ecx
$LN3@ConvertDib:
	mov	eax, DWORD PTR _nBytesWide$[ebp]
	sub	eax, DWORD PTR _nUnused$[ebp]
	cmp	DWORD PTR _p$[ebp], eax
	jge	$LN1@ConvertDib

; 210  : 	  { 
; 211  :           nRow = (pbBmHdr->biHeight-r-1) * nBytesWide;

	mov	eax, DWORD PTR _pbBmHdr$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR _r$[ebp]
	sub	ecx, 1
	imul	ecx, DWORD PTR _nBytesWide$[ebp]
	mov	DWORD PTR _nRow$[ebp], ecx

; 212  :           nPixel  = nRow + p;

	mov	eax, DWORD PTR _nRow$[ebp]
	add	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR _nPixel$[ebp], eax

; 213  : 
; 214  :           jsmpPixels[r][q+0] = lpPixels[nPixel+2]; //Red

	mov	eax, DWORD PTR _r$[ebp]
	mov	ecx, DWORD PTR _jsmpPixels$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _lpPixels$[ebp]
	add	eax, DWORD PTR _nPixel$[ebp]
	mov	ecx, DWORD PTR _q$[ebp]
	mov	al, BYTE PTR [eax+2]
	mov	BYTE PTR [edx+ecx], al

; 215  :           jsmpPixels[r][q+1] = lpPixels[nPixel+1]; //Green

	mov	eax, DWORD PTR _r$[ebp]
	mov	ecx, DWORD PTR _jsmpPixels$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _lpPixels$[ebp]
	add	eax, DWORD PTR _nPixel$[ebp]
	mov	ecx, DWORD PTR _q$[ebp]
	mov	al, BYTE PTR [eax+1]
	mov	BYTE PTR [ecx+edx+1], al

; 216  :           jsmpPixels[r][q+2] = lpPixels[nPixel+0]; //Blue

	mov	eax, DWORD PTR _r$[ebp]
	mov	ecx, DWORD PTR _jsmpPixels$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _lpPixels$[ebp]
	add	eax, DWORD PTR _nPixel$[ebp]
	mov	ecx, DWORD PTR _q$[ebp]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [ecx+edx+2], al

; 217  :        }

	jmp	$LN2@ConvertDib
$LN1@ConvertDib:

; 218  :    }

	jmp	$LN5@ConvertDib
$LN7@ConvertDib:

; 219  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN11@ConvertDib
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	372					; 00000174H
	npad	1
$LN11@ConvertDib:
	DD	1
	DD	$LN10@ConvertDib
$LN10@ConvertDib:
	DD	-284					; fffffee4H
	DD	4
	DD	$LN9@ConvertDib
$LN9@ConvertDib:
	DB	95					; 0000005fH
	DB	36					; 00000024H
	DB	65					; 00000041H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	0
?ConvertDibToSamps@CScreenshot@@AAEXPAXHUjpeg_compress_struct@@PAPAE@Z ENDP ; CScreenshot::ConvertDibToSamps
_TEXT	ENDS
END
