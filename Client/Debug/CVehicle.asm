; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\vice-players-master\Client\game\CVehicle.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
_create_car DW	0a5H
	DB	'ifffv', 00H
	ORG $+7
	ORG $+1
_set_car_z_angle DW 0175H
	DB	'if', 00H
	ORG $+10
	ORG $+1
_pop_vehicle_trunk DW 050bH
	DB	'i', 00H
	ORG $+11
	ORG $+1
CONST	ENDS
PUBLIC	?ToggleRhinoInstantExplosionUponContact@CVehicle@@QAEXH@Z ; CVehicle::ToggleRhinoInstantExplosionUponContact
PUBLIC	?SetInvulnerable@CVehicle@@QAEXH@Z		; CVehicle::SetInvulnerable
PUBLIC	??0Vector3@@QAE@XZ				; Vector3::Vector3
PUBLIC	??0CVehicle@@QAE@HMMMM@Z			; CVehicle::CVehicle
EXTRN	?GetEntity@CEntity@@QAEPAU_ENTITY_TYPE@@XZ:PROC	; CEntity::GetEntity
EXTRN	?SetPosition@CEntity@@QAEXUVector3@@@Z:PROC	; CEntity::SetPosition
EXTRN	?GetPosition@CEntity@@QAEXPAUVector3@@@Z:PROC	; CEntity::GetPosition
EXTRN	?SetEntity@CEntity@@QAEXPAU_ENTITY_TYPE@@@Z:PROC ; CEntity::SetEntity
EXTRN	?GetVehicleFromIndex@CPools@@SGPAU_VEHICLE_TYPE@@H@Z:PROC ; CPools::GetVehicleFromIndex
EXTRN	?ScriptCommand@@YAHPBUSCRIPT_COMMAND@@ZZ:PROC	; ScriptCommand
EXTRN	__imp__Sleep@4:PROC
EXTRN	?LoadRequestedModels@CGame@@QAEXXZ:PROC		; CGame::LoadRequestedModels
EXTRN	?RequestModel@CGame@@QAEXH@Z:PROC		; CGame::RequestModel
EXTRN	?IsModelLoaded@CGame@@QAEHH@Z:PROC		; CGame::IsModelLoaded
EXTRN	?pGame@@3PAVCGame@@A:DWORD			; pGame
EXTRN	__fltused:DWORD
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT rtc$TMZ
; File d:\vice-players-master\client\game\cvehicle.cpp
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu /ZI
rtc$IMZ	ENDS
;	COMDAT ??0CVehicle@@QAE@HMMMM@Z
_TEXT	SEGMENT
_pVehicle$ = -52					; size = 4
_vPos$ = -40						; size = 12
_dwRetID$ = -20						; size = 4
_this$ = -8						; size = 4
_iType$ = 8						; size = 4
_fPosX$ = 12						; size = 4
_fPosY$ = 16						; size = 4
_fPosZ$ = 20						; size = 4
_fRotation$ = 24					; size = 4
??0CVehicle@@QAE@HMMMM@Z PROC				; CVehicle::CVehicle, COMDAT
; _this$ = ecx

; 21   : {	

	push	ebp
	mov	ebp, esp
	sub	esp, 248				; 000000f8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-248]
	mov	ecx, 62					; 0000003eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 22   : 	DWORD dwRetID=0;

	mov	DWORD PTR _dwRetID$[ebp], 0

; 23   : 	m_dwGTAId = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 24   : 	m_bIsInvulnerable = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 25   : 
; 26   : 	// Is the model not loaded?
; 27   : 	if(!pGame->IsModelLoaded(iType))

	mov	eax, DWORD PTR _iType$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?pGame@@3PAVCGame@@A	; pGame
	call	?IsModelLoaded@CGame@@QAEHH@Z		; CGame::IsModelLoaded
	test	eax, eax
	jne	SHORT $LN1@CVehicle

; 28   : 	{
; 29   : 		// Request the model
; 30   : 		pGame->RequestModel(iType);

	mov	eax, DWORD PTR _iType$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?pGame@@3PAVCGame@@A	; pGame
	call	?RequestModel@CGame@@QAEXH@Z		; CGame::RequestModel

; 31   : 
; 32   : 		// Load all requested models
; 33   : 		pGame->LoadRequestedModels();

	mov	ecx, DWORD PTR ?pGame@@3PAVCGame@@A	; pGame
	call	?LoadRequestedModels@CGame@@QAEXXZ	; CGame::LoadRequestedModels
$LN2@CVehicle:

; 34   : 
; 35   : 		// Wait for the model to load
; 36   : 		while(!pGame->IsModelLoaded(iType))

	mov	eax, DWORD PTR _iType$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?pGame@@3PAVCGame@@A	; pGame
	call	?IsModelLoaded@CGame@@QAEHH@Z		; CGame::IsModelLoaded
	test	eax, eax
	jne	SHORT $LN1@CVehicle

; 37   : 		{
; 38   : 			Sleep(2);

	mov	esi, esp
	push	2
	call	DWORD PTR __imp__Sleep@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 39   : 		}

	jmp	SHORT $LN2@CVehicle
$LN1@CVehicle:

; 40   : 	}
; 41   : 
; 42   : 	ScriptCommand(&create_car, iType, fPosX, fPosY, fPosZ, &dwRetID);

	lea	eax, DWORD PTR _dwRetID$[ebp]
	push	eax
	fld	DWORD PTR _fPosZ$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	fld	DWORD PTR _fPosY$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	fld	DWORD PTR _fPosX$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _iType$[ebp]
	push	ecx
	push	OFFSET _create_car
	call	?ScriptCommand@@YAHPBUSCRIPT_COMMAND@@ZZ ; ScriptCommand
	add	esp, 36					; 00000024H

; 43   : 	ScriptCommand(&set_car_z_angle, dwRetID, fRotation);

	fld	DWORD PTR _fRotation$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	eax, DWORD PTR _dwRetID$[ebp]
	push	eax
	push	OFFSET _set_car_z_angle
	call	?ScriptCommand@@YAHPBUSCRIPT_COMMAND@@ZZ ; ScriptCommand
	add	esp, 16					; 00000010H

; 44   : 	SetEntity((ENTITY_TYPE*)CPools::GetVehicleFromIndex(dwRetID));

	mov	eax, DWORD PTR _dwRetID$[ebp]
	push	eax
	call	?GetVehicleFromIndex@CPools@@SGPAU_VEHICLE_TYPE@@H@Z ; CPools::GetVehicleFromIndex
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetEntity@CEntity@@QAEXPAU_ENTITY_TYPE@@@Z ; CEntity::SetEntity

; 45   : 	m_dwGTAId = dwRetID;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _dwRetID$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 46   : 
; 47   : 	Vector3 vPos;

	lea	ecx, DWORD PTR _vPos$[ebp]
	call	??0Vector3@@QAE@XZ			; Vector3::Vector3

; 48   : 	GetPosition(&vPos);

	lea	eax, DWORD PTR _vPos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPosition@CEntity@@QAEXPAUVector3@@@Z ; CEntity::GetPosition

; 49   : 	vPos.Z = fPosZ;

	fld	DWORD PTR _fPosZ$[ebp]
	fstp	DWORD PTR _vPos$[ebp+8]

; 50   : 	SetPosition(vPos);

	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	ecx, DWORD PTR _vPos$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _vPos$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _vPos$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetPosition@CEntity@@QAEXUVector3@@@Z	; CEntity::SetPosition

; 51   : 
; 52   : 	VEHICLE_TYPE * pVehicle = (VEHICLE_TYPE *)GetEntity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetEntity@CEntity@@QAEPAU_ENTITY_TYPE@@XZ ; CEntity::GetEntity
	mov	DWORD PTR _pVehicle$[ebp], eax

; 53   : 	pVehicle->dwDoorsLocked = 0;

	mov	eax, DWORD PTR _pVehicle$[ebp]
	mov	DWORD PTR [eax+560], 0

; 54   : 	//m_pEntity->byteLockedFlags = 1;
; 55   : 
; 56   : 	SetInvulnerable(TRUE);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetInvulnerable@CVehicle@@QAEXH@Z	; CVehicle::SetInvulnerable

; 57   : 	ToggleRhinoInstantExplosionUponContact(FALSE);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ToggleRhinoInstantExplosionUponContact@CVehicle@@QAEXH@Z ; CVehicle::ToggleRhinoInstantExplosionUponContact

; 58   : 	m_bDead = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 59   : }

	mov	eax, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@CVehicle
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 248				; 000000f8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
	npad	2
$LN9@CVehicle:
	DD	2
	DD	$LN8@CVehicle
$LN8@CVehicle:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN6@CVehicle
	DD	-40					; ffffffd8H
	DD	12					; 0000000cH
	DD	$LN7@CVehicle
$LN7@CVehicle:
	DB	118					; 00000076H
	DB	80					; 00000050H
	DB	111					; 0000006fH
	DB	115					; 00000073H
	DB	0
$LN6@CVehicle:
	DB	100					; 00000064H
	DB	119					; 00000077H
	DB	82					; 00000052H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	73					; 00000049H
	DB	68					; 00000044H
	DB	0
??0CVehicle@@QAE@HMMMM@Z ENDP				; CVehicle::CVehicle
_TEXT	ENDS
PUBLIC	??1CVehicle@@QAE@XZ				; CVehicle::~CVehicle
EXTRN	?Remove@CWorld@@SAXPAU_ENTITY_TYPE@@@Z:PROC	; CWorld::Remove
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1CVehicle@@QAE@XZ
_TEXT	SEGMENT
_pVehicle$ = -20					; size = 4
_this$ = -8						; size = 4
??1CVehicle@@QAE@XZ PROC				; CVehicle::~CVehicle, COMDAT
; _this$ = ecx

; 64   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 65   : 	// Get the vehicle pointer
; 66   : 	VEHICLE_TYPE * pVehicle = (VEHICLE_TYPE *)GetEntity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetEntity@CEntity@@QAEPAU_ENTITY_TYPE@@XZ ; CEntity::GetEntity
	mov	DWORD PTR _pVehicle$[ebp], eax

; 67   : 
; 68   : 	// Remove ourself from the world
; 69   : 	CWorld::Remove((ENTITY_TYPE *)pVehicle);

	mov	eax, DWORD PTR _pVehicle$[ebp]
	push	eax
	call	?Remove@CWorld@@SAXPAU_ENTITY_TYPE@@@Z	; CWorld::Remove
	add	esp, 4

; 70   : 
; 71   : 	// Remove all references to ourself
; 72   : 	CWorld::Remove((ENTITY_TYPE *)pVehicle);

	mov	eax, DWORD PTR _pVehicle$[ebp]
	push	eax
	call	?Remove@CWorld@@SAXPAU_ENTITY_TYPE@@@Z	; CWorld::Remove
	add	esp, 4

; 73   : 
; 74   : 	// Call class destructor
; 75   : 	_asm
; 76   : 	{
; 77   : 		mov ecx, pVehicle

	mov	ecx, DWORD PTR _pVehicle$[ebp]

; 78   : 		mov ebx, [ecx]

	mov	ebx, DWORD PTR [ecx]

; 79   : 		push 1

	push	1

; 80   : 		call [ebx+8]

	call	DWORD PTR [ebx+8]

; 81   : 	}
; 82   : 
; 83   : 	// Set our pointer to null
; 84   : 	SetEntity(NULL);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetEntity@CEntity@@QAEXPAU_ENTITY_TYPE@@@Z ; CEntity::SetEntity

; 85   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1CVehicle@@QAE@XZ ENDP				; CVehicle::~CVehicle
_TEXT	ENDS
PUBLIC	?GetVehicle@CVehicle@@QAEPAU_VEHICLE_TYPE@@XZ	; CVehicle::GetVehicle
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?GetVehicle@CVehicle@@QAEPAU_VEHICLE_TYPE@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetVehicle@CVehicle@@QAEPAU_VEHICLE_TYPE@@XZ PROC	; CVehicle::GetVehicle, COMDAT
; _this$ = ecx

; 90   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 91   : 	return (VEHICLE_TYPE *)GetEntity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetEntity@CEntity@@QAEPAU_ENTITY_TYPE@@XZ ; CEntity::GetEntity

; 92   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetVehicle@CVehicle@@QAEPAU_VEHICLE_TYPE@@XZ ENDP	; CVehicle::GetVehicle
_TEXT	ENDS
PUBLIC	__real@3e99999a
PUBLIC	__real@be99999a
PUBLIC	__real@0000000000000000
PUBLIC	?EnforceWorldBoundries@CVehicle@@QAEXMMMM@Z	; CVehicle::EnforceWorldBoundries
EXTRN	?SetMoveSpeed@CPhysical@@QAEXUVector3@@@Z:PROC	; CPhysical::SetMoveSpeed
EXTRN	?GetMoveSpeed@CPhysical@@QAEXPAUVector3@@@Z:PROC ; CPhysical::GetMoveSpeed
;	COMDAT __real@3e99999a
CONST	SEGMENT
__real@3e99999a DD 03e99999ar			; 0.3
CONST	ENDS
;	COMDAT __real@be99999a
CONST	SEGMENT
__real@be99999a DD 0be99999ar			; -0.3
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?EnforceWorldBoundries@CVehicle@@QAEXMMMM@Z
_TEXT	SEGMENT
_vecMoveSpeed$ = -48					; size = 12
_vPos$ = -28						; size = 12
_this$ = -8						; size = 4
_fPX$ = 8						; size = 4
_fZX$ = 12						; size = 4
_fPY$ = 16						; size = 4
_fNY$ = 20						; size = 4
?EnforceWorldBoundries@CVehicle@@QAEXMMMM@Z PROC	; CVehicle::EnforceWorldBoundries, COMDAT
; _this$ = ecx

; 97   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 98   : 	Vector3 vPos;

	lea	ecx, DWORD PTR _vPos$[ebp]
	call	??0Vector3@@QAE@XZ			; Vector3::Vector3

; 99   : 	Vector3 vecMoveSpeed;

	lea	ecx, DWORD PTR _vecMoveSpeed$[ebp]
	call	??0Vector3@@QAE@XZ			; Vector3::Vector3

; 100  : 
; 101  : 	if(!GetEntity()) return;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetEntity@CEntity@@QAEPAU_ENTITY_TYPE@@XZ ; CEntity::GetEntity
	test	eax, eax
	jne	SHORT $LN12@EnforceWor
	jmp	$LN13@EnforceWor
$LN12@EnforceWor:

; 102  : 
; 103  : 	GetPosition(&vPos);

	lea	eax, DWORD PTR _vPos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPosition@CEntity@@QAEXPAUVector3@@@Z ; CEntity::GetPosition

; 104  : 	GetMoveSpeed(&vecMoveSpeed);

	lea	eax, DWORD PTR _vecMoveSpeed$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMoveSpeed@CPhysical@@QAEXPAUVector3@@@Z ; CPhysical::GetMoveSpeed

; 105  : 
; 106  : 	if(vPos.X > fPX) // greatest X coord check

	fld	DWORD PTR _vPos$[ebp]
	fld	DWORD PTR _fPX$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN11@EnforceWor

; 107  : 	{
; 108  : 		if(vecMoveSpeed.X != 0.0f) {

	fld	DWORD PTR _vecMoveSpeed$[ebp]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN10@EnforceWor

; 109  : 			vecMoveSpeed.X = -0.3f;

	fld	DWORD PTR __real@be99999a
	fstp	DWORD PTR _vecMoveSpeed$[ebp]
$LN10@EnforceWor:

; 110  : 		}
; 111  : 		SetMoveSpeed(vecMoveSpeed);

	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	ecx, DWORD PTR _vecMoveSpeed$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _vecMoveSpeed$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _vecMoveSpeed$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMoveSpeed@CPhysical@@QAEXUVector3@@@Z ; CPhysical::SetMoveSpeed
	jmp	$LN13@EnforceWor

; 112  : 		return;

	jmp	$LN2@EnforceWor
$LN11@EnforceWor:

; 113  : 	}
; 114  : 	else if(vPos.X < fZX)  // least X coord check

	fld	DWORD PTR _vPos$[ebp]
	fld	DWORD PTR _fZX$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN8@EnforceWor

; 115  : 	{
; 116  : 		if(vecMoveSpeed.X != 0.0f) {

	fld	DWORD PTR _vecMoveSpeed$[ebp]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN7@EnforceWor

; 117  : 			vecMoveSpeed.X = 0.3f;

	fld	DWORD PTR __real@3e99999a
	fstp	DWORD PTR _vecMoveSpeed$[ebp]
$LN7@EnforceWor:

; 118  : 		}
; 119  : 		SetMoveSpeed(vecMoveSpeed);

	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	ecx, DWORD PTR _vecMoveSpeed$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _vecMoveSpeed$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _vecMoveSpeed$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMoveSpeed@CPhysical@@QAEXUVector3@@@Z ; CPhysical::SetMoveSpeed
	jmp	$LN13@EnforceWor

; 120  : 		return;

	jmp	$LN2@EnforceWor
$LN8@EnforceWor:

; 121  : 	}
; 122  : 	else if(vPos.Y > fPY) // Y coord check

	fld	DWORD PTR _vPos$[ebp+4]
	fld	DWORD PTR _fPY$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN5@EnforceWor

; 123  : 	{
; 124  : 		if(vecMoveSpeed.Y != 0.0f) {

	fld	DWORD PTR _vecMoveSpeed$[ebp+4]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN4@EnforceWor

; 125  : 			vecMoveSpeed.Y = -0.3f;

	fld	DWORD PTR __real@be99999a
	fstp	DWORD PTR _vecMoveSpeed$[ebp+4]
$LN4@EnforceWor:

; 126  : 		}
; 127  : 
; 128  : 		SetMoveSpeed(vecMoveSpeed);

	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	ecx, DWORD PTR _vecMoveSpeed$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _vecMoveSpeed$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _vecMoveSpeed$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMoveSpeed@CPhysical@@QAEXUVector3@@@Z ; CPhysical::SetMoveSpeed
	jmp	SHORT $LN13@EnforceWor

; 129  : 		return;

	jmp	SHORT $LN2@EnforceWor
$LN5@EnforceWor:

; 130  : 	}
; 131  : 	else if(vPos.Y < fNY)

	fld	DWORD PTR _vPos$[ebp+4]
	fld	DWORD PTR _fNY$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN2@EnforceWor

; 132  : 	{
; 133  : 		if(vecMoveSpeed.Y != 0.0f) {

	fld	DWORD PTR _vecMoveSpeed$[ebp+4]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN1@EnforceWor

; 134  : 			vecMoveSpeed.Y = 0.3f;

	fld	DWORD PTR __real@3e99999a
	fstp	DWORD PTR _vecMoveSpeed$[ebp+4]
$LN1@EnforceWor:

; 135  : 		}
; 136  : 
; 137  : 		SetMoveSpeed(vecMoveSpeed);

	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	ecx, DWORD PTR _vecMoveSpeed$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _vecMoveSpeed$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _vecMoveSpeed$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMoveSpeed@CPhysical@@QAEXUVector3@@@Z ; CPhysical::SetMoveSpeed
$LN2@EnforceWor:
$LN13@EnforceWor:

; 138  : 		return;
; 139  : 	}
; 140  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN18@EnforceWor
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
	npad	1
$LN18@EnforceWor:
	DD	2
	DD	$LN17@EnforceWor
$LN17@EnforceWor:
	DD	-28					; ffffffe4H
	DD	12					; 0000000cH
	DD	$LN15@EnforceWor
	DD	-48					; ffffffd0H
	DD	12					; 0000000cH
	DD	$LN16@EnforceWor
$LN16@EnforceWor:
	DB	118					; 00000076H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	77					; 0000004dH
	DB	111					; 0000006fH
	DB	118					; 00000076H
	DB	101					; 00000065H
	DB	83					; 00000053H
	DB	112					; 00000070H
	DB	101					; 00000065H
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	0
$LN15@EnforceWor:
	DB	118					; 00000076H
	DB	80					; 00000050H
	DB	111					; 0000006fH
	DB	115					; 00000073H
	DB	0
?EnforceWorldBoundries@CVehicle@@QAEXMMMM@Z ENDP	; CVehicle::EnforceWorldBoundries
_TEXT	ENDS
PUBLIC	?HasExceededWorldBoundries@CVehicle@@QAEHMMMM@Z	; CVehicle::HasExceededWorldBoundries
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?HasExceededWorldBoundries@CVehicle@@QAEHMMMM@Z
_TEXT	SEGMENT
_vPos$ = -28						; size = 12
_this$ = -8						; size = 4
_fPX$ = 8						; size = 4
_fZX$ = 12						; size = 4
_fPY$ = 16						; size = 4
_fNY$ = 20						; size = 4
?HasExceededWorldBoundries@CVehicle@@QAEHMMMM@Z PROC	; CVehicle::HasExceededWorldBoundries, COMDAT
; _this$ = ecx

; 145  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 224				; 000000e0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-224]
	mov	ecx, 56					; 00000038H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 146  : 	Vector3 vPos;

	lea	ecx, DWORD PTR _vPos$[ebp]
	call	??0Vector3@@QAE@XZ			; Vector3::Vector3

; 147  : 
; 148  : 	if(!GetEntity()) return FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetEntity@CEntity@@QAEPAU_ENTITY_TYPE@@XZ ; CEntity::GetEntity
	test	eax, eax
	jne	SHORT $LN8@HasExceede
	xor	eax, eax
	jmp	SHORT $LN9@HasExceede
$LN8@HasExceede:

; 149  : 
; 150  : 	GetPosition(&vPos);

	lea	eax, DWORD PTR _vPos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPosition@CEntity@@QAEXPAUVector3@@@Z ; CEntity::GetPosition

; 151  : 
; 152  : 	if(vPos.X > fPX) {

	fld	DWORD PTR _vPos$[ebp]
	fld	DWORD PTR _fPX$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN7@HasExceede

; 153  : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $LN9@HasExceede
	jmp	SHORT $LN1@HasExceede
$LN7@HasExceede:

; 154  : 	}
; 155  : 	else if(vPos.X < fZX) {

	fld	DWORD PTR _vPos$[ebp]
	fld	DWORD PTR _fZX$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN5@HasExceede

; 156  : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $LN9@HasExceede
	jmp	SHORT $LN1@HasExceede
$LN5@HasExceede:

; 157  : 	}
; 158  : 	else if(vPos.Y > fPY) {

	fld	DWORD PTR _vPos$[ebp+4]
	fld	DWORD PTR _fPY$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN3@HasExceede

; 159  : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $LN9@HasExceede
	jmp	SHORT $LN1@HasExceede
$LN3@HasExceede:

; 160  : 	}
; 161  : 	else if(vPos.Y < fNY) {

	fld	DWORD PTR _vPos$[ebp+4]
	fld	DWORD PTR _fNY$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN1@HasExceede

; 162  : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $LN9@HasExceede
$LN1@HasExceede:

; 163  : 	}
; 164  : 	return FALSE;

	xor	eax, eax
$LN9@HasExceede:

; 165  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN13@HasExceede
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 224				; 000000e0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
	npad	2
$LN13@HasExceede:
	DD	1
	DD	$LN12@HasExceede
$LN12@HasExceede:
	DD	-28					; ffffffe4H
	DD	12					; 0000000cH
	DD	$LN11@HasExceede
$LN11@HasExceede:
	DB	118					; 00000076H
	DB	80					; 00000050H
	DB	111					; 0000006fH
	DB	115					; 00000073H
	DB	0
?HasExceededWorldBoundries@CVehicle@@QAEHMMMM@Z ENDP	; CVehicle::HasExceededWorldBoundries
_TEXT	ENDS
PUBLIC	?sqrt@@YAMM@Z					; sqrt
PUBLIC	__real@461c4000
PUBLIC	?FindPlayerPed@CGame@@QAEPAVCPlayerPed@@XZ	; CGame::FindPlayerPed
PUBLIC	?GetDistanceFromLocalPlayerPed@CVehicle@@QAEMXZ	; CVehicle::GetDistanceFromLocalPlayerPed
;	COMDAT __real@461c4000
CONST	SEGMENT
__real@461c4000 DD 0461c4000r			; 10000
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?GetDistanceFromLocalPlayerPed@CVehicle@@QAEMXZ
_TEXT	SEGMENT
tv158 = -284						; size = 4
_pLocalPlayerPed$ = -84					; size = 4
_fSY$ = -72						; size = 4
_fSX$ = -60						; size = 4
_vFromPlayer$ = -48					; size = 12
_vThisVehicle$ = -28					; size = 12
_this$ = -8						; size = 4
?GetDistanceFromLocalPlayerPed@CVehicle@@QAEMXZ PROC	; CVehicle::GetDistanceFromLocalPlayerPed, COMDAT
; _this$ = ecx

; 170  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 284				; 0000011cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-284]
	mov	ecx, 71					; 00000047H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 171  : 	Vector3 vThisVehicle;

	lea	ecx, DWORD PTR _vThisVehicle$[ebp]
	call	??0Vector3@@QAE@XZ			; Vector3::Vector3

; 172  : 	Vector3 vFromPlayer;

	lea	ecx, DWORD PTR _vFromPlayer$[ebp]
	call	??0Vector3@@QAE@XZ			; Vector3::Vector3

; 173  : 	float  fSX,fSY;
; 174  : 
; 175  : 	CPlayerPed *pLocalPlayerPed = pGame->FindPlayerPed();

	mov	ecx, DWORD PTR ?pGame@@3PAVCGame@@A	; pGame
	call	?FindPlayerPed@CGame@@QAEPAVCPlayerPed@@XZ ; CGame::FindPlayerPed
	mov	DWORD PTR _pLocalPlayerPed$[ebp], eax

; 176  : 
; 177  : 	if(!GetEntity()) return 10000.0f; // very far away

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetEntity@CEntity@@QAEPAU_ENTITY_TYPE@@XZ ; CEntity::GetEntity
	test	eax, eax
	jne	SHORT $LN2@GetDistanc
	fld	DWORD PTR __real@461c4000
	jmp	SHORT $LN3@GetDistanc
$LN2@GetDistanc:

; 178  : 	if(!pLocalPlayerPed) return 10000.0f; // very far away

	cmp	DWORD PTR _pLocalPlayerPed$[ebp], 0
	jne	SHORT $LN1@GetDistanc
	fld	DWORD PTR __real@461c4000
	jmp	SHORT $LN3@GetDistanc
$LN1@GetDistanc:

; 179  : 	
; 180  : 	GetPosition(&vThisVehicle);

	lea	eax, DWORD PTR _vThisVehicle$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPosition@CEntity@@QAEXPAUVector3@@@Z ; CEntity::GetPosition

; 181  : 	pLocalPlayerPed->GetPosition(&vFromPlayer);

	lea	eax, DWORD PTR _vFromPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLocalPlayerPed$[ebp]
	call	?GetPosition@CEntity@@QAEXPAUVector3@@@Z ; CEntity::GetPosition

; 182  : 	
; 183  : 	fSX = (vThisVehicle.X - vFromPlayer.X) * (vThisVehicle.X - vFromPlayer.X);

	fld	DWORD PTR _vThisVehicle$[ebp]
	fsub	DWORD PTR _vFromPlayer$[ebp]
	fld	DWORD PTR _vThisVehicle$[ebp]
	fsub	DWORD PTR _vFromPlayer$[ebp]
	fmulp	ST(1), ST(0)
	fstp	DWORD PTR _fSX$[ebp]

; 184  : 	fSY = (vThisVehicle.Y - vFromPlayer.Y) * (vThisVehicle.Y - vFromPlayer.Y);

	fld	DWORD PTR _vThisVehicle$[ebp+4]
	fsub	DWORD PTR _vFromPlayer$[ebp+4]
	fld	DWORD PTR _vThisVehicle$[ebp+4]
	fsub	DWORD PTR _vFromPlayer$[ebp+4]
	fmulp	ST(1), ST(0)
	fstp	DWORD PTR _fSY$[ebp]

; 185  : 	
; 186  : 	return (float)sqrt(fSX + fSY);

	fld	DWORD PTR _fSX$[ebp]
	fadd	DWORD PTR _fSY$[ebp]
	fstp	DWORD PTR tv158[ebp]
	fld	DWORD PTR tv158[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
$LN3@GetDistanc:

; 187  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@GetDistanc
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 284				; 0000011cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@GetDistanc:
	DD	2
	DD	$LN7@GetDistanc
$LN7@GetDistanc:
	DD	-28					; ffffffe4H
	DD	12					; 0000000cH
	DD	$LN5@GetDistanc
	DD	-48					; ffffffd0H
	DD	12					; 0000000cH
	DD	$LN6@GetDistanc
$LN6@GetDistanc:
	DB	118					; 00000076H
	DB	70					; 00000046H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	109					; 0000006dH
	DB	80					; 00000050H
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$LN5@GetDistanc:
	DB	118					; 00000076H
	DB	84					; 00000054H
	DB	104					; 00000068H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	86					; 00000056H
	DB	101					; 00000065H
	DB	104					; 00000068H
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
?GetDistanceFromLocalPlayerPed@CVehicle@@QAEMXZ ENDP	; CVehicle::GetDistanceFromLocalPlayerPed
_TEXT	ENDS
PUBLIC	?SetImmunities@CVehicle@@QAEXHHHHH@Z		; CVehicle::SetImmunities
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?SetInvulnerable@CVehicle@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_bInv$ = 8						; size = 4
?SetInvulnerable@CVehicle@@QAEXH@Z PROC			; CVehicle::SetInvulnerable, COMDAT
; _this$ = ecx

; 192  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 193  : 	if(!GetEntity()) return;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetEntity@CEntity@@QAEPAU_ENTITY_TYPE@@XZ ; CEntity::GetEntity
	test	eax, eax
	jne	SHORT $LN4@SetInvulne
	jmp	SHORT $LN5@SetInvulne
$LN4@SetInvulne:

; 194  : 
; 195  : 	if(bInv && m_bIsInvulnerable == FALSE) {

	cmp	DWORD PTR _bInv$[ebp], 0
	je	SHORT $LN3@SetInvulne
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN3@SetInvulne

; 196  : 		SetImmunities(1, 1, 1, 1, 1);

	push	1
	push	1
	push	1
	push	1
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetImmunities@CVehicle@@QAEXHHHHH@Z	; CVehicle::SetImmunities

; 197  : 		m_bIsInvulnerable = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 1
	jmp	SHORT $LN5@SetInvulne
$LN3@SetInvulne:

; 198  : 	}
; 199  : 	else if(!bInv && m_bIsInvulnerable == TRUE)	{

	cmp	DWORD PTR _bInv$[ebp], 0
	jne	SHORT $LN5@SetInvulne
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 1
	jne	SHORT $LN5@SetInvulne

; 200  : 		SetImmunities(0, 0, 0, 0, 0);

	push	0
	push	0
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetImmunities@CVehicle@@QAEXHHHHH@Z	; CVehicle::SetImmunities

; 201  : 		m_bIsInvulnerable = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
$LN5@SetInvulne:

; 202  : 	}
; 203  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SetInvulnerable@CVehicle@@QAEXH@Z ENDP			; CVehicle::SetInvulnerable
_TEXT	ENDS
PUBLIC	?SetLockedState@CVehicle@@QAEXH@Z		; CVehicle::SetLockedState
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?SetLockedState@CVehicle@@QAEXH@Z
_TEXT	SEGMENT
_pPhysical$ = -20					; size = 4
_this$ = -8						; size = 4
_iLocked$ = 8						; size = 4
?SetLockedState@CVehicle@@QAEXH@Z PROC			; CVehicle::SetLockedState, COMDAT
; _this$ = ecx

; 207  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 208  : 	PHYSICAL_TYPE * pPhysical = (PHYSICAL_TYPE *)GetEntity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetEntity@CEntity@@QAEPAU_ENTITY_TYPE@@XZ ; CEntity::GetEntity
	mov	DWORD PTR _pPhysical$[ebp], eax

; 209  : 
; 210  : 	if(pPhysical)

	cmp	DWORD PTR _pPhysical$[ebp], 0
	je	SHORT $LN2@SetLockedS

; 211  : 	{
; 212  : 		pPhysical->byteLockedFlags = iLocked;

	mov	eax, DWORD PTR _pPhysical$[ebp]
	mov	cl, BYTE PTR _iLocked$[ebp]
	mov	BYTE PTR [eax+283], cl
$LN2@SetLockedS:

; 213  : 	}
; 214  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SetLockedState@CVehicle@@QAEXH@Z ENDP			; CVehicle::SetLockedState
_TEXT	ENDS
PUBLIC	?VerifyControlState@CVehicle@@QAEXXZ		; CVehicle::VerifyControlState
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?VerifyControlState@CVehicle@@QAEXXZ
_TEXT	SEGMENT
_pVehicle$ = -20					; size = 4
_this$ = -8						; size = 4
?VerifyControlState@CVehicle@@QAEXXZ PROC		; CVehicle::VerifyControlState, COMDAT
; _this$ = ecx

; 221  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 222  : 	VEHICLE_TYPE * pVehicle = (VEHICLE_TYPE *)GetEntity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetEntity@CEntity@@QAEPAU_ENTITY_TYPE@@XZ ; CEntity::GetEntity
	mov	DWORD PTR _pVehicle$[ebp], eax

; 223  : 
; 224  : 	if(pVehicle)

	cmp	DWORD PTR _pVehicle$[ebp], 0
	je	SHORT $LN3@VerifyCont

; 225  : 	{
; 226  : 		if(!pVehicle->pDriver && (pVehicle->physical.entity.nControlFlags == 0x2))

	mov	eax, DWORD PTR _pVehicle$[ebp]
	cmp	DWORD PTR [eax+424], 0
	jne	SHORT $LN3@VerifyCont
	mov	eax, DWORD PTR _pVehicle$[ebp]
	movzx	ecx, BYTE PTR [eax+80]
	cmp	ecx, 2
	jne	SHORT $LN3@VerifyCont

; 227  : 		{
; 228  : 			pVehicle->physical.entity.nControlFlags = 0x22;

	mov	eax, DWORD PTR _pVehicle$[ebp]
	mov	BYTE PTR [eax+80], 34			; 00000022H
$LN3@VerifyCont:

; 229  : 		}
; 230  : 	}
; 231  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?VerifyControlState@CVehicle@@QAEXXZ ENDP		; CVehicle::VerifyControlState
_TEXT	ENDS
PUBLIC	__real@00000000
PUBLIC	?GetHealth@CVehicle@@QAEMXZ			; CVehicle::GetHealth
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?GetHealth@CVehicle@@QAEMXZ
_TEXT	SEGMENT
_pVehicle$ = -20					; size = 4
_this$ = -8						; size = 4
?GetHealth@CVehicle@@QAEMXZ PROC			; CVehicle::GetHealth, COMDAT
; _this$ = ecx

; 236  : {	

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 237  : 	VEHICLE_TYPE * pVehicle = (VEHICLE_TYPE *)GetEntity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetEntity@CEntity@@QAEPAU_ENTITY_TYPE@@XZ ; CEntity::GetEntity
	mov	DWORD PTR _pVehicle$[ebp], eax

; 238  : 
; 239  : 	if(pVehicle)

	cmp	DWORD PTR _pVehicle$[ebp], 0
	je	SHORT $LN1@GetHealth

; 240  : 	{
; 241  : 		return pVehicle->fHealth;

	mov	eax, DWORD PTR _pVehicle$[ebp]
	fld	DWORD PTR [eax+516]
	jmp	SHORT $LN2@GetHealth
$LN1@GetHealth:

; 242  : 	}
; 243  : 
; 244  : 	return 0.0f;

	fldz
$LN2@GetHealth:

; 245  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetHealth@CVehicle@@QAEMXZ ENDP			; CVehicle::GetHealth
_TEXT	ENDS
PUBLIC	?SetHealth@CVehicle@@QAEXM@Z			; CVehicle::SetHealth
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?SetHealth@CVehicle@@QAEXM@Z
_TEXT	SEGMENT
_pVehicle$ = -20					; size = 4
_this$ = -8						; size = 4
_fHealth$ = 8						; size = 4
?SetHealth@CVehicle@@QAEXM@Z PROC			; CVehicle::SetHealth, COMDAT
; _this$ = ecx

; 250  : {	

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 251  : 	VEHICLE_TYPE * pVehicle = (VEHICLE_TYPE *)GetEntity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetEntity@CEntity@@QAEPAU_ENTITY_TYPE@@XZ ; CEntity::GetEntity
	mov	DWORD PTR _pVehicle$[ebp], eax

; 252  : 
; 253  : 	if(pVehicle)

	cmp	DWORD PTR _pVehicle$[ebp], 0
	je	SHORT $LN1@SetHealth

; 254  : 	{
; 255  : 		pVehicle->fHealth = fHealth;

	mov	eax, DWORD PTR _pVehicle$[ebp]
	fld	DWORD PTR _fHealth$[ebp]
	fstp	DWORD PTR [eax+516]
$LN1@SetHealth:

; 256  : 	}
; 257  : }	

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SetHealth@CVehicle@@QAEXM@Z ENDP			; CVehicle::SetHealth
_TEXT	ENDS
PUBLIC	?SetColor@CVehicle@@QAEXHH@Z			; CVehicle::SetColor
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?SetColor@CVehicle@@QAEXHH@Z
_TEXT	SEGMENT
_pVehicle$ = -20					; size = 4
_this$ = -8						; size = 4
_iColor1$ = 8						; size = 4
_iColor2$ = 12						; size = 4
?SetColor@CVehicle@@QAEXHH@Z PROC			; CVehicle::SetColor, COMDAT
; _this$ = ecx

; 262  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 263  : 	VEHICLE_TYPE * pVehicle = (VEHICLE_TYPE *)GetEntity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetEntity@CEntity@@QAEPAU_ENTITY_TYPE@@XZ ; CEntity::GetEntity
	mov	DWORD PTR _pVehicle$[ebp], eax

; 264  : 
; 265  : 	if(pVehicle)

	cmp	DWORD PTR _pVehicle$[ebp], 0
	je	SHORT $LN2@SetColor

; 266  : 	{
; 267  : 		pVehicle->byteColors[0] = (BYTE)iColor1;

	mov	eax, DWORD PTR _pVehicle$[ebp]
	mov	cl, BYTE PTR _iColor1$[ebp]
	mov	BYTE PTR [eax+416], cl

; 268  : 		pVehicle->byteColors[1] = (BYTE)iColor2;

	mov	eax, DWORD PTR _pVehicle$[ebp]
	mov	cl, BYTE PTR _iColor2$[ebp]
	mov	BYTE PTR [eax+417], cl
$LN2@SetColor:

; 269  : 	}
; 270  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?SetColor@CVehicle@@QAEXHH@Z ENDP			; CVehicle::SetColor
_TEXT	ENDS
PUBLIC	?GetSubtype@CVehicle@@QAEEXZ			; CVehicle::GetSubtype
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?GetSubtype@CVehicle@@QAEEXZ
_TEXT	SEGMENT
_dwFlags$209374 = -32					; size = 4
_pVehicle$ = -20					; size = 4
_this$ = -8						; size = 4
?GetSubtype@CVehicle@@QAEEXZ PROC			; CVehicle::GetSubtype, COMDAT
; _this$ = ecx

; 275  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 276  : 	VEHICLE_TYPE * pVehicle = (VEHICLE_TYPE *)GetEntity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetEntity@CEntity@@QAEPAU_ENTITY_TYPE@@XZ ; CEntity::GetEntity
	mov	DWORD PTR _pVehicle$[ebp], eax

; 277  : 
; 278  : 	if(pVehicle)

	cmp	DWORD PTR _pVehicle$[ebp], 0
	je	SHORT $LN1@GetSubtype

; 279  : 	{
; 280  : 		DWORD dwFlags = pVehicle->pHandling->dwFlags;

	mov	eax, DWORD PTR _pVehicle$[ebp]
	mov	ecx, DWORD PTR [eax+288]
	mov	edx, DWORD PTR [ecx+204]
	mov	DWORD PTR _dwFlags$209374[ebp], edx

; 281  : 		_asm
; 282  : 		{
; 283  : 			mov eax, dwFlags

	mov	eax, DWORD PTR _dwFlags$209374[ebp]

; 284  : 			and eax, 0F0000h

	and	eax, 983040				; 000f0000H

; 285  : 			jz ret_car

	je	SHORT $ret_car$209375

; 286  : 			sub eax, 10000h

	sub	eax, 65536				; 00010000H

; 287  : 			jz ret_bike

	je	SHORT $ret_bike$209376

; 288  : 			sub eax, 10000h

	sub	eax, 65536				; 00010000H

; 289  : 			jz ret_heli

	je	SHORT $ret_heli$209377

; 290  : 			sub eax, 20000h

	sub	eax, 131072				; 00020000H

; 291  : 			jz ret_boat

	je	SHORT $ret_boat$209378

; 292  : 			sub eax, 40000h

	sub	eax, 262144				; 00040000H

; 293  : 			jz ret_plane

	je	SHORT $ret_plane$209379

; 294  : 		}
; 295  : 
; 296  : 		return VEHICLE_SUBTYPE_NONE;

	xor	al, al
	jmp	SHORT $LN2@GetSubtype
$ret_car$209375:

; 297  : 
; 298  : ret_car:
; 299  : 		return VEHICLE_SUBTYPE_CAR;

	mov	al, 1
	jmp	SHORT $LN2@GetSubtype
$ret_bike$209376:

; 300  : ret_bike:
; 301  : 		return VEHICLE_SUBTYPE_BIKE;

	mov	al, 2
	jmp	SHORT $LN2@GetSubtype
$ret_heli$209377:

; 302  : ret_heli:
; 303  : 		return VEHICLE_SUBTYPE_HELI;

	mov	al, 3
	jmp	SHORT $LN2@GetSubtype
$ret_boat$209378:

; 304  : ret_boat:
; 305  : 		return VEHICLE_SUBTYPE_BOAT;

	mov	al, 4
	jmp	SHORT $LN2@GetSubtype
$ret_plane$209379:

; 306  : ret_plane:
; 307  : 		return VEHICLE_SUBTYPE_PLANE;

	mov	al, 5
	jmp	SHORT $LN2@GetSubtype
$LN1@GetSubtype:

; 308  : 	}
; 309  : 
; 310  : 	return VEHICLE_SUBTYPE_NONE;

	xor	al, al
$LN2@GetSubtype:

; 311  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSubtype@CVehicle@@QAEEXZ ENDP			; CVehicle::GetSubtype
_TEXT	ENDS
PUBLIC	?HasSunk@CVehicle@@QAEHXZ			; CVehicle::HasSunk
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?HasSunk@CVehicle@@QAEHXZ
_TEXT	SEGMENT
_pPhysical$ = -20					; size = 4
_this$ = -8						; size = 4
?HasSunk@CVehicle@@QAEHXZ PROC				; CVehicle::HasSunk, COMDAT
; _this$ = ecx

; 316  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 317  : 	PHYSICAL_TYPE * pPhysical = (PHYSICAL_TYPE *)GetEntity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetEntity@CEntity@@QAEPAU_ENTITY_TYPE@@XZ ; CEntity::GetEntity
	mov	DWORD PTR _pPhysical$[ebp], eax

; 318  : 
; 319  : 	if(pPhysical)

	cmp	DWORD PTR _pPhysical$[ebp], 0
	je	SHORT $LN2@HasSunk

; 320  : 	{
; 321  : 		if(pPhysical->byteSunkFlags & 0x10)

	mov	eax, DWORD PTR _pPhysical$[ebp]
	movzx	ecx, BYTE PTR [eax+282]
	and	ecx, 16					; 00000010H
	je	SHORT $LN2@HasSunk

; 322  : 		{
; 323  : 			return TRUE;

	mov	eax, 1
	jmp	SHORT $LN3@HasSunk
$LN2@HasSunk:

; 324  : 		}
; 325  : 	}
; 326  : 
; 327  : 	return FALSE;

	xor	eax, eax
$LN3@HasSunk:

; 328  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?HasSunk@CVehicle@@QAEHXZ ENDP				; CVehicle::HasSunk
_TEXT	ENDS
PUBLIC	?IsDriverLocalPlayer@CVehicle@@QAEHXZ		; CVehicle::IsDriverLocalPlayer
EXTRN	?GamePool_FindPlayerPed@@YGPAU_PED_TYPE@@XZ:PROC ; GamePool_FindPlayerPed
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?IsDriverLocalPlayer@CVehicle@@QAEHXZ
_TEXT	SEGMENT
_pVehicle$ = -20					; size = 4
_this$ = -8						; size = 4
?IsDriverLocalPlayer@CVehicle@@QAEHXZ PROC		; CVehicle::IsDriverLocalPlayer, COMDAT
; _this$ = ecx

; 333  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 334  : 	VEHICLE_TYPE * pVehicle = (VEHICLE_TYPE *)GetEntity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetEntity@CEntity@@QAEPAU_ENTITY_TYPE@@XZ ; CEntity::GetEntity
	mov	DWORD PTR _pVehicle$[ebp], eax

; 335  : 
; 336  : 	if(pVehicle)

	cmp	DWORD PTR _pVehicle$[ebp], 0
	je	SHORT $LN2@IsDriverLo

; 337  : 	{
; 338  : 		if(pVehicle->pDriver == GamePool_FindPlayerPed())

	call	?GamePool_FindPlayerPed@@YGPAU_PED_TYPE@@XZ ; GamePool_FindPlayerPed
	mov	ecx, DWORD PTR _pVehicle$[ebp]
	cmp	DWORD PTR [ecx+424], eax
	jne	SHORT $LN2@IsDriverLo

; 339  : 		{
; 340  : 			return TRUE;

	mov	eax, 1
	jmp	SHORT $LN3@IsDriverLo
$LN2@IsDriverLo:

; 341  : 		}
; 342  : 	}
; 343  : 
; 344  : 	return FALSE;

	xor	eax, eax
$LN3@IsDriverLo:

; 345  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?IsDriverLocalPlayer@CVehicle@@QAEHXZ ENDP		; CVehicle::IsDriverLocalPlayer
_TEXT	ENDS
PUBLIC	?GetMaxPassengers@CVehicle@@QAEEXZ		; CVehicle::GetMaxPassengers
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?GetMaxPassengers@CVehicle@@QAEEXZ
_TEXT	SEGMENT
_pVehicle$ = -20					; size = 4
_this$ = -8						; size = 4
?GetMaxPassengers@CVehicle@@QAEEXZ PROC			; CVehicle::GetMaxPassengers, COMDAT
; _this$ = ecx

; 350  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 351  : 	VEHICLE_TYPE * pVehicle = (VEHICLE_TYPE *)GetEntity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetEntity@CEntity@@QAEPAU_ENTITY_TYPE@@XZ ; CEntity::GetEntity
	mov	DWORD PTR _pVehicle$[ebp], eax

; 352  : 
; 353  : 	if(pVehicle)

	cmp	DWORD PTR _pVehicle$[ebp], 0
	je	SHORT $LN1@GetMaxPass

; 354  : 	{
; 355  : 		return pVehicle->byteMaxPassengers;

	mov	eax, DWORD PTR _pVehicle$[ebp]
	mov	al, BYTE PTR [eax+464]
	jmp	SHORT $LN2@GetMaxPass
$LN1@GetMaxPass:

; 356  : 	}
; 357  : 
; 358  : 	return 0;

	xor	al, al
$LN2@GetMaxPass:

; 359  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetMaxPassengers@CVehicle@@QAEEXZ ENDP			; CVehicle::GetMaxPassengers
_TEXT	ENDS
PUBLIC	?GetDriver@CVehicle@@QAEPAU_PED_TYPE@@XZ	; CVehicle::GetDriver
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?GetDriver@CVehicle@@QAEPAU_PED_TYPE@@XZ
_TEXT	SEGMENT
_pVehicle$ = -20					; size = 4
_this$ = -8						; size = 4
?GetDriver@CVehicle@@QAEPAU_PED_TYPE@@XZ PROC		; CVehicle::GetDriver, COMDAT
; _this$ = ecx

; 364  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 365  : 	VEHICLE_TYPE * pVehicle = (VEHICLE_TYPE *)GetEntity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetEntity@CEntity@@QAEPAU_ENTITY_TYPE@@XZ ; CEntity::GetEntity
	mov	DWORD PTR _pVehicle$[ebp], eax

; 366  : 
; 367  : 	if(pVehicle)

	cmp	DWORD PTR _pVehicle$[ebp], 0
	je	SHORT $LN1@GetDriver

; 368  : 	{
; 369  : 		return pVehicle->pDriver;

	mov	eax, DWORD PTR _pVehicle$[ebp]
	mov	eax, DWORD PTR [eax+424]
	jmp	SHORT $LN2@GetDriver
$LN1@GetDriver:

; 370  : 	}
; 371  : 
; 372  : 	return NULL;

	xor	eax, eax
$LN2@GetDriver:

; 373  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDriver@CVehicle@@QAEPAU_PED_TYPE@@XZ ENDP		; CVehicle::GetDriver
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ?SetImmunities@CVehicle@@QAEXHHHHH@Z
_TEXT	SEGMENT
_pEntity$ = -20						; size = 4
_this$ = -8						; size = 4
_iIm1$ = 8						; size = 4
_iIm2$ = 12						; size = 4
_iIm3$ = 16						; size = 4
_iIm4$ = 20						; size = 4
_iIm5$ = 24						; size = 4
?SetImmunities@CVehicle@@QAEXHHHHH@Z PROC		; CVehicle::SetImmunities, COMDAT
; _this$ = ecx

; 378  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 379  : 	ENTITY_TYPE * pEntity = (ENTITY_TYPE *)GetEntity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetEntity@CEntity@@QAEPAU_ENTITY_TYPE@@XZ ; CEntity::GetEntity
	mov	DWORD PTR _pEntity$[ebp], eax

; 380  : 
; 381  : 	if(pEntity)

	cmp	DWORD PTR _pEntity$[ebp], 0
	je	$LN12@SetImmunit

; 382  : 	{
; 383  : 		if(iIm1) {

	cmp	DWORD PTR _iIm1$[ebp], 0
	je	SHORT $LN10@SetImmunit

; 384  : 			pEntity->byteUnkFlags2 = (pEntity->byteUnkFlags2 & 0xFD | 2);

	mov	eax, DWORD PTR _pEntity$[ebp]
	movzx	ecx, BYTE PTR [eax+83]
	and	ecx, 253				; 000000fdH
	or	ecx, 2
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	BYTE PTR [edx+83], cl

; 385  : 		} else {

	jmp	SHORT $LN9@SetImmunit
$LN10@SetImmunit:

; 386  : 			pEntity->byteUnkFlags2 &= 0xFD;

	mov	eax, DWORD PTR _pEntity$[ebp]
	movzx	ecx, BYTE PTR [eax+83]
	and	ecx, 253				; 000000fdH
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	BYTE PTR [edx+83], cl
$LN9@SetImmunit:

; 387  : 		}
; 388  : 
; 389  : 		if(iIm2) {

	cmp	DWORD PTR _iIm2$[ebp], 0
	je	SHORT $LN8@SetImmunit

; 390  : 			pEntity->byteUnkFlags2 = (pEntity->byteUnkFlags2 & 0xFB | 4);

	mov	eax, DWORD PTR _pEntity$[ebp]
	movzx	ecx, BYTE PTR [eax+83]
	and	ecx, 251				; 000000fbH
	or	ecx, 4
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	BYTE PTR [edx+83], cl

; 391  : 		} else {

	jmp	SHORT $LN7@SetImmunit
$LN8@SetImmunit:

; 392  : 			pEntity->byteUnkFlags2 &= 0xFB;

	mov	eax, DWORD PTR _pEntity$[ebp]
	movzx	ecx, BYTE PTR [eax+83]
	and	ecx, 251				; 000000fbH
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	BYTE PTR [edx+83], cl
$LN7@SetImmunit:

; 393  : 		}
; 394  : 
; 395  : 		if(iIm3) {

	cmp	DWORD PTR _iIm3$[ebp], 0
	je	SHORT $LN6@SetImmunit

; 396  : 			pEntity->byteUnkFlags1 = (pEntity->byteUnkFlags1 & 0xFD | 2);

	mov	eax, DWORD PTR _pEntity$[ebp]
	movzx	ecx, BYTE PTR [eax+82]
	and	ecx, 253				; 000000fdH
	or	ecx, 2
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	BYTE PTR [edx+82], cl

; 397  : 		} else {

	jmp	SHORT $LN5@SetImmunit
$LN6@SetImmunit:

; 398  : 			pEntity->byteUnkFlags1 &= 0xFD;

	mov	eax, DWORD PTR _pEntity$[ebp]
	movzx	ecx, BYTE PTR [eax+82]
	and	ecx, 253				; 000000fdH
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	BYTE PTR [edx+82], cl
$LN5@SetImmunit:

; 399  : 		}
; 400  : 
; 401  : 		if(iIm4) {

	cmp	DWORD PTR _iIm4$[ebp], 0
	je	SHORT $LN4@SetImmunit

; 402  : 			pEntity->byteUnkFlags2 = (pEntity->byteUnkFlags2 & 0xF7 | 8);

	mov	eax, DWORD PTR _pEntity$[ebp]
	movzx	ecx, BYTE PTR [eax+83]
	and	ecx, 247				; 000000f7H
	or	ecx, 8
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	BYTE PTR [edx+83], cl

; 403  : 		} else {

	jmp	SHORT $LN3@SetImmunit
$LN4@SetImmunit:

; 404  : 			pEntity->byteUnkFlags2 &= 0xF7u;

	mov	eax, DWORD PTR _pEntity$[ebp]
	movzx	ecx, BYTE PTR [eax+83]
	and	ecx, 247				; 000000f7H
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	BYTE PTR [edx+83], cl
$LN3@SetImmunit:

; 405  : 		}
; 406  : 
; 407  : 		if(iIm5) {

	cmp	DWORD PTR _iIm5$[ebp], 0
	je	SHORT $LN2@SetImmunit

; 408  : 			pEntity->byteUnkFlags2 = (pEntity->byteUnkFlags2 & 0xEF | 0x10);

	mov	eax, DWORD PTR _pEntity$[ebp]
	movzx	ecx, BYTE PTR [eax+83]
	and	ecx, 239				; 000000efH
	or	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	BYTE PTR [edx+83], cl

; 409  : 		} else {

	jmp	SHORT $LN12@SetImmunit
$LN2@SetImmunit:

; 410  : 			pEntity->byteUnkFlags2 &= 0xEFu;

	mov	eax, DWORD PTR _pEntity$[ebp]
	movzx	ecx, BYTE PTR [eax+83]
	and	ecx, 239				; 000000efH
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	BYTE PTR [edx+83], cl
$LN12@SetImmunit:

; 411  : 		}
; 412  : 	}
; 413  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?SetImmunities@CVehicle@@QAEXHHHHH@Z ENDP		; CVehicle::SetImmunities
_TEXT	ENDS
PUBLIC	?SetDead@CVehicle@@QAEXH@Z			; CVehicle::SetDead
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?SetDead@CVehicle@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_bDead$ = 8						; size = 4
?SetDead@CVehicle@@QAEXH@Z PROC				; CVehicle::SetDead, COMDAT
; _this$ = ecx

; 418  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 419  : 	m_bDead = bDead;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _bDead$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 420  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetDead@CVehicle@@QAEXH@Z ENDP				; CVehicle::SetDead
_TEXT	ENDS
PUBLIC	?IsDead@CVehicle@@QAEHXZ			; CVehicle::IsDead
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?IsDead@CVehicle@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?IsDead@CVehicle@@QAEHXZ PROC				; CVehicle::IsDead, COMDAT
; _this$ = ecx

; 425  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 426  : 	return m_bDead;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]

; 427  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsDead@CVehicle@@QAEHXZ ENDP				; CVehicle::IsDead
_TEXT	ENDS
PUBLIC	?PopTrunk@CVehicle@@QAEXXZ			; CVehicle::PopTrunk
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?PopTrunk@CVehicle@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?PopTrunk@CVehicle@@QAEXXZ PROC				; CVehicle::PopTrunk, COMDAT
; _this$ = ecx

; 432  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 433  : 	ScriptCommand(&pop_vehicle_trunk, m_dwGTAId);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	OFFSET _pop_vehicle_trunk
	call	?ScriptCommand@@YAHPBUSCRIPT_COMMAND@@ZZ ; ScriptCommand
	add	esp, 8

; 434  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?PopTrunk@CVehicle@@QAEXXZ ENDP				; CVehicle::PopTrunk
_TEXT	ENDS
EXTRN	?GetModelIndex@CEntity@@QAEGXZ:PROC		; CEntity::GetModelIndex
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?ToggleRhinoInstantExplosionUponContact@CVehicle@@QAEXH@Z
_TEXT	SEGMENT
_pAutomobile$209442 = -20				; size = 4
_this$ = -8						; size = 4
_iToggle$ = 8						; size = 4
?ToggleRhinoInstantExplosionUponContact@CVehicle@@QAEXH@Z PROC ; CVehicle::ToggleRhinoInstantExplosionUponContact, COMDAT
; _this$ = ecx

; 439  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 440  : 	if(GetModelIndex() == 162) // Rhino

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetModelIndex@CEntity@@QAEGXZ		; CEntity::GetModelIndex
	movzx	eax, ax
	cmp	eax, 162				; 000000a2H
	jne	SHORT $LN5@ToggleRhin

; 441  : 	{
; 442  : 		AUTOMOBILE_TYPE * pAutomobile = (AUTOMOBILE_TYPE *)GetEntity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetEntity@CEntity@@QAEPAU_ENTITY_TYPE@@XZ ; CEntity::GetEntity
	mov	DWORD PTR _pAutomobile$209442[ebp], eax

; 443  : 
; 444  : 		if(pAutomobile)

	cmp	DWORD PTR _pAutomobile$209442[ebp], 0
	je	SHORT $LN5@ToggleRhin

; 445  : 		{
; 446  : 			if(iToggle)

	cmp	DWORD PTR _iToggle$[ebp], 0
	je	SHORT $LN2@ToggleRhin

; 447  : 			{
; 448  : 				pAutomobile->byteUnknownFlags = (pAutomobile->byteUnknownFlags & 0xBF | 0x40);

	mov	eax, DWORD PTR _pAutomobile$209442[ebp]
	movzx	ecx, BYTE PTR [eax+1285]
	and	ecx, 191				; 000000bfH
	or	ecx, 64					; 00000040H
	mov	edx, DWORD PTR _pAutomobile$209442[ebp]
	mov	BYTE PTR [edx+1285], cl

; 449  : 			}
; 450  : 			else

	jmp	SHORT $LN5@ToggleRhin
$LN2@ToggleRhin:

; 451  : 			{
; 452  : 				pAutomobile->byteUnknownFlags &= 0xBF;

	mov	eax, DWORD PTR _pAutomobile$209442[ebp]
	movzx	ecx, BYTE PTR [eax+1285]
	and	ecx, 191				; 000000bfH
	mov	edx, DWORD PTR _pAutomobile$209442[ebp]
	mov	BYTE PTR [edx+1285], cl
$LN5@ToggleRhin:

; 453  : 			}
; 454  : 		}
; 455  : 	}
; 456  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?ToggleRhinoInstantExplosionUponContact@CVehicle@@QAEXH@Z ENDP ; CVehicle::ToggleRhinoInstantExplosionUponContact
_TEXT	ENDS
PUBLIC	_sqrtf
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\math.h
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?sqrt@@YAMM@Z PROC					; sqrt, COMDAT

; 534  :         {return (sqrtf(_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	ecx
	fld	DWORD PTR __X$[ebp]
	fstp	DWORD PTR [esp]
	call	_sqrtf
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?sqrt@@YAMM@Z ENDP					; sqrt
_TEXT	ENDS
EXTRN	_sqrt:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv73 = -196						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC						; COMDAT

; 423  :         {return ((float)sqrt((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	fld	DWORD PTR __X$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR tv73[ebp]
	fld	DWORD PTR tv73[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_sqrtf	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\vice-players-master\client\game\common.h
_TEXT	ENDS
;	COMDAT ??0Vector3@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0Vector3@@QAE@XZ PROC					; Vector3::Vector3, COMDAT
; _this$ = ecx

; 34   : 	Vector3()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 	{
; 36   : 		X = Y = Z = 0;

	mov	eax, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [edx]

; 37   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector3@@QAE@XZ ENDP					; Vector3::Vector3
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??0CPlayerPed@@QAE@XZ:PROC			; CPlayerPed::CPlayerPed
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT xdata$x
; File d:\vice-players-master\client\game\cgame.h
xdata$x	SEGMENT
__unwindtable$?FindPlayerPed@CGame@@QAEPAVCPlayerPed@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FindPlayerPed@CGame@@QAEPAVCPlayerPed@@XZ$0
__ehfuncinfo$?FindPlayerPed@CGame@@QAEPAVCPlayerPed@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?FindPlayerPed@CGame@@QAEPAVCPlayerPed@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCsu /ZI
xdata$x	ENDS
;	COMDAT ?FindPlayerPed@CGame@@QAEPAVCPlayerPed@@XZ
_TEXT	SEGMENT
tv74 = -244						; size = 4
$T209566 = -236						; size = 4
$T209567 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?FindPlayerPed@CGame@@QAEPAVCPlayerPed@@XZ PROC		; CGame::FindPlayerPed, COMDAT
; _this$ = ecx

; 101  : 	CPlayerPed  *FindPlayerPed() {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?FindPlayerPed@CGame@@QAEPAVCPlayerPed@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 102  : 		if(m_pInternalPlayer==NULL)	m_pInternalPlayer = new CPlayerPed();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN1@FindPlayer
	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T209567[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T209567[ebp], 0
	je	SHORT $LN4@FindPlayer
	mov	ecx, DWORD PTR $T209567[ebp]
	call	??0CPlayerPed@@QAE@XZ			; CPlayerPed::CPlayerPed
	mov	DWORD PTR tv74[ebp], eax
	jmp	SHORT $LN5@FindPlayer
$LN4@FindPlayer:
	mov	DWORD PTR tv74[ebp], 0
$LN5@FindPlayer:
	mov	eax, DWORD PTR tv74[ebp]
	mov	DWORD PTR $T209566[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T209566[ebp]
	mov	DWORD PTR [ecx+4], edx
$LN1@FindPlayer:

; 103  : 		return m_pInternalPlayer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 104  : 	};

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FindPlayerPed@CGame@@QAEPAVCPlayerPed@@XZ$0:
	mov	eax, DWORD PTR $T209567[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?FindPlayerPed@CGame@@QAEPAVCPlayerPed@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-248]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?FindPlayerPed@CGame@@QAEPAVCPlayerPed@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?FindPlayerPed@CGame@@QAEPAVCPlayerPed@@XZ ENDP		; CGame::FindPlayerPed
END
