; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\vice-players-master\Client\net\CVehicleManager.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??0_VEHICLE_SPAWN_INFO@@QAE@XZ			; _VEHICLE_SPAWN_INFO::_VEHICLE_SPAWN_INFO
PUBLIC	??0CVehicleManager@@QAE@XZ			; CVehicleManager::CVehicleManager
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT rtc$TMZ
; File d:\vice-players-master\client\net\cvehiclemanager.cpp
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu /ZI
rtc$IMZ	ENDS
;	COMDAT ??0CVehicleManager@@QAE@XZ
_TEXT	SEGMENT
_i$209252 = -17						; size = 1
_this$ = -8						; size = 4
??0CVehicleManager@@QAE@XZ PROC				; CVehicleManager::CVehicleManager, COMDAT
; _this$ = ecx

; 20   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET ??0_VEHICLE_SPAWN_INFO@@QAE@XZ
	push	200					; 000000c8H
	push	28					; 0000001cH
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1600				; 00000640H
	push	eax
	call	??_H@YGXPAXIHP6EPAX0@Z@Z

; 21   : 	for(EntityId i = 0; i < MAX_VEHICLES; i++)

	mov	BYTE PTR _i$209252[ebp], 0
	jmp	SHORT $LN3@CVehicleMa
$LN2@CVehicleMa:
	mov	al, BYTE PTR _i$209252[ebp]
	add	al, 1
	mov	BYTE PTR _i$209252[ebp], al
$LN3@CVehicleMa:
	movzx	eax, BYTE PTR _i$209252[ebp]
	cmp	eax, 200				; 000000c8H
	jge	SHORT $LN4@CVehicleMa

; 22   : 	{
; 23   : 		m_bVehicleSlotState[i] = FALSE;

	movzx	eax, BYTE PTR _i$209252[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4], 0

; 24   : 		m_pVehicles[i] = NULL;

	movzx	eax, BYTE PTR _i$209252[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+800], 0
	jmp	SHORT $LN2@CVehicleMa
$LN4@CVehicleMa:

; 25   : 	}
; 26   : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0CVehicleManager@@QAE@XZ ENDP				; CVehicleManager::CVehicleManager
_TEXT	ENDS
PUBLIC	??0Vector3@@QAE@XZ				; Vector3::Vector3
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0_VEHICLE_SPAWN_INFO@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_VEHICLE_SPAWN_INFO@@QAE@XZ PROC			; _VEHICLE_SPAWN_INFO::_VEHICLE_SPAWN_INFO, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0Vector3@@QAE@XZ			; Vector3::Vector3
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0_VEHICLE_SPAWN_INFO@@QAE@XZ ENDP			; _VEHICLE_SPAWN_INFO::_VEHICLE_SPAWN_INFO
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
$LN2@vector:
	mov	eax, DWORD PTR ___n$[ebp]
	sub	eax, 1
	mov	DWORD PTR ___n$[ebp], eax
	js	SHORT $LN3@vector
	mov	esi, esp
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR ___t$[ebp]
	add	eax, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], eax
	jmp	SHORT $LN2@vector
$LN3@vector:
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	?Delete@CVehicleManager@@QAEHE@Z		; CVehicleManager::Delete
PUBLIC	??1CVehicleManager@@QAE@XZ			; CVehicleManager::~CVehicleManager
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1CVehicleManager@@QAE@XZ
_TEXT	SEGMENT
_i$209272 = -17						; size = 1
_this$ = -8						; size = 4
??1CVehicleManager@@QAE@XZ PROC				; CVehicleManager::~CVehicleManager, COMDAT
; _this$ = ecx

; 31   : {	

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 32   : 	for(EntityId i = 0; i < MAX_VEHICLES; i++)

	mov	BYTE PTR _i$209272[ebp], 0
	jmp	SHORT $LN4@CVehicleMa@2
$LN3@CVehicleMa@2:
	mov	al, BYTE PTR _i$209272[ebp]
	add	al, 1
	mov	BYTE PTR _i$209272[ebp], al
$LN4@CVehicleMa@2:
	movzx	eax, BYTE PTR _i$209272[ebp]
	cmp	eax, 200				; 000000c8H
	jge	SHORT $LN5@CVehicleMa@2

; 33   : 	{
; 34   : 		if(m_bVehicleSlotState[i])

	movzx	eax, BYTE PTR _i$209272[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	je	SHORT $LN1@CVehicleMa@2

; 35   : 		{
; 36   : 			Delete(i);

	movzx	eax, BYTE PTR _i$209272[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Delete@CVehicleManager@@QAEHE@Z	; CVehicleManager::Delete
$LN1@CVehicleMa@2:

; 37   : 		}

	jmp	SHORT $LN3@CVehicleMa@2
$LN5@CVehicleMa@2:

; 38   : 	}
; 39   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1CVehicleManager@@QAE@XZ ENDP				; CVehicleManager::~CVehicleManager
_TEXT	ENDS
PUBLIC	?Spawn@CVehicleManager@@QAEHEEPAUVector3@@MHH@Z	; CVehicleManager::Spawn
PUBLIC	?New@CVehicleManager@@QAEHEEPAUVector3@@MHH0M@Z	; CVehicleManager::New
EXTRN	__fltused:DWORD
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?New@CVehicleManager@@QAEHEEPAUVector3@@MHH0M@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_vehicleID$ = 8						; size = 1
_byteVehicleType$ = 12					; size = 1
_vecPos$ = 16						; size = 4
_fRotation$ = 20					; size = 4
_iColor1$ = 24						; size = 4
_iColor2$ = 28						; size = 4
_vecSpawnPos$ = 32					; size = 4
_fSpawnRotation$ = 36					; size = 4
?New@CVehicleManager@@QAEHEEPAUVector3@@MHH0M@Z PROC	; CVehicleManager::New, COMDAT
; _this$ = ecx

; 47   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 48   : 
; 49   : 	// Setup the spawninfo for the next respawn.
; 50   : 	m_SpawnInfo[vehicleID].byteVehicleType = byteVehicleType;

	movzx	eax, BYTE PTR _vehicleID$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR _byteVehicleType$[ebp]
	mov	BYTE PTR [ecx+eax+1600], dl

; 51   : 	m_SpawnInfo[vehicleID].vecPos.X = vecSpawnPos->X;

	movzx	eax, BYTE PTR _vehicleID$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _vecSpawnPos$[ebp]
	fld	DWORD PTR [edx]
	fstp	DWORD PTR [ecx+eax+1604]

; 52   : 	m_SpawnInfo[vehicleID].vecPos.Y = vecSpawnPos->Y;

	movzx	eax, BYTE PTR _vehicleID$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _vecSpawnPos$[ebp]
	fld	DWORD PTR [edx+4]
	fstp	DWORD PTR [ecx+eax+1608]

; 53   : 	m_SpawnInfo[vehicleID].vecPos.Z = vecSpawnPos->Z;

	movzx	eax, BYTE PTR _vehicleID$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _vecSpawnPos$[ebp]
	fld	DWORD PTR [edx+8]
	fstp	DWORD PTR [ecx+eax+1612]

; 54   : 	m_SpawnInfo[vehicleID].fRotation = fSpawnRotation;

	movzx	eax, BYTE PTR _vehicleID$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fSpawnRotation$[ebp]
	fstp	DWORD PTR [ecx+eax+1616]

; 55   : 	m_SpawnInfo[vehicleID].iColor1 = iColor1;

	movzx	eax, BYTE PTR _vehicleID$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _iColor1$[ebp]
	mov	DWORD PTR [ecx+eax+1620], edx

; 56   : 	m_SpawnInfo[vehicleID].iColor2 = iColor2;

	movzx	eax, BYTE PTR _vehicleID$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _iColor2$[ebp]
	mov	DWORD PTR [ecx+eax+1624], edx

; 57   : 
; 58   : 	// Now go ahead and spawn it at the location we got passed.
; 59   : 	return Spawn(vehicleID,byteVehicleType,vecPos,fRotation,iColor1,iColor2);

	mov	eax, DWORD PTR _iColor2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iColor1$[ebp]
	push	ecx
	push	ecx
	fld	DWORD PTR _fRotation$[ebp]
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _vecPos$[ebp]
	push	edx
	movzx	eax, BYTE PTR _byteVehicleType$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _vehicleID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Spawn@CVehicleManager@@QAEHEEPAUVector3@@MHH@Z ; CVehicleManager::Spawn

; 60   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?New@CVehicleManager@@QAEHEEPAUVector3@@MHH0M@Z ENDP	; CVehicleManager::New
_TEXT	ENDS
PUBLIC	??_GCVehicle@@QAEPAXI@Z				; CVehicle::`scalar deleting destructor'
PUBLIC	?GetSlotState@CVehicleManager@@QAEHE@Z		; CVehicleManager::GetSlotState
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?Delete@CVehicleManager@@QAEHE@Z
_TEXT	SEGMENT
tv84 = -232						; size = 4
$T209433 = -224						; size = 4
$T209434 = -212						; size = 4
_this$ = -8						; size = 4
_vehicleID$ = 8						; size = 1
?Delete@CVehicleManager@@QAEHE@Z PROC			; CVehicleManager::Delete, COMDAT
; _this$ = ecx

; 65   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 66   : 	if(!GetSlotState(vehicleID) || !m_pVehicles[vehicleID]) {

	movzx	eax, BYTE PTR _vehicleID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSlotState@CVehicleManager@@QAEHE@Z	; CVehicleManager::GetSlotState
	test	eax, eax
	je	SHORT $LN1@Delete
	movzx	eax, BYTE PTR _vehicleID$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*4+800], 0
	jne	SHORT $LN2@Delete
$LN1@Delete:

; 67   : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $LN3@Delete
$LN2@Delete:

; 68   : 	}
; 69   : 
; 70   : 	m_bVehicleSlotState[vehicleID] = FALSE;

	movzx	eax, BYTE PTR _vehicleID$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4], 0

; 71   : 	delete m_pVehicles[vehicleID];

	movzx	eax, BYTE PTR _vehicleID$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+800]
	mov	DWORD PTR $T209434[ebp], edx
	mov	eax, DWORD PTR $T209434[ebp]
	mov	DWORD PTR $T209433[ebp], eax
	cmp	DWORD PTR $T209433[ebp], 0
	je	SHORT $LN5@Delete
	push	1
	mov	ecx, DWORD PTR $T209433[ebp]
	call	??_GCVehicle@@QAEPAXI@Z
	mov	DWORD PTR tv84[ebp], eax
	jmp	SHORT $LN6@Delete
$LN5@Delete:
	mov	DWORD PTR tv84[ebp], 0
$LN6@Delete:

; 72   : 	m_pVehicles[vehicleID] = NULL;

	movzx	eax, BYTE PTR _vehicleID$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+800], 0

; 73   : 
; 74   : 	return TRUE;

	mov	eax, 1
$LN3@Delete:

; 75   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Delete@CVehicleManager@@QAEHE@Z ENDP			; CVehicleManager::Delete
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??1CVehicle@@QAE@XZ:PROC			; CVehicle::~CVehicle
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_GCVehicle@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_GCVehicle@@QAEPAXI@Z PROC				; CVehicle::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CVehicle@@QAE@XZ			; CVehicle::~CVehicle
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCVehicle@@QAEPAXI@Z ENDP				; CVehicle::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	?SetColor@CVehicle@@QAEXHH@Z:PROC		; CVehicle::SetColor
EXTRN	??0CVehicle@@QAE@HMMMM@Z:PROC			; CVehicle::CVehicle
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Spawn@CVehicleManager@@QAEHEEPAUVector3@@MHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Spawn@CVehicleManager@@QAEHEEPAUVector3@@MHH@Z$0
__ehfuncinfo$?Spawn@CVehicleManager@@QAEHEEPAUVector3@@MHH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Spawn@CVehicleManager@@QAEHEEPAUVector3@@MHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCsu /ZI
xdata$x	ENDS
;	COMDAT ?Spawn@CVehicleManager@@QAEHEEPAUVector3@@MHH@Z
_TEXT	SEGMENT
tv90 = -244						; size = 4
$T209441 = -236						; size = 4
$T209442 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
_vehicleID$ = 8						; size = 1
_byteVehicleType$ = 12					; size = 1
_vecPos$ = 16						; size = 4
_fRotation$ = 20					; size = 4
_iColor1$ = 24						; size = 4
_iColor2$ = 28						; size = 4
?Spawn@CVehicleManager@@QAEHEEPAUVector3@@MHH@Z PROC	; CVehicleManager::Spawn, COMDAT
; _this$ = ecx

; 82   : {	

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Spawn@CVehicleManager@@QAEHEEPAUVector3@@MHH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 83   : 	if(m_pVehicles[vehicleID] != NULL) {

	movzx	eax, BYTE PTR _vehicleID$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*4+800], 0
	je	SHORT $LN4@Spawn

; 84   : 		Delete(vehicleID);

	movzx	eax, BYTE PTR _vehicleID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Delete@CVehicleManager@@QAEHE@Z	; CVehicleManager::Delete
$LN4@Spawn:

; 85   : 	}
; 86   : 
; 87   : 	m_pVehicles[vehicleID] =  new CVehicle(byteVehicleType,
; 88   : 		vecPos->X,vecPos->Y,vecPos->Z,fRotation);

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T209442[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T209442[ebp], 0
	je	SHORT $LN7@Spawn
	push	ecx
	fld	DWORD PTR _fRotation$[ebp]
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _vecPos$[ebp]
	push	ecx
	fld	DWORD PTR [eax+8]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _vecPos$[ebp]
	push	ecx
	fld	DWORD PTR [ecx+4]
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _vecPos$[ebp]
	push	ecx
	fld	DWORD PTR [edx]
	fstp	DWORD PTR [esp]
	movzx	eax, BYTE PTR _byteVehicleType$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T209442[ebp]
	call	??0CVehicle@@QAE@HMMMM@Z		; CVehicle::CVehicle
	mov	DWORD PTR tv90[ebp], eax
	jmp	SHORT $LN8@Spawn
$LN7@Spawn:
	mov	DWORD PTR tv90[ebp], 0
$LN8@Spawn:
	mov	ecx, DWORD PTR tv90[ebp]
	mov	DWORD PTR $T209441[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	movzx	edx, BYTE PTR _vehicleID$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T209441[ebp]
	mov	DWORD PTR [eax+edx*4+800], ecx

; 89   : 
; 90   : 	if(m_pVehicles[vehicleID])

	movzx	eax, BYTE PTR _vehicleID$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*4+800], 0
	je	SHORT $LN3@Spawn

; 91   : 	{	
; 92   : 		if(iColor1 != (-1)) {

	cmp	DWORD PTR _iColor1$[ebp], -1
	je	SHORT $LN2@Spawn

; 93   : 			m_pVehicles[vehicleID]->SetColor(iColor1,iColor2);

	mov	eax, DWORD PTR _iColor2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iColor1$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _vehicleID$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+800]
	call	?SetColor@CVehicle@@QAEXHH@Z		; CVehicle::SetColor
$LN2@Spawn:

; 94   : 		}
; 95   : 
; 96   : 		m_bVehicleSlotState[vehicleID] = TRUE;

	movzx	eax, BYTE PTR _vehicleID$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4], 1

; 97   : 
; 98   : 		m_bIsActive[vehicleID] = TRUE;

	movzx	eax, BYTE PTR _vehicleID$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+7200], 1

; 99   : 		m_bIsWasted[vehicleID] = FALSE;

	movzx	eax, BYTE PTR _vehicleID$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+8000], 0

; 100  : 
; 101  : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $LN1@Spawn

; 102  : 	}
; 103  : 	else

	jmp	SHORT $LN1@Spawn
$LN3@Spawn:

; 104  : 	{
; 105  : 		return FALSE;

	xor	eax, eax
$LN1@Spawn:

; 106  : 	}
; 107  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Spawn@CVehicleManager@@QAEHEEPAUVector3@@MHH@Z$0:
	mov	eax, DWORD PTR $T209442[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?Spawn@CVehicleManager@@QAEHEEPAUVector3@@MHH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-248]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Spawn@CVehicleManager@@QAEHEEPAUVector3@@MHH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Spawn@CVehicleManager@@QAEHEEPAUVector3@@MHH@Z ENDP	; CVehicleManager::Spawn
PUBLIC	?FindIDFromGtaPtr@CVehicleManager@@QAEEPAU_VEHICLE_TYPE@@@Z ; CVehicleManager::FindIDFromGtaPtr
EXTRN	?GetVehicle@CVehicle@@QAEPAU_VEHICLE_TYPE@@XZ:PROC ; CVehicle::GetVehicle
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?FindIDFromGtaPtr@CVehicleManager@@QAEEPAU_VEHICLE_TYPE@@@Z
_TEXT	SEGMENT
_i$209321 = -17						; size = 1
_this$ = -8						; size = 4
_pGtaVehicle$ = 8					; size = 4
?FindIDFromGtaPtr@CVehicleManager@@QAEEPAU_VEHICLE_TYPE@@@Z PROC ; CVehicleManager::FindIDFromGtaPtr, COMDAT
; _this$ = ecx

; 112  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 113  : 	for(EntityId i = 1; i < MAX_VEHICLES; i++)

	mov	BYTE PTR _i$209321[ebp], 1
	jmp	SHORT $LN5@FindIDFrom
$LN4@FindIDFrom:
	mov	al, BYTE PTR _i$209321[ebp]
	add	al, 1
	mov	BYTE PTR _i$209321[ebp], al
$LN5@FindIDFrom:
	movzx	eax, BYTE PTR _i$209321[ebp]
	cmp	eax, 200				; 000000c8H
	jge	SHORT $LN3@FindIDFrom

; 114  : 	{
; 115  : 		if(m_bVehicleSlotState[i])

	movzx	eax, BYTE PTR _i$209321[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	je	SHORT $LN2@FindIDFrom

; 116  : 		{
; 117  : 			if(pGtaVehicle == m_pVehicles[i]->GetVehicle())

	movzx	eax, BYTE PTR _i$209321[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4+800]
	call	?GetVehicle@CVehicle@@QAEPAU_VEHICLE_TYPE@@XZ ; CVehicle::GetVehicle
	cmp	DWORD PTR _pGtaVehicle$[ebp], eax
	jne	SHORT $LN2@FindIDFrom

; 118  : 			{
; 119  : 				return i;

	mov	al, BYTE PTR _i$209321[ebp]
	jmp	SHORT $LN6@FindIDFrom
$LN2@FindIDFrom:

; 120  : 			}
; 121  : 		}
; 122  : 	}

	jmp	SHORT $LN4@FindIDFrom
$LN3@FindIDFrom:

; 123  : 
; 124  : 	return INVALID_ENTITY_ID;

	or	al, 255					; 000000ffH
$LN6@FindIDFrom:

; 125  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?FindIDFromGtaPtr@CVehicleManager@@QAEEPAU_VEHICLE_TYPE@@@Z ENDP ; CVehicleManager::FindIDFromGtaPtr
_TEXT	ENDS
PUBLIC	?FindGtaIDFromID@CVehicleManager@@QAEHE@Z	; CVehicleManager::FindGtaIDFromID
EXTRN	?GetIndexFromVehicle@CPools@@SGHPAU_VEHICLE_TYPE@@@Z:PROC ; CPools::GetIndexFromVehicle
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?FindGtaIDFromID@CVehicleManager@@QAEHE@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_vehicleID$ = 8						; size = 1
?FindGtaIDFromID@CVehicleManager@@QAEHE@Z PROC		; CVehicleManager::FindGtaIDFromID, COMDAT
; _this$ = ecx

; 130  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 131  : 	if(m_pVehicles[vehicleID]) {

	movzx	eax, BYTE PTR _vehicleID$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*4+800], 0
	je	SHORT $LN1@FindGtaIDF

; 132  : 		return CPools::GetIndexFromVehicle(m_pVehicles[vehicleID]->GetVehicle());

	movzx	eax, BYTE PTR _vehicleID$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4+800]
	call	?GetVehicle@CVehicle@@QAEPAU_VEHICLE_TYPE@@XZ ; CVehicle::GetVehicle
	push	eax
	call	?GetIndexFromVehicle@CPools@@SGHPAU_VEHICLE_TYPE@@@Z ; CPools::GetIndexFromVehicle
	jmp	SHORT $LN2@FindGtaIDF
$LN1@FindGtaIDF:

; 133  : 	}
; 134  : 
; 135  : 	// not too sure about this
; 136  : 	return 0;

	xor	eax, eax
$LN2@FindGtaIDF:

; 137  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?FindGtaIDFromID@CVehicleManager@@QAEHE@Z ENDP		; CVehicleManager::FindGtaIDFromID
_TEXT	ENDS
PUBLIC	?GetRPC4@CNetworkManager@@QAEPAVRPC4@RakNet@@XZ	; CNetworkManager::GetRPC4
PUBLIC	??_C@_0N@KNIJHINL@VehicleDeath?$AA@		; `string'
PUBLIC	??0AddressOrGUID@RakNet@@QAE@ABUSystemAddress@1@@Z ; RakNet::AddressOrGUID::AddressOrGUID
PUBLIC	??$Write@E@BitStream@RakNet@@QAEXABE@Z		; RakNet::BitStream::Write<unsigned char>
PUBLIC	__$ArrayPad$
PUBLIC	?SendVehicleDeath@CVehicleManager@@QAEXE@Z	; CVehicleManager::SendVehicleDeath
EXTRN	??1BitStream@RakNet@@QAE@XZ:PROC		; RakNet::BitStream::~BitStream
EXTRN	?Call@RPC4@RakNet@@QAEXPBDPAVBitStream@2@W4PacketPriority@@W4PacketReliability@@DUAddressOrGUID@2@_N@Z:PROC ; RakNet::RPC4::Call
EXTRN	?pNetowkManager@@3PAVCNetworkManager@@A:DWORD	; pNetowkManager
EXTRN	??0BitStream@RakNet@@QAE@XZ:PROC		; RakNet::BitStream::BitStream
EXTRN	@_RTC_CheckStackVars@8:PROC
;	COMDAT ??_C@_0N@KNIJHINL@VehicleDeath?$AA@
CONST	SEGMENT
??_C@_0N@KNIJHINL@VehicleDeath?$AA@ DB 'VehicleDeath', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SendVehicleDeath@CVehicleManager@@QAEXE@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SendVehicleDeath@CVehicleManager@@QAEXE@Z$0
__ehfuncinfo$?SendVehicleDeath@CVehicleManager@@QAEXE@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SendVehicleDeath@CVehicleManager@@QAEXE@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCsu /ZI
xdata$x	ENDS
;	COMDAT ?SendVehicleDeath@CVehicleManager@@QAEXE@Z
_TEXT	SEGMENT
$T209464 = -512						; size = 4
_bsVehicleDeath$ = -308					; size = 276
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_vehicleID$ = 8						; size = 1
?SendVehicleDeath@CVehicleManager@@QAEXE@Z PROC		; CVehicleManager::SendVehicleDeath, COMDAT
; _this$ = ecx

; 142  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SendVehicleDeath@CVehicleManager@@QAEXE@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 504				; 000001f8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-516]
	mov	ecx, 126				; 0000007eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 143  : 	BitStream bsVehicleDeath;

	lea	ecx, DWORD PTR _bsVehicleDeath$[ebp]
	call	??0BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::BitStream
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 144  : 	bsVehicleDeath.Write(vehicleID);

	lea	eax, DWORD PTR _vehicleID$[ebp]
	push	eax
	lea	ecx, DWORD PTR _bsVehicleDeath$[ebp]
	call	??$Write@E@BitStream@RakNet@@QAEXABE@Z	; RakNet::BitStream::Write<unsigned char>

; 145  : 	pNetowkManager->GetRPC4()->Call("VehicleDeath", &bsVehicleDeath, HIGH_PRIORITY, RELIABLE_ORDERED, 0, 
; 146  : 		UNASSIGNED_SYSTEM_ADDRESS, true);

	push	1
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	mov	DWORD PTR $T209464[ebp], esp
	push	OFFSET _UNASSIGNED_SYSTEM_ADDRESS
	call	??0AddressOrGUID@RakNet@@QAE@ABUSystemAddress@1@@Z ; RakNet::AddressOrGUID::AddressOrGUID
	push	0
	push	3
	push	1
	lea	eax, DWORD PTR _bsVehicleDeath$[ebp]
	push	eax
	push	OFFSET ??_C@_0N@KNIJHINL@VehicleDeath?$AA@
	mov	ecx, DWORD PTR ?pNetowkManager@@3PAVCNetworkManager@@A ; pNetowkManager
	call	?GetRPC4@CNetworkManager@@QAEPAVRPC4@RakNet@@XZ ; CNetworkManager::GetRPC4
	mov	ecx, eax
	call	?Call@RPC4@RakNet@@QAEXPBDPAVBitStream@2@W4PacketPriority@@W4PacketReliability@@DUAddressOrGUID@2@_N@Z ; RakNet::RPC4::Call

; 147  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _bsVehicleDeath$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@SendVehicl
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 516				; 00000204H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	1
$LN7@SendVehicl:
	DD	1
	DD	$LN6@SendVehicl
$LN6@SendVehicl:
	DD	-308					; fffffeccH
	DD	276					; 00000114H
	DD	$LN4@SendVehicl
$LN4@SendVehicl:
	DB	98					; 00000062H
	DB	115					; 00000073H
	DB	86					; 00000056H
	DB	101					; 00000065H
	DB	104					; 00000068H
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	68					; 00000044H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SendVehicleDeath@CVehicleManager@@QAEXE@Z$0:
	lea	ecx, DWORD PTR _bsVehicleDeath$[ebp]
	jmp	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
__ehhandler$?SendVehicleDeath@CVehicleManager@@QAEXE@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-520]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SendVehicleDeath@CVehicleManager@@QAEXE@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SendVehicleDeath@CVehicleManager@@QAEXE@Z ENDP		; CVehicleManager::SendVehicleDeath
PUBLIC	__real@4072c00000000000
PUBLIC	__real@0000000000000000
PUBLIC	?Process@CVehicleManager@@QAEXXZ		; CVehicleManager::Process
EXTRN	?VerifyControlState@CVehicle@@QAEXXZ:PROC	; CVehicle::VerifyControlState
EXTRN	?SetLockedState@CVehicle@@QAEXH@Z:PROC		; CVehicle::SetLockedState
EXTRN	?GetDistanceFromLocalPlayerPed@CVehicle@@QAEMXZ:PROC ; CVehicle::GetDistanceFromLocalPlayerPed
EXTRN	?SetInvulnerable@CVehicle@@QAEXH@Z:PROC		; CVehicle::SetInvulnerable
EXTRN	?IsDriverLocalPlayer@CVehicle@@QAEHXZ:PROC	; CVehicle::IsDriverLocalPlayer
EXTRN	?SetDead@CVehicle@@QAEXH@Z:PROC			; CVehicle::SetDead
EXTRN	?IsDead@CVehicle@@QAEHXZ:PROC			; CVehicle::IsDead
EXTRN	?HasSunk@CVehicle@@QAEHXZ:PROC			; CVehicle::HasSunk
EXTRN	?GetSubtype@CVehicle@@QAEEXZ:PROC		; CVehicle::GetSubtype
EXTRN	?GetHealth@CVehicle@@QAEMXZ:PROC		; CVehicle::GetHealth
EXTRN	__imp__GetTickCount@0:PROC
;	COMDAT __real@4072c00000000000
CONST	SEGMENT
__real@4072c00000000000 DQ 04072c00000000000r	; 300
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?Process@CVehicleManager@@QAEXXZ
_TEXT	SEGMENT
_x$209347 = -41						; size = 1
_dwThisTime$ = -32					; size = 4
_pVehicle$ = -20					; size = 4
_this$ = -8						; size = 4
?Process@CVehicleManager@@QAEXXZ PROC			; CVehicleManager::Process, COMDAT
; _this$ = ecx

; 152  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 153  : 	CVehicle *pVehicle;
; 154  : 	DWORD dwThisTime = GetTickCount();

	mov	esi, esp
	call	DWORD PTR __imp__GetTickCount@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _dwThisTime$[ebp], eax

; 155  : 
; 156  : 	for(BYTE x = 0; x < MAX_VEHICLES; x++)

	mov	BYTE PTR _x$209347[ebp], 0
	jmp	SHORT $LN14@Process
$LN13@Process:
	mov	al, BYTE PTR _x$209347[ebp]
	add	al, 1
	mov	BYTE PTR _x$209347[ebp], al
$LN14@Process:
	movzx	eax, BYTE PTR _x$209347[ebp]
	cmp	eax, 200				; 000000c8H
	jge	$LN12@Process

; 157  : 	{
; 158  : 		if(GetSlotState(x)) { // It's inuse.

	movzx	eax, BYTE PTR _x$209347[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSlotState@CVehicleManager@@QAEHE@Z	; CVehicleManager::GetSlotState
	test	eax, eax
	je	$LN1@Process

; 159  : 			pVehicle = m_pVehicles[x];

	movzx	eax, BYTE PTR _x$209347[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+800]
	mov	DWORD PTR _pVehicle$[ebp], edx

; 160  : 
; 161  : 			if(m_bIsActive[x]) {

	movzx	eax, BYTE PTR _x$209347[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*4+7200], 0
	je	$LN1@Process

; 162  : 				if((pVehicle->GetHealth() == 0.0f) || 
; 163  : 					(pVehicle->GetSubtype() != VEHICLE_SUBTYPE_BOAT &&
; 164  : 					pVehicle->GetSubtype() != VEHICLE_SUBTYPE_PLANE &&
; 165  : 					pVehicle->HasSunk())) { // It's dead or its not a boat and it has sunk

	mov	ecx, DWORD PTR _pVehicle$[ebp]
	call	?GetHealth@CVehicle@@QAEMXZ		; CVehicle::GetHealth
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN8@Process
	mov	ecx, DWORD PTR _pVehicle$[ebp]
	call	?GetSubtype@CVehicle@@QAEEXZ		; CVehicle::GetSubtype
	movzx	eax, al
	cmp	eax, 4
	je	SHORT $LN9@Process
	mov	ecx, DWORD PTR _pVehicle$[ebp]
	call	?GetSubtype@CVehicle@@QAEEXZ		; CVehicle::GetSubtype
	movzx	eax, al
	cmp	eax, 5
	je	SHORT $LN9@Process
	mov	ecx, DWORD PTR _pVehicle$[ebp]
	call	?HasSunk@CVehicle@@QAEHXZ		; CVehicle::HasSunk
	test	eax, eax
	je	SHORT $LN9@Process
$LN8@Process:

; 166  : 					if(!pVehicle->IsDead()) {

	mov	ecx, DWORD PTR _pVehicle$[ebp]
	call	?IsDead@CVehicle@@QAEHXZ		; CVehicle::IsDead
	test	eax, eax
	jne	SHORT $LN7@Process

; 167  : 						SendVehicleDeath(x);

	movzx	eax, BYTE PTR _x$209347[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendVehicleDeath@CVehicleManager@@QAEXE@Z ; CVehicleManager::SendVehicleDeath

; 168  : 						pVehicle->SetDead(TRUE);

	push	1
	mov	ecx, DWORD PTR _pVehicle$[ebp]
	call	?SetDead@CVehicle@@QAEXH@Z		; CVehicle::SetDead
$LN7@Process:

; 169  : 					}
; 170  : 				}
; 171  : 				else 

	jmp	SHORT $LN1@Process
$LN9@Process:

; 172  : 				{
; 173  : 					if(pVehicle->IsDriverLocalPlayer()) {

	mov	ecx, DWORD PTR _pVehicle$[ebp]
	call	?IsDriverLocalPlayer@CVehicle@@QAEHXZ	; CVehicle::IsDriverLocalPlayer
	test	eax, eax
	je	SHORT $LN5@Process

; 174  : 						pVehicle->SetInvulnerable(FALSE);

	push	0
	mov	ecx, DWORD PTR _pVehicle$[ebp]
	call	?SetInvulnerable@CVehicle@@QAEXH@Z	; CVehicle::SetInvulnerable

; 175  : 					} else {

	jmp	SHORT $LN4@Process
$LN5@Process:

; 176  : 						pVehicle->SetInvulnerable(TRUE);

	push	1
	mov	ecx, DWORD PTR _pVehicle$[ebp]
	call	?SetInvulnerable@CVehicle@@QAEXH@Z	; CVehicle::SetInvulnerable
$LN4@Process:

; 177  : 					}
; 178  : 
; 179  : 					// Lock vehicles beyond given radius.
; 180  : 					// whats the point in this?
; 181  : 					if(pVehicle->GetDistanceFromLocalPlayerPed() > 300.0f) {

	mov	ecx, DWORD PTR _pVehicle$[ebp]
	call	?GetDistanceFromLocalPlayerPed@CVehicle@@QAEMXZ ; CVehicle::GetDistanceFromLocalPlayerPed
	fcomp	QWORD PTR __real@4072c00000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN3@Process

; 182  : 						pVehicle->SetLockedState(1);

	push	1
	mov	ecx, DWORD PTR _pVehicle$[ebp]
	call	?SetLockedState@CVehicle@@QAEXH@Z	; CVehicle::SetLockedState

; 183  : 					} else {

	jmp	SHORT $LN2@Process
$LN3@Process:

; 184  : 						pVehicle->SetLockedState(0);

	push	0
	mov	ecx, DWORD PTR _pVehicle$[ebp]
	call	?SetLockedState@CVehicle@@QAEXH@Z	; CVehicle::SetLockedState
$LN2@Process:

; 185  : 					}
; 186  : 
; 187  : 					if(pVehicle->GetSubtype() == VEHICLE_SUBTYPE_BIKE) {

	mov	ecx, DWORD PTR _pVehicle$[ebp]
	call	?GetSubtype@CVehicle@@QAEEXZ		; CVehicle::GetSubtype
	movzx	eax, al
	cmp	eax, 2
	jne	SHORT $LN1@Process

; 188  : 						pVehicle->VerifyControlState();

	mov	ecx, DWORD PTR _pVehicle$[ebp]
	call	?VerifyControlState@CVehicle@@QAEXXZ	; CVehicle::VerifyControlState
$LN1@Process:

; 189  : 					}		
; 190  : 				}
; 191  : 			}
; 192  : 		}

	jmp	$LN13@Process
$LN12@Process:

; 193  : 	}
; 194  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Process@CVehicleManager@@QAEXXZ ENDP			; CVehicleManager::Process
_TEXT	ENDS
PUBLIC	?DoEndianSwap@BitStream@RakNet@@SA_NXZ		; RakNet::BitStream::DoEndianSwap
EXTRN	?ReverseBytes@BitStream@RakNet@@SAXPAE0I@Z:PROC	; RakNet::BitStream::ReverseBytes
EXTRN	?WriteBits@BitStream@RakNet@@QAEXPBEI_N@Z:PROC	; RakNet::BitStream::WriteBits
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\vice-players-master\raknet\bitstream.h
;	COMDAT ??$Write@E@BitStream@RakNet@@QAEXABE@Z
_TEXT	SEGMENT
_output$209370 = -17					; size = 1
_this$ = -8						; size = 4
_inTemplateVar$ = 8					; size = 4
??$Write@E@BitStream@RakNet@@QAEXABE@Z PROC		; RakNet::BitStream::Write<unsigned char>, COMDAT
; _this$ = ecx

; 1055 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1056 : #ifdef _MSC_VER
; 1057 : #pragma warning(disable:4127)   // conditional expression is constant
; 1058 : #endif
; 1059 : 		if (sizeof(inTemplateVar)==1)

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN4@Write

; 1060 : 			WriteBits( ( unsigned char* ) & inTemplateVar, sizeof( templateType ) * 8, true );

	push	1
	push	8
	mov	eax, DWORD PTR _inTemplateVar$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteBits@BitStream@RakNet@@QAEXPBEI_N@Z ; RakNet::BitStream::WriteBits

; 1061 : 		else

	jmp	SHORT $LN5@Write
$LN4@Write:

; 1062 : 		{
; 1063 : #ifndef __BITSTREAM_NATIVE_END
; 1064 : 			if (DoEndianSwap())

	call	?DoEndianSwap@BitStream@RakNet@@SA_NXZ	; RakNet::BitStream::DoEndianSwap
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Write

; 1065 : 			{
; 1066 : 				unsigned char output[sizeof(templateType)];
; 1067 : 				ReverseBytes((unsigned char*)&inTemplateVar, output, sizeof(templateType));

	push	1
	lea	eax, DWORD PTR _output$209370[ebp]
	push	eax
	mov	ecx, DWORD PTR _inTemplateVar$[ebp]
	push	ecx
	call	?ReverseBytes@BitStream@RakNet@@SAXPAE0I@Z ; RakNet::BitStream::ReverseBytes
	add	esp, 12					; 0000000cH

; 1068 : 				WriteBits( ( unsigned char* ) output, sizeof(templateType) * 8, true );

	push	1
	push	8
	lea	eax, DWORD PTR _output$209370[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteBits@BitStream@RakNet@@QAEXPBEI_N@Z ; RakNet::BitStream::WriteBits

; 1069 : 			}
; 1070 : 			else

	jmp	SHORT $LN5@Write
$LN2@Write:

; 1071 : #endif
; 1072 : 				WriteBits( ( unsigned char* ) & inTemplateVar, sizeof(templateType) * 8, true );

	push	1
	push	8
	mov	eax, DWORD PTR _inTemplateVar$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteBits@BitStream@RakNet@@QAEXPBEI_N@Z ; RakNet::BitStream::WriteBits
$LN5@Write:

; 1073 : 		}
; 1074 : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@Write
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN9@Write:
	DD	1
	DD	$LN8@Write
$LN8@Write:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN7@Write
$LN7@Write:
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	112					; 00000070H
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	0
??$Write@E@BitStream@RakNet@@QAEXABE@Z ENDP		; RakNet::BitStream::Write<unsigned char>
_TEXT	ENDS
PUBLIC	__real@00000000
;	COMDAT __real@00000000
; File d:\vice-players-master\client\game\common.h
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ??0Vector3@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0Vector3@@QAE@XZ PROC					; Vector3::Vector3, COMDAT
; _this$ = ecx

; 34   : 	Vector3()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 	{
; 36   : 		X = Y = Z = 0;

	mov	eax, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [edx]

; 37   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector3@@QAE@XZ ENDP					; Vector3::Vector3
_TEXT	ENDS
PUBLIC	??4SystemAddress@RakNet@@QAEAAU01@ABU01@@Z	; RakNet::SystemAddress::operator=
PUBLIC	??4RakNetGUID@RakNet@@QAEAAU01@ABU01@@Z		; RakNet::RakNetGUID::operator=
PUBLIC	??0RakNetGUID@RakNet@@QAE@XZ			; RakNet::RakNetGUID::RakNetGUID
EXTRN	??0SystemAddress@RakNet@@QAE@XZ:PROC		; RakNet::SystemAddress::SystemAddress
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\vice-players-master\raknet\raknettypes.h
;	COMDAT ??0AddressOrGUID@RakNet@@QAE@ABUSystemAddress@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_input$ = 8						; size = 4
??0AddressOrGUID@RakNet@@QAE@ABUSystemAddress@1@@Z PROC	; RakNet::AddressOrGUID::AddressOrGUID, COMDAT
; _this$ = ecx

; 220  : 	AddressOrGUID( const SystemAddress& input )

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0RakNetGUID@RakNet@@QAE@XZ		; RakNet::RakNetGUID::RakNetGUID
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??0SystemAddress@RakNet@@QAE@XZ		; RakNet::SystemAddress::SystemAddress

; 221  : 	{
; 222  : 		rakNetGuid=UNASSIGNED_RAKNET_GUID;

	push	OFFSET _UNASSIGNED_RAKNET_GUID
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4RakNetGUID@RakNet@@QAEAAU01@ABU01@@Z	; RakNet::RakNetGUID::operator=

; 223  : 		systemAddress=input;

	mov	eax, DWORD PTR _input$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??4SystemAddress@RakNet@@QAEAAU01@ABU01@@Z ; RakNet::SystemAddress::operator=

; 224  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0AddressOrGUID@RakNet@@QAE@ABUSystemAddress@1@@Z ENDP	; RakNet::AddressOrGUID::AddressOrGUID
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ??4SystemAddress@RakNet@@QAEAAU01@ABU01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_input$ = 8						; size = 4
??4SystemAddress@RakNet@@QAEAAU01@ABU01@@Z PROC		; RakNet::SystemAddress::operator=, COMDAT
; _this$ = ecx

; 139  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		binaryAddress = input.binaryAddress;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _input$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 141  : 		port = input.port;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _input$[ebp]
	mov	dx, WORD PTR [ecx+4]
	mov	WORD PTR [eax+4], dx

; 142  : 		systemIndex = input.systemIndex;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _input$[ebp]
	mov	dx, WORD PTR [ecx+6]
	mov	WORD PTR [eax+6], dx

; 143  : 		return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 144  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4SystemAddress@RakNet@@QAEAAU01@ABU01@@Z ENDP		; RakNet::SystemAddress::operator=
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ??0RakNetGUID@RakNet@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0RakNetGUID@RakNet@@QAE@XZ PROC			; RakNet::RakNetGUID::RakNetGUID, COMDAT
; _this$ = ecx

; 156  : 	RakNetGUID() {systemIndex=(SystemIndex)-1;}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+8], ax
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0RakNetGUID@RakNet@@QAE@XZ ENDP			; RakNet::RakNetGUID::RakNetGUID
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ??4RakNetGUID@RakNet@@QAEAAU01@ABU01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_input$ = 8						; size = 4
??4RakNetGUID@RakNet@@QAEAAU01@ABU01@@Z PROC		; RakNet::RakNetGUID::operator=, COMDAT
; _this$ = ecx

; 174  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 175  : 		g=input.g;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _input$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx

; 176  : 		systemIndex=input.systemIndex;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _input$[ebp]
	mov	dx, WORD PTR [ecx+8]
	mov	WORD PTR [eax+8], dx

; 177  : 		return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 178  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4RakNetGUID@RakNet@@QAEAAU01@ABU01@@Z ENDP		; RakNet::RakNetGUID::operator=
_TEXT	ENDS
PUBLIC	?IsNetworkOrder@BitStream@RakNet@@SA_NXZ	; RakNet::BitStream::IsNetworkOrder
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\vice-players-master\raknet\bitstream.h
;	COMDAT ?DoEndianSwap@BitStream@RakNet@@SA_NXZ
_TEXT	SEGMENT
?DoEndianSwap@BitStream@RakNet@@SA_NXZ PROC		; RakNet::BitStream::DoEndianSwap, COMDAT

; 863  : 		inline static bool DoEndianSwap(void) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 864  : #ifndef __BITSTREAM_NATIVE_END
; 865  : 			return IsNetworkOrder()==false;

	call	?IsNetworkOrder@BitStream@RakNet@@SA_NXZ ; RakNet::BitStream::IsNetworkOrder
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 866  : #else
; 867  : 			return false;
; 868  : #endif
; 869  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DoEndianSwap@BitStream@RakNet@@SA_NXZ ENDP		; RakNet::BitStream::DoEndianSwap
_TEXT	ENDS
PUBLIC	?r@?1??IsNetworkOrder@BitStream@RakNet@@SA_NXZ@4_NB ; `RakNet::BitStream::IsNetworkOrder'::`2'::r
PUBLIC	??_B?1??IsNetworkOrder@BitStream@RakNet@@SA_NXZ@51 ; `RakNet::BitStream::IsNetworkOrder'::`2'::`local static guard'
EXTRN	?IsNetworkOrderInternal@BitStream@RakNet@@SA_NXZ:PROC ; RakNet::BitStream::IsNetworkOrderInternal
;	COMDAT ?r@?1??IsNetworkOrder@BitStream@RakNet@@SA_NXZ@4_NB
_BSS	SEGMENT
?r@?1??IsNetworkOrder@BitStream@RakNet@@SA_NXZ@4_NB DB 01H DUP (?) ; `RakNet::BitStream::IsNetworkOrder'::`2'::r
_BSS	ENDS
;	COMDAT ??_B?1??IsNetworkOrder@BitStream@RakNet@@SA_NXZ@51
_BSS	SEGMENT
??_B?1??IsNetworkOrder@BitStream@RakNet@@SA_NXZ@51 DD 01H DUP (?) ; `RakNet::BitStream::IsNetworkOrder'::`2'::`local static guard'
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?IsNetworkOrder@BitStream@RakNet@@SA_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?IsNetworkOrder@BitStream@RakNet@@SA_NXZ$0
__ehfuncinfo$?IsNetworkOrder@BitStream@RakNet@@SA_NXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?IsNetworkOrder@BitStream@RakNet@@SA_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCsu /ZI
xdata$x	ENDS
;	COMDAT ?IsNetworkOrder@BitStream@RakNet@@SA_NXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
?IsNetworkOrder@BitStream@RakNet@@SA_NXZ PROC		; RakNet::BitStream::IsNetworkOrder, COMDAT

; 874  : 		inline static bool IsNetworkOrder(void) {static const bool r = IsNetworkOrderInternal(); return r;}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?IsNetworkOrder@BitStream@RakNet@@SA_NXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR ??_B?1??IsNetworkOrder@BitStream@RakNet@@SA_NXZ@51
	and	eax, 1
	jne	SHORT $LN1@IsNetworkO
	mov	eax, DWORD PTR ??_B?1??IsNetworkOrder@BitStream@RakNet@@SA_NXZ@51
	or	eax, 1
	mov	DWORD PTR ??_B?1??IsNetworkOrder@BitStream@RakNet@@SA_NXZ@51, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	?IsNetworkOrderInternal@BitStream@RakNet@@SA_NXZ ; RakNet::BitStream::IsNetworkOrderInternal
	mov	BYTE PTR ?r@?1??IsNetworkOrder@BitStream@RakNet@@SA_NXZ@4_NB, al ; `RakNet::BitStream::IsNetworkOrder'::`2'::r
	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN1@IsNetworkO:
	mov	al, BYTE PTR ?r@?1??IsNetworkOrder@BitStream@RakNet@@SA_NXZ@4_NB ; `RakNet::BitStream::IsNetworkOrder'::`2'::r
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?IsNetworkOrder@BitStream@RakNet@@SA_NXZ$0:
	mov	eax, DWORD PTR ??_B?1??IsNetworkOrder@BitStream@RakNet@@SA_NXZ@51
	and	eax, -2					; fffffffeH
	mov	DWORD PTR ??_B?1??IsNetworkOrder@BitStream@RakNet@@SA_NXZ@51, eax
	ret	0
__ehhandler$?IsNetworkOrder@BitStream@RakNet@@SA_NXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?IsNetworkOrder@BitStream@RakNet@@SA_NXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?IsNetworkOrder@BitStream@RakNet@@SA_NXZ ENDP		; RakNet::BitStream::IsNetworkOrder
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\vice-players-master\client\net\cvehiclemanager.h
;	COMDAT ?GetSlotState@CVehicleManager@@QAEHE@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_vehicleID$ = 8						; size = 1
?GetSlotState@CVehicleManager@@QAEHE@Z PROC		; CVehicleManager::GetSlotState, COMDAT
; _this$ = ecx

; 50   : 	BOOL GetSlotState(EntityId vehicleID) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 51   : 		if(vehicleID > MAX_VEHICLES) { return FALSE; }

	movzx	eax, BYTE PTR _vehicleID$[ebp]
	cmp	eax, 200				; 000000c8H
	jle	SHORT $LN1@GetSlotSta
	xor	eax, eax
	jmp	SHORT $LN2@GetSlotSta
$LN1@GetSlotSta:

; 52   : 		return m_bVehicleSlotState[vehicleID];

	movzx	eax, BYTE PTR _vehicleID$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]
$LN2@GetSlotSta:

; 53   : 	};

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetSlotState@CVehicleManager@@QAEHE@Z ENDP		; CVehicleManager::GetSlotState
_TEXT	ENDS
EXTRN	?m_pRPC4@CNetworkManager@@0PAVRPC4@RakNet@@A:DWORD ; CNetworkManager::m_pRPC4
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\vice-players-master\client\net\cnetworkmanager.h
;	COMDAT ?GetRPC4@CNetworkManager@@QAEPAVRPC4@RakNet@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetRPC4@CNetworkManager@@QAEPAVRPC4@RakNet@@XZ PROC	; CNetworkManager::GetRPC4, COMDAT
; _this$ = ecx

; 86   : 	RPC4 * GetRPC4() { return m_pRPC4; };

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ?m_pRPC4@CNetworkManager@@0PAVRPC4@RakNet@@A ; CNetworkManager::m_pRPC4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetRPC4@CNetworkManager@@QAEPAVRPC4@RakNet@@XZ ENDP	; CNetworkManager::GetRPC4
_TEXT	ENDS
EXTRN	??0SystemAddress@RakNet@@QAE@IG@Z:PROC		; RakNet::SystemAddress::SystemAddress
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\vice-players-master\raknet\raknettypes.h
;	COMDAT ??__EUNASSIGNED_SYSTEM_ADDRESS@RakNet@@YAXXZ
text$yc	SEGMENT
??__EUNASSIGNED_SYSTEM_ADDRESS@RakNet@@YAXXZ PROC	; RakNet::`dynamic initializer for 'UNASSIGNED_SYSTEM_ADDRESS'', COMDAT

; 196  : const SystemAddress UNASSIGNED_SYSTEM_ADDRESS(0xFFFFFFFF, 0xFFFF);

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	65535					; 0000ffffH
	push	-1
	mov	ecx, OFFSET _UNASSIGNED_SYSTEM_ADDRESS
	call	??0SystemAddress@RakNet@@QAE@IG@Z	; RakNet::SystemAddress::SystemAddress
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__EUNASSIGNED_SYSTEM_ADDRESS@RakNet@@YAXXZ ENDP	; RakNet::`dynamic initializer for 'UNASSIGNED_SYSTEM_ADDRESS''
text$yc	ENDS
PUBLIC	??0RakNetGUID@RakNet@@QAE@_K@Z			; RakNet::RakNetGUID::RakNetGUID
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??__EUNASSIGNED_RAKNET_GUID@RakNet@@YAXXZ
text$yc	SEGMENT
??__EUNASSIGNED_RAKNET_GUID@RakNet@@YAXXZ PROC		; RakNet::`dynamic initializer for 'UNASSIGNED_RAKNET_GUID'', COMDAT

; 197  : const RakNetGUID UNASSIGNED_RAKNET_GUID((uint64_t)-1);

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	-1
	push	-1
	mov	ecx, OFFSET _UNASSIGNED_RAKNET_GUID
	call	??0RakNetGUID@RakNet@@QAE@_K@Z		; RakNet::RakNetGUID::RakNetGUID
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__EUNASSIGNED_RAKNET_GUID@RakNet@@YAXXZ ENDP		; RakNet::`dynamic initializer for 'UNASSIGNED_RAKNET_GUID''
; Function compile flags: /Odtp /RTCsu /ZI
text$yc	ENDS
;	COMDAT ??0RakNetGUID@RakNet@@QAE@_K@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__g$ = 8						; size = 8
??0RakNetGUID@RakNet@@QAE@_K@Z PROC			; RakNet::RakNetGUID::RakNetGUID, COMDAT
; _this$ = ecx

; 157  : 	explicit RakNetGUID(uint64_t _g) {g=_g; systemIndex=(SystemIndex)-1;}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __g$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __g$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+8], ax
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0RakNetGUID@RakNet@@QAE@_K@Z ENDP			; RakNet::RakNetGUID::RakNetGUID
_TEXT	ENDS
_BSS	SEGMENT
_UNASSIGNED_SYSTEM_ADDRESS DQ 01H DUP (?)
_UNASSIGNED_RAKNET_GUID DB 010H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_UNASSIGNED_SYSTEM_ADDRESS$initializer$ DD FLAT:??__EUNASSIGNED_SYSTEM_ADDRESS@RakNet@@YAXXZ
_UNASSIGNED_RAKNET_GUID$initializer$ DD FLAT:??__EUNASSIGNED_RAKNET_GUID@RakNet@@YAXXZ
CRT$XCU	ENDS
END
