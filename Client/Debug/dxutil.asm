; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\vice-players-master\Client\d3d8\dxutil.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

_BSS	SEGMENT
?strNull@?1??DXUtil_GetDXSDKMediaPath@@YAPBDXZ@4PADA DB 02H DUP (?) ; `DXUtil_GetDXSDKMediaPath'::`2'::strNull
	ALIGN	4

?m_bTimerInitialized@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4HA DD 01H DUP (?) ; `DXUtil_Timer'::`2'::m_bTimerInitialized
?m_bUsingQPF@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4HA DD 01H DUP (?) ; `DXUtil_Timer'::`2'::m_bUsingQPF
	ALIGN	8

?m_llQPFTicksPerSec@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA DQ 01H DUP (?) ; `DXUtil_Timer'::`2'::m_llQPFTicksPerSec
?m_llStopTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA DQ 01H DUP (?) ; `DXUtil_Timer'::`10'::m_llStopTime
?m_llLastElapsedTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA DQ 01H DUP (?) ; `DXUtil_Timer'::`10'::m_llLastElapsedTime
?m_llBaseTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA DQ 01H DUP (?) ; `DXUtil_Timer'::`10'::m_llBaseTime
?m_fLastElapsedTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA DQ 01H DUP (?) ; `DXUtil_Timer'::`38'::m_fLastElapsedTime
?m_fBaseTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA DQ 01H DUP (?) ; `DXUtil_Timer'::`38'::m_fBaseTime
?m_fStopTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA DQ 01H DUP (?) ; `DXUtil_Timer'::`38'::m_fStopTime
_BSS	ENDS
_DATA	SEGMENT
?m_bTimerStopped@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4HA DD 01H ; `DXUtil_Timer'::`2'::m_bTimerStopped
_DATA	ENDS
PUBLIC	??_C@_07JADGJGAE@?2Media?2?$AA@			; `string'
PUBLIC	??_C@_0BF@FNOEFMNI@DX81SDK?5Samples?5Path?$AA@	; `string'
PUBLIC	??_C@_0BP@HEGLIIKH@Software?2Microsoft?2DirectX?5SDK?$AA@ ; `string'
PUBLIC	?DXUtil_GetDXSDKMediaPath@@YAPBDXZ		; DXUtil_GetDXSDKMediaPath
EXTRN	_strcat:PROC
EXTRN	__imp__RegCloseKey@4:PROC
EXTRN	__imp__RegQueryValueExA@24:PROC
EXTRN	__imp__RegOpenKeyExA@20:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
_BSS	SEGMENT
?strPath@?1??DXUtil_GetDXSDKMediaPath@@YAPBDXZ@4PADA DB 0104H DUP (?) ; `DXUtil_GetDXSDKMediaPath'::`2'::strPath
_BSS	ENDS
;	COMDAT ??_C@_07JADGJGAE@?2Media?2?$AA@
; File d:\vice-players-master\client\d3d8\dxutil.cpp
CONST	SEGMENT
??_C@_07JADGJGAE@?2Media?2?$AA@ DB '\Media\', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FNOEFMNI@DX81SDK?5Samples?5Path?$AA@
CONST	SEGMENT
??_C@_0BF@FNOEFMNI@DX81SDK?5Samples?5Path?$AA@ DB 'DX81SDK Samples Path', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@HEGLIIKH@Software?2Microsoft?2DirectX?5SDK?$AA@
CONST	SEGMENT
??_C@_0BP@HEGLIIKH@Software?2Microsoft?2DirectX?5SDK?$AA@ DB 'Software\Mi'
	DB	'crosoft\DirectX SDK', 00H			; `string'
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu /ZI
rtc$IMZ	ENDS
;	COMDAT ?DXUtil_GetDXSDKMediaPath@@YAPBDXZ
_TEXT	SEGMENT
_lResult$ = -44						; size = 4
_hKey$ = -32						; size = 4
_dwSize$ = -20						; size = 4
_dwType$ = -8						; size = 4
?DXUtil_GetDXSDKMediaPath@@YAPBDXZ PROC			; DXUtil_GetDXSDKMediaPath, COMDAT

; 25   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 26   :     static TCHAR strNull[2] = _T("");
; 27   :     static TCHAR strPath[MAX_PATH];
; 28   :     DWORD dwType;
; 29   :     DWORD dwSize = MAX_PATH;

	mov	DWORD PTR _dwSize$[ebp], 260		; 00000104H

; 30   :     HKEY  hKey;
; 31   : 
; 32   :     // Open the appropriate registry key
; 33   :     LONG lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
; 34   :                                 _T("Software\\Microsoft\\DirectX SDK"),
; 35   :                                 0, KEY_READ, &hKey );

	mov	esi, esp
	lea	eax, DWORD PTR _hKey$[ebp]
	push	eax
	push	131097					; 00020019H
	push	0
	push	OFFSET ??_C@_0BP@HEGLIIKH@Software?2Microsoft?2DirectX?5SDK?$AA@
	push	-2147483646				; 80000002H
	call	DWORD PTR __imp__RegOpenKeyExA@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _lResult$[ebp], eax

; 36   :     if( ERROR_SUCCESS != lResult )

	cmp	DWORD PTR _lResult$[ebp], 0
	je	SHORT $LN2@DXUtil_Get

; 37   :         return strNull;

	mov	eax, OFFSET ?strNull@?1??DXUtil_GetDXSDKMediaPath@@YAPBDXZ@4PADA
	jmp	SHORT $LN3@DXUtil_Get
$LN2@DXUtil_Get:

; 38   : 
; 39   :     lResult = RegQueryValueEx( hKey, _T("DX81SDK Samples Path"), NULL,
; 40   :                               &dwType, (BYTE*)strPath, &dwSize );

	mov	esi, esp
	lea	eax, DWORD PTR _dwSize$[ebp]
	push	eax
	push	OFFSET ?strPath@?1??DXUtil_GetDXSDKMediaPath@@YAPBDXZ@4PADA
	lea	ecx, DWORD PTR _dwType$[ebp]
	push	ecx
	push	0
	push	OFFSET ??_C@_0BF@FNOEFMNI@DX81SDK?5Samples?5Path?$AA@
	mov	edx, DWORD PTR _hKey$[ebp]
	push	edx
	call	DWORD PTR __imp__RegQueryValueExA@24
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _lResult$[ebp], eax

; 41   :     RegCloseKey( hKey );

	mov	esi, esp
	mov	eax, DWORD PTR _hKey$[ebp]
	push	eax
	call	DWORD PTR __imp__RegCloseKey@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 42   : 
; 43   :     if( ERROR_SUCCESS != lResult )

	cmp	DWORD PTR _lResult$[ebp], 0
	je	SHORT $LN1@DXUtil_Get

; 44   :         return strNull;

	mov	eax, OFFSET ?strNull@?1??DXUtil_GetDXSDKMediaPath@@YAPBDXZ@4PADA
	jmp	SHORT $LN3@DXUtil_Get
$LN1@DXUtil_Get:

; 45   : 
; 46   :     _tcscat( strPath, _T("\\Media\\") );

	push	OFFSET ??_C@_07JADGJGAE@?2Media?2?$AA@
	push	OFFSET ?strPath@?1??DXUtil_GetDXSDKMediaPath@@YAPBDXZ@4PADA
	call	_strcat
	add	esp, 8

; 47   : 
; 48   :     return strPath;

	mov	eax, OFFSET ?strPath@?1??DXUtil_GetDXSDKMediaPath@@YAPBDXZ@4PADA
$LN3@DXUtil_Get:

; 49   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@DXUtil_Get
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN9@DXUtil_Get:
	DD	3
	DD	$LN8@DXUtil_Get
$LN8@DXUtil_Get:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN5@DXUtil_Get
	DD	-20					; ffffffecH
	DD	4
	DD	$LN6@DXUtil_Get
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN7@DXUtil_Get
$LN7@DXUtil_Get:
	DB	104					; 00000068H
	DB	75					; 0000004bH
	DB	101					; 00000065H
	DB	121					; 00000079H
	DB	0
$LN6@DXUtil_Get:
	DB	100					; 00000064H
	DB	119					; 00000077H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	0
$LN5@DXUtil_Get:
	DB	100					; 00000064H
	DB	119					; 00000077H
	DB	84					; 00000054H
	DB	121					; 00000079H
	DB	112					; 00000070H
	DB	101					; 00000065H
	DB	0
?DXUtil_GetDXSDKMediaPath@@YAPBDXZ ENDP			; DXUtil_GetDXSDKMediaPath
_TEXT	ENDS
PUBLIC	??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@		; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?DXUtil_FindMediaFile@@YAJPAD0@Z		; DXUtil_FindMediaFile
EXTRN	_sprintf:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	_strcpy:PROC
EXTRN	__imp__CreateFileA@28:PROC
EXTRN	__imp__GetFullPathNameA@16:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
CONST	SEGMENT
??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@ DB '%s%s', 00H		; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?DXUtil_FindMediaFile@@YAJPAD0@Z
_TEXT	SEGMENT
_cchPath$ = -1068					; size = 4
_strShortName$ = -1056					; size = 4
_strFullPath$ = -1044					; size = 1024
_file$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_strPath$ = 8						; size = 4
_strFilename$ = 12					; size = 4
?DXUtil_FindMediaFile@@YAJPAD0@Z PROC			; DXUtil_FindMediaFile, COMDAT

; 59   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1264				; 000004f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-1264]
	mov	ecx, 316				; 0000013cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 60   :     HANDLE file;
; 61   :     TCHAR strFullPath[1024];
; 62   :     TCHAR *strShortName;
; 63   :     DWORD cchPath;
; 64   : 
; 65   :     if( NULL==strFilename || NULL==strPath )

	cmp	DWORD PTR _strFilename$[ebp], 0
	je	SHORT $LN6@DXUtil_Fin
	cmp	DWORD PTR _strPath$[ebp], 0
	jne	SHORT $LN7@DXUtil_Fin
$LN6@DXUtil_Fin:

; 66   :         return E_INVALIDARG;

	mov	eax, -2147024809			; 80070057H
	jmp	$LN8@DXUtil_Fin
$LN7@DXUtil_Fin:

; 67   : 
; 68   :     // Build full path name from strFileName (strShortName will be just the leaf filename)
; 69   :     cchPath = GetFullPathName(strFilename, sizeof(strFullPath)/sizeof(TCHAR), strFullPath, &strShortName);

	mov	esi, esp
	lea	eax, DWORD PTR _strShortName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strFullPath$[ebp]
	push	ecx
	push	1024					; 00000400H
	mov	edx, DWORD PTR _strFilename$[ebp]
	push	edx
	call	DWORD PTR __imp__GetFullPathNameA@16
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _cchPath$[ebp], eax

; 70   :     if ((cchPath == 0) || (sizeof(strFullPath)/sizeof(TCHAR) <= cchPath))

	cmp	DWORD PTR _cchPath$[ebp], 0
	je	SHORT $LN4@DXUtil_Fin
	cmp	DWORD PTR _cchPath$[ebp], 1024		; 00000400H
	jb	SHORT $LN5@DXUtil_Fin
$LN4@DXUtil_Fin:

; 71   :         return E_FAIL;

	mov	eax, -2147467259			; 80004005H
	jmp	$LN8@DXUtil_Fin
$LN5@DXUtil_Fin:

; 72   : 
; 73   :     // first try to find the filename given a full path
; 74   :     file = CreateFile( strFullPath, GENERIC_READ, FILE_SHARE_READ, NULL, 
; 75   :                        OPEN_EXISTING, 0, NULL );

	mov	esi, esp
	push	0
	push	0
	push	3
	push	0
	push	1
	push	-2147483648				; 80000000H
	lea	eax, DWORD PTR _strFullPath$[ebp]
	push	eax
	call	DWORD PTR __imp__CreateFileA@28
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _file$[ebp], eax

; 76   :     if( INVALID_HANDLE_VALUE != file )

	cmp	DWORD PTR _file$[ebp], -1
	je	SHORT $LN3@DXUtil_Fin

; 77   :     {
; 78   :         _tcscpy( strPath, strFullPath );

	lea	eax, DWORD PTR _strFullPath$[ebp]
	push	eax
	mov	ecx, DWORD PTR _strPath$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 79   :         CloseHandle( file );

	mov	esi, esp
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	DWORD PTR __imp__CloseHandle@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 80   :         return S_OK;

	xor	eax, eax
	jmp	$LN8@DXUtil_Fin
$LN3@DXUtil_Fin:

; 81   :     }
; 82   :     
; 83   :     // next try to find the filename in the current working directory (path stripped)
; 84   :     file = CreateFile( strShortName, GENERIC_READ, FILE_SHARE_READ, NULL, 
; 85   :                        OPEN_EXISTING, 0, NULL );

	mov	esi, esp
	push	0
	push	0
	push	3
	push	0
	push	1
	push	-2147483648				; 80000000H
	mov	eax, DWORD PTR _strShortName$[ebp]
	push	eax
	call	DWORD PTR __imp__CreateFileA@28
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _file$[ebp], eax

; 86   :     if( INVALID_HANDLE_VALUE != file )

	cmp	DWORD PTR _file$[ebp], -1
	je	SHORT $LN2@DXUtil_Fin

; 87   :     {
; 88   :         _tcscpy( strPath, strShortName );

	mov	eax, DWORD PTR _strShortName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _strPath$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 89   :         CloseHandle( file );

	mov	esi, esp
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	DWORD PTR __imp__CloseHandle@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 90   :         return S_OK;

	xor	eax, eax
	jmp	SHORT $LN8@DXUtil_Fin
$LN2@DXUtil_Fin:

; 91   :     }
; 92   :     
; 93   :     // last, check if the file exists in the media directory
; 94   :     _stprintf( strPath, _T("%s%s"), DXUtil_GetDXSDKMediaPath(), strShortName );

	mov	eax, DWORD PTR _strShortName$[ebp]
	push	eax
	call	?DXUtil_GetDXSDKMediaPath@@YAPBDXZ	; DXUtil_GetDXSDKMediaPath
	push	eax
	push	OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
	mov	ecx, DWORD PTR _strPath$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 95   : 
; 96   :     file = CreateFile( strPath, GENERIC_READ, FILE_SHARE_READ, NULL, 
; 97   :                        OPEN_EXISTING, 0, NULL );

	mov	esi, esp
	push	0
	push	0
	push	3
	push	0
	push	1
	push	-2147483648				; 80000000H
	mov	eax, DWORD PTR _strPath$[ebp]
	push	eax
	call	DWORD PTR __imp__CreateFileA@28
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _file$[ebp], eax

; 98   :     if( INVALID_HANDLE_VALUE != file )

	cmp	DWORD PTR _file$[ebp], -1
	je	SHORT $LN1@DXUtil_Fin

; 99   :     {
; 100  :         CloseHandle( file );

	mov	esi, esp
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	DWORD PTR __imp__CloseHandle@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 101  :         return S_OK;

	xor	eax, eax
	jmp	SHORT $LN8@DXUtil_Fin
$LN1@DXUtil_Fin:

; 102  :     }
; 103  : 
; 104  :     // On failure, just return the file as the path
; 105  :     _tcscpy( strPath, strFilename );

	mov	eax, DWORD PTR _strFilename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _strPath$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 106  :     return E_FAIL;

	mov	eax, -2147467259			; 80004005H
$LN8@DXUtil_Fin:

; 107  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN13@DXUtil_Fin
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 1264				; 000004f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@DXUtil_Fin:
	DD	2
	DD	$LN12@DXUtil_Fin
$LN12@DXUtil_Fin:
	DD	-1044					; fffffbecH
	DD	1024					; 00000400H
	DD	$LN10@DXUtil_Fin
	DD	-1056					; fffffbe0H
	DD	4
	DD	$LN11@DXUtil_Fin
$LN11@DXUtil_Fin:
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	83					; 00000053H
	DB	104					; 00000068H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	78					; 0000004eH
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
$LN10@DXUtil_Fin:
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	70					; 00000046H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	108					; 0000006cH
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
?DXUtil_FindMediaFile@@YAJPAD0@Z ENDP			; DXUtil_FindMediaFile
_TEXT	ENDS
PUBLIC	?DXUtil_ReadStringRegKey@@YAJPAUHKEY__@@PAD1K1@Z ; DXUtil_ReadStringRegKey
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?DXUtil_ReadStringRegKey@@YAJPAUHKEY__@@PAD1K1@Z
_TEXT	SEGMENT
_dwType$ = -8						; size = 4
_hKey$ = 8						; size = 4
_strRegName$ = 12					; size = 4
_strValue$ = 16						; size = 4
_dwLength$ = 20						; size = 4
_strDefault$ = 24					; size = 4
?DXUtil_ReadStringRegKey@@YAJPAUHKEY__@@PAD1K1@Z PROC	; DXUtil_ReadStringRegKey, COMDAT

; 118  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 119  :     DWORD dwType;
; 120  : 
; 121  :     if( ERROR_SUCCESS != RegQueryValueEx( hKey, strRegName, 0, &dwType, 
; 122  :                                           (BYTE*)strValue, &dwLength ) )

	mov	esi, esp
	lea	eax, DWORD PTR _dwLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _strValue$[ebp]
	push	ecx
	lea	edx, DWORD PTR _dwType$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _strRegName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hKey$[ebp]
	push	ecx
	call	DWORD PTR __imp__RegQueryValueExA@24
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN1@DXUtil_Rea

; 123  :     {
; 124  :         _tcscpy( strValue, strDefault );

	mov	eax, DWORD PTR _strDefault$[ebp]
	push	eax
	mov	ecx, DWORD PTR _strValue$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8
$LN1@DXUtil_Rea:

; 125  :     }
; 126  : 
; 127  :     return S_OK;

	xor	eax, eax

; 128  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@DXUtil_Rea
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN6@DXUtil_Rea:
	DD	1
	DD	$LN5@DXUtil_Rea
$LN5@DXUtil_Rea:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN4@DXUtil_Rea
$LN4@DXUtil_Rea:
	DB	100					; 00000064H
	DB	119					; 00000077H
	DB	84					; 00000054H
	DB	121					; 00000079H
	DB	112					; 00000070H
	DB	101					; 00000065H
	DB	0
?DXUtil_ReadStringRegKey@@YAJPAUHKEY__@@PAD1K1@Z ENDP	; DXUtil_ReadStringRegKey
_TEXT	ENDS
PUBLIC	?DXUtil_WriteStringRegKey@@YAJPAUHKEY__@@PAD1@Z	; DXUtil_WriteStringRegKey
EXTRN	__imp__RegSetValueExA@24:PROC
EXTRN	_strlen:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?DXUtil_WriteStringRegKey@@YAJPAUHKEY__@@PAD1@Z
_TEXT	SEGMENT
_hKey$ = 8						; size = 4
_strRegName$ = 12					; size = 4
_strValue$ = 16						; size = 4
?DXUtil_WriteStringRegKey@@YAJPAUHKEY__@@PAD1@Z PROC	; DXUtil_WriteStringRegKey, COMDAT

; 139  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 140  :     if( ERROR_SUCCESS != RegSetValueEx( hKey, strRegName, 0, REG_SZ, 
; 141  :                                         (BYTE*)strValue, 
; 142  :                                         (_tcslen(strValue)+1)*sizeof(TCHAR) ) )

	mov	eax, DWORD PTR _strValue$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 1
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _strValue$[ebp]
	push	ecx
	push	1
	push	0
	mov	edx, DWORD PTR _strRegName$[ebp]
	push	edx
	mov	eax, DWORD PTR _hKey$[ebp]
	push	eax
	call	DWORD PTR __imp__RegSetValueExA@24
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN1@DXUtil_Wri

; 143  :         return E_FAIL;

	mov	eax, -2147467259			; 80004005H
	jmp	SHORT $LN2@DXUtil_Wri
$LN1@DXUtil_Wri:

; 144  : 
; 145  :     return S_OK;

	xor	eax, eax
$LN2@DXUtil_Wri:

; 146  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUtil_WriteStringRegKey@@YAJPAUHKEY__@@PAD1@Z ENDP	; DXUtil_WriteStringRegKey
_TEXT	ENDS
PUBLIC	?DXUtil_ReadIntRegKey@@YAJPAUHKEY__@@PADPAKK@Z	; DXUtil_ReadIntRegKey
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?DXUtil_ReadIntRegKey@@YAJPAUHKEY__@@PADPAKK@Z
_TEXT	SEGMENT
_dwLength$ = -20					; size = 4
_dwType$ = -8						; size = 4
_hKey$ = 8						; size = 4
_strRegName$ = 12					; size = 4
_pdwValue$ = 16						; size = 4
_dwDefault$ = 20					; size = 4
?DXUtil_ReadIntRegKey@@YAJPAUHKEY__@@PADPAKK@Z PROC	; DXUtil_ReadIntRegKey, COMDAT

; 157  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 158  :     DWORD dwType;
; 159  :     DWORD dwLength = sizeof(DWORD);

	mov	DWORD PTR _dwLength$[ebp], 4

; 160  : 
; 161  :     if( ERROR_SUCCESS != RegQueryValueEx( hKey, strRegName, 0, &dwType, 
; 162  :                                           (BYTE*)pdwValue, &dwLength ) )

	mov	esi, esp
	lea	eax, DWORD PTR _dwLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pdwValue$[ebp]
	push	ecx
	lea	edx, DWORD PTR _dwType$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _strRegName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hKey$[ebp]
	push	ecx
	call	DWORD PTR __imp__RegQueryValueExA@24
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN1@DXUtil_Rea@2

; 163  :     {
; 164  :         *pdwValue = dwDefault;

	mov	eax, DWORD PTR _pdwValue$[ebp]
	mov	ecx, DWORD PTR _dwDefault$[ebp]
	mov	DWORD PTR [eax], ecx
$LN1@DXUtil_Rea@2:

; 165  :     }
; 166  : 
; 167  :     return S_OK;

	xor	eax, eax

; 168  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@DXUtil_Rea@2
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN7@DXUtil_Rea@2:
	DD	2
	DD	$LN6@DXUtil_Rea@2
$LN6@DXUtil_Rea@2:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN4@DXUtil_Rea@2
	DD	-20					; ffffffecH
	DD	4
	DD	$LN5@DXUtil_Rea@2
$LN5@DXUtil_Rea@2:
	DB	100					; 00000064H
	DB	119					; 00000077H
	DB	76					; 0000004cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$LN4@DXUtil_Rea@2:
	DB	100					; 00000064H
	DB	119					; 00000077H
	DB	84					; 00000054H
	DB	121					; 00000079H
	DB	112					; 00000070H
	DB	101					; 00000065H
	DB	0
?DXUtil_ReadIntRegKey@@YAJPAUHKEY__@@PADPAKK@Z ENDP	; DXUtil_ReadIntRegKey
_TEXT	ENDS
PUBLIC	?DXUtil_WriteIntRegKey@@YAJPAUHKEY__@@PADK@Z	; DXUtil_WriteIntRegKey
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?DXUtil_WriteIntRegKey@@YAJPAUHKEY__@@PADK@Z
_TEXT	SEGMENT
_hKey$ = 8						; size = 4
_strRegName$ = 12					; size = 4
_dwValue$ = 16						; size = 4
?DXUtil_WriteIntRegKey@@YAJPAUHKEY__@@PADK@Z PROC	; DXUtil_WriteIntRegKey, COMDAT

; 178  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 179  :     if( ERROR_SUCCESS != RegSetValueEx( hKey, strRegName, 0, REG_DWORD, 
; 180  :                                         (BYTE*)&dwValue, sizeof(DWORD) ) )

	mov	esi, esp
	push	4
	lea	eax, DWORD PTR _dwValue$[ebp]
	push	eax
	push	4
	push	0
	mov	ecx, DWORD PTR _strRegName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hKey$[ebp]
	push	edx
	call	DWORD PTR __imp__RegSetValueExA@24
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN1@DXUtil_Wri@2

; 181  :         return E_FAIL;

	mov	eax, -2147467259			; 80004005H
	jmp	SHORT $LN2@DXUtil_Wri@2
$LN1@DXUtil_Wri@2:

; 182  : 
; 183  :     return S_OK;

	xor	eax, eax
$LN2@DXUtil_Wri@2:

; 184  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUtil_WriteIntRegKey@@YAJPAUHKEY__@@PADK@Z ENDP	; DXUtil_WriteIntRegKey
_TEXT	ENDS
PUBLIC	?DXUtil_ReadBoolRegKey@@YAJPAUHKEY__@@PADPAHH@Z	; DXUtil_ReadBoolRegKey
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?DXUtil_ReadBoolRegKey@@YAJPAUHKEY__@@PADPAHH@Z
_TEXT	SEGMENT
_dwLength$ = -20					; size = 4
_dwType$ = -8						; size = 4
_hKey$ = 8						; size = 4
_strRegName$ = 12					; size = 4
_pbValue$ = 16						; size = 4
_bDefault$ = 20						; size = 4
?DXUtil_ReadBoolRegKey@@YAJPAUHKEY__@@PADPAHH@Z PROC	; DXUtil_ReadBoolRegKey, COMDAT

; 195  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 196  :     DWORD dwType;
; 197  :     DWORD dwLength = sizeof(BOOL);

	mov	DWORD PTR _dwLength$[ebp], 4

; 198  : 
; 199  :     if( ERROR_SUCCESS != RegQueryValueEx( hKey, strRegName, 0, &dwType, 
; 200  :                                           (BYTE*)pbValue, &dwLength ) )

	mov	esi, esp
	lea	eax, DWORD PTR _dwLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pbValue$[ebp]
	push	ecx
	lea	edx, DWORD PTR _dwType$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _strRegName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hKey$[ebp]
	push	ecx
	call	DWORD PTR __imp__RegQueryValueExA@24
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN1@DXUtil_Rea@3

; 201  :     {
; 202  :         *pbValue = bDefault;

	mov	eax, DWORD PTR _pbValue$[ebp]
	mov	ecx, DWORD PTR _bDefault$[ebp]
	mov	DWORD PTR [eax], ecx
$LN1@DXUtil_Rea@3:

; 203  :     }
; 204  : 
; 205  :     return S_OK;

	xor	eax, eax

; 206  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@DXUtil_Rea@3
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN7@DXUtil_Rea@3:
	DD	2
	DD	$LN6@DXUtil_Rea@3
$LN6@DXUtil_Rea@3:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN4@DXUtil_Rea@3
	DD	-20					; ffffffecH
	DD	4
	DD	$LN5@DXUtil_Rea@3
$LN5@DXUtil_Rea@3:
	DB	100					; 00000064H
	DB	119					; 00000077H
	DB	76					; 0000004cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$LN4@DXUtil_Rea@3:
	DB	100					; 00000064H
	DB	119					; 00000077H
	DB	84					; 00000054H
	DB	121					; 00000079H
	DB	112					; 00000070H
	DB	101					; 00000065H
	DB	0
?DXUtil_ReadBoolRegKey@@YAJPAUHKEY__@@PADPAHH@Z ENDP	; DXUtil_ReadBoolRegKey
_TEXT	ENDS
PUBLIC	?DXUtil_WriteBoolRegKey@@YAJPAUHKEY__@@PADH@Z	; DXUtil_WriteBoolRegKey
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?DXUtil_WriteBoolRegKey@@YAJPAUHKEY__@@PADH@Z
_TEXT	SEGMENT
_hKey$ = 8						; size = 4
_strRegName$ = 12					; size = 4
_bValue$ = 16						; size = 4
?DXUtil_WriteBoolRegKey@@YAJPAUHKEY__@@PADH@Z PROC	; DXUtil_WriteBoolRegKey, COMDAT

; 216  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 217  :     if( ERROR_SUCCESS != RegSetValueEx( hKey, strRegName, 0, REG_DWORD, 
; 218  :                                         (BYTE*)&bValue, sizeof(BOOL) ) )

	mov	esi, esp
	push	4
	lea	eax, DWORD PTR _bValue$[ebp]
	push	eax
	push	4
	push	0
	mov	ecx, DWORD PTR _strRegName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hKey$[ebp]
	push	edx
	call	DWORD PTR __imp__RegSetValueExA@24
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN1@DXUtil_Wri@3

; 219  :         return E_FAIL;

	mov	eax, -2147467259			; 80004005H
	jmp	SHORT $LN2@DXUtil_Wri@3
$LN1@DXUtil_Wri@3:

; 220  : 
; 221  :     return S_OK;

	xor	eax, eax
$LN2@DXUtil_Wri@3:

; 222  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUtil_WriteBoolRegKey@@YAJPAUHKEY__@@PADH@Z ENDP	; DXUtil_WriteBoolRegKey
_TEXT	ENDS
PUBLIC	?DXUtil_ReadGuidRegKey@@YAJPAUHKEY__@@PADPAU_GUID@@AAU2@@Z ; DXUtil_ReadGuidRegKey
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?DXUtil_ReadGuidRegKey@@YAJPAUHKEY__@@PADPAU_GUID@@AAU2@@Z
_TEXT	SEGMENT
_dwLength$ = -20					; size = 4
_dwType$ = -8						; size = 4
_hKey$ = 8						; size = 4
_strRegName$ = 12					; size = 4
_pGuidValue$ = 16					; size = 4
_guidDefault$ = 20					; size = 4
?DXUtil_ReadGuidRegKey@@YAJPAUHKEY__@@PADPAU_GUID@@AAU2@@Z PROC ; DXUtil_ReadGuidRegKey, COMDAT

; 233  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 234  :     DWORD dwType;
; 235  :     DWORD dwLength = sizeof(GUID);

	mov	DWORD PTR _dwLength$[ebp], 16		; 00000010H

; 236  : 
; 237  :     if( ERROR_SUCCESS != RegQueryValueEx( hKey, strRegName, 0, &dwType, 
; 238  :                                           (LPBYTE) pGuidValue, &dwLength ) )

	mov	esi, esp
	lea	eax, DWORD PTR _dwLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pGuidValue$[ebp]
	push	ecx
	lea	edx, DWORD PTR _dwType$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _strRegName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hKey$[ebp]
	push	ecx
	call	DWORD PTR __imp__RegQueryValueExA@24
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN1@DXUtil_Rea@4

; 239  :     {
; 240  :         *pGuidValue = guidDefault;

	mov	eax, DWORD PTR _guidDefault$[ebp]
	mov	ecx, DWORD PTR _pGuidValue$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
$LN1@DXUtil_Rea@4:

; 241  :     }
; 242  : 
; 243  :     return S_OK;

	xor	eax, eax

; 244  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@DXUtil_Rea@4
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN7@DXUtil_Rea@4:
	DD	2
	DD	$LN6@DXUtil_Rea@4
$LN6@DXUtil_Rea@4:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN4@DXUtil_Rea@4
	DD	-20					; ffffffecH
	DD	4
	DD	$LN5@DXUtil_Rea@4
$LN5@DXUtil_Rea@4:
	DB	100					; 00000064H
	DB	119					; 00000077H
	DB	76					; 0000004cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$LN4@DXUtil_Rea@4:
	DB	100					; 00000064H
	DB	119					; 00000077H
	DB	84					; 00000054H
	DB	121					; 00000079H
	DB	112					; 00000070H
	DB	101					; 00000065H
	DB	0
?DXUtil_ReadGuidRegKey@@YAJPAUHKEY__@@PADPAU_GUID@@AAU2@@Z ENDP ; DXUtil_ReadGuidRegKey
_TEXT	ENDS
PUBLIC	?DXUtil_WriteGuidRegKey@@YAJPAUHKEY__@@PADU_GUID@@@Z ; DXUtil_WriteGuidRegKey
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?DXUtil_WriteGuidRegKey@@YAJPAUHKEY__@@PADU_GUID@@@Z
_TEXT	SEGMENT
_hKey$ = 8						; size = 4
_strRegName$ = 12					; size = 4
_guidValue$ = 16					; size = 16
?DXUtil_WriteGuidRegKey@@YAJPAUHKEY__@@PADU_GUID@@@Z PROC ; DXUtil_WriteGuidRegKey, COMDAT

; 254  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 255  :     if( ERROR_SUCCESS != RegSetValueEx( hKey, strRegName, 0, REG_BINARY, 
; 256  :                                         (BYTE*)&guidValue, sizeof(GUID) ) )

	mov	esi, esp
	push	16					; 00000010H
	lea	eax, DWORD PTR _guidValue$[ebp]
	push	eax
	push	3
	push	0
	mov	ecx, DWORD PTR _strRegName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hKey$[ebp]
	push	edx
	call	DWORD PTR __imp__RegSetValueExA@24
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN1@DXUtil_Wri@4

; 257  :         return E_FAIL;

	mov	eax, -2147467259			; 80004005H
	jmp	SHORT $LN2@DXUtil_Wri@4
$LN1@DXUtil_Wri@4:

; 258  : 
; 259  :     return S_OK;

	xor	eax, eax
$LN2@DXUtil_Wri@4:

; 260  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@DXUtil_Wri@4
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@DXUtil_Wri@4:
	DD	1
	DD	$LN5@DXUtil_Wri@4
$LN5@DXUtil_Wri@4:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN4@DXUtil_Wri@4
$LN4@DXUtil_Wri@4:
	DB	95					; 0000005fH
	DB	36					; 00000024H
	DB	65					; 00000041H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	0
?DXUtil_WriteGuidRegKey@@YAJPAUHKEY__@@PADU_GUID@@@Z ENDP ; DXUtil_WriteGuidRegKey
_TEXT	ENDS
PUBLIC	__real@3fb99999a0000000
PUBLIC	__real@3f50624dd2f1a9fc
PUBLIC	__real@0000000000000000
PUBLIC	__real@bf800000
PUBLIC	__real@00000000
PUBLIC	?DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z		; DXUtil_Timer
EXTRN	__imp__timeGetTime@0:PROC
EXTRN	__imp__QueryPerformanceCounter@4:PROC
EXTRN	__imp__QueryPerformanceFrequency@4:PROC
EXTRN	__fltused:DWORD
EXTRN	__alldiv:PROC
;	COMDAT __real@3fb99999a0000000
CONST	SEGMENT
__real@3fb99999a0000000 DQ 03fb99999a0000000r	; 0.1
CONST	ENDS
;	COMDAT __real@3f50624dd2f1a9fc
CONST	SEGMENT
__real@3f50624dd2f1a9fc DQ 03f50624dd2f1a9fcr	; 0.001
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z
_TEXT	SEGMENT
tv242 = -312						; size = 8
tv186 = -312						; size = 8
tv174 = -312						; size = 8
tv268 = -308						; size = 4
tv252 = -308						; size = 4
tv248 = -308						; size = 4
tv231 = -308						; size = 4
tv189 = -308						; size = 4
tv179 = -308						; size = 4
_fElapsedTime$87631 = -108				; size = 8
_fTime$87630 = -92					; size = 8
_fAppTime$87611 = -76					; size = 8
_qwTime$87603 = -60					; size = 8
_fElapsedTime$87602 = -44				; size = 8
_fTime$87601 = -28					; size = 8
_qwTicksPerSec$87592 = -12				; size = 8
_command$ = 8						; size = 4
?DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z PROC		; DXUtil_Timer, COMDAT

; 278  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 312				; 00000138H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-312]
	mov	ecx, 78					; 0000004eH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 279  :     static BOOL     m_bTimerInitialized = FALSE;
; 280  :     static BOOL     m_bUsingQPF         = FALSE;
; 281  :     static BOOL     m_bTimerStopped     = TRUE;
; 282  :     static LONGLONG m_llQPFTicksPerSec  = 0;
; 283  : 
; 284  :     // Initialize the timer
; 285  :     if( FALSE == m_bTimerInitialized )

	cmp	DWORD PTR ?m_bTimerInitialized@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4HA, 0
	jne	SHORT $LN23@DXUtil_Tim

; 286  :     {
; 287  :         m_bTimerInitialized = TRUE;

	mov	DWORD PTR ?m_bTimerInitialized@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4HA, 1

; 288  : 
; 289  :         // Use QueryPerformanceFrequency() to get frequency of timer.  If QPF is
; 290  :         // not supported, we will timeGetTime() which returns milliseconds.
; 291  :         LARGE_INTEGER qwTicksPerSec;
; 292  :         m_bUsingQPF = QueryPerformanceFrequency( &qwTicksPerSec );

	mov	esi, esp
	lea	eax, DWORD PTR _qwTicksPerSec$87592[ebp]
	push	eax
	call	DWORD PTR __imp__QueryPerformanceFrequency@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR ?m_bUsingQPF@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4HA, eax

; 293  :         if( m_bUsingQPF )

	cmp	DWORD PTR ?m_bUsingQPF@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4HA, 0
	je	SHORT $LN23@DXUtil_Tim

; 294  :             m_llQPFTicksPerSec = qwTicksPerSec.QuadPart;

	mov	eax, DWORD PTR _qwTicksPerSec$87592[ebp]
	mov	DWORD PTR ?m_llQPFTicksPerSec@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA, eax
	mov	ecx, DWORD PTR _qwTicksPerSec$87592[ebp+4]
	mov	DWORD PTR ?m_llQPFTicksPerSec@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4, ecx
$LN23@DXUtil_Tim:

; 295  :     }
; 296  : 
; 297  :     if( m_bUsingQPF )

	cmp	DWORD PTR ?m_bUsingQPF@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4HA, 0
	je	$LN22@DXUtil_Tim

; 298  :     {
; 299  :         static LONGLONG m_llStopTime        = 0;
; 300  :         static LONGLONG m_llLastElapsedTime = 0;
; 301  :         static LONGLONG m_llBaseTime        = 0;
; 302  :         double fTime;
; 303  :         double fElapsedTime;
; 304  :         LARGE_INTEGER qwTime;
; 305  :         
; 306  :         // Get either the current time or the stop time, depending
; 307  :         // on whether we're stopped and what command was sent
; 308  :         if( m_llStopTime != 0 && command != TIMER_START && command != TIMER_GETABSOLUTETIME)

	mov	eax, DWORD PTR ?m_llStopTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA
	or	eax, DWORD PTR ?m_llStopTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4
	je	SHORT $LN21@DXUtil_Tim
	cmp	DWORD PTR _command$[ebp], 1
	je	SHORT $LN21@DXUtil_Tim
	cmp	DWORD PTR _command$[ebp], 4
	je	SHORT $LN21@DXUtil_Tim

; 309  :             qwTime.QuadPart = m_llStopTime;

	mov	eax, DWORD PTR ?m_llStopTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA
	mov	DWORD PTR _qwTime$87603[ebp], eax
	mov	ecx, DWORD PTR ?m_llStopTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4
	mov	DWORD PTR _qwTime$87603[ebp+4], ecx

; 310  :         else

	jmp	SHORT $LN20@DXUtil_Tim
$LN21@DXUtil_Tim:

; 311  :             QueryPerformanceCounter( &qwTime );

	mov	esi, esp
	lea	eax, DWORD PTR _qwTime$87603[ebp]
	push	eax
	call	DWORD PTR __imp__QueryPerformanceCounter@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN20@DXUtil_Tim:

; 312  : 
; 313  :         // Return the elapsed time
; 314  :         if( command == TIMER_GETELAPSEDTIME )

	cmp	DWORD PTR _command$[ebp], 6
	jne	SHORT $LN19@DXUtil_Tim

; 315  :         {
; 316  :             fElapsedTime = (double) ( qwTime.QuadPart - m_llLastElapsedTime ) / (double) m_llQPFTicksPerSec;

	mov	eax, DWORD PTR _qwTime$87603[ebp]
	sub	eax, DWORD PTR ?m_llLastElapsedTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA
	mov	ecx, DWORD PTR _qwTime$87603[ebp+4]
	sbb	ecx, DWORD PTR ?m_llLastElapsedTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4
	mov	DWORD PTR tv174[ebp], eax
	mov	DWORD PTR tv174[ebp+4], ecx
	fild	QWORD PTR tv174[ebp]
	fild	QWORD PTR ?m_llQPFTicksPerSec@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA
	fdivp	ST(1), ST(0)
	fstp	QWORD PTR _fElapsedTime$87602[ebp]

; 317  :             m_llLastElapsedTime = qwTime.QuadPart;

	mov	eax, DWORD PTR _qwTime$87603[ebp]
	mov	DWORD PTR ?m_llLastElapsedTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA, eax
	mov	ecx, DWORD PTR _qwTime$87603[ebp+4]
	mov	DWORD PTR ?m_llLastElapsedTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4, ecx

; 318  :             return (FLOAT) fElapsedTime;

	fld	QWORD PTR _fElapsedTime$87602[ebp]
	fstp	DWORD PTR tv179[ebp]
	fld	DWORD PTR tv179[ebp]
	jmp	$LN11@DXUtil_Tim
$LN19@DXUtil_Tim:

; 319  :         }
; 320  :     
; 321  :         // Return the current time
; 322  :         if( command == TIMER_GETAPPTIME )

	cmp	DWORD PTR _command$[ebp], 5
	jne	SHORT $LN18@DXUtil_Tim

; 323  :         {
; 324  :             double fAppTime = (double) ( qwTime.QuadPart - m_llBaseTime ) / (double) m_llQPFTicksPerSec;

	mov	eax, DWORD PTR _qwTime$87603[ebp]
	sub	eax, DWORD PTR ?m_llBaseTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA
	mov	ecx, DWORD PTR _qwTime$87603[ebp+4]
	sbb	ecx, DWORD PTR ?m_llBaseTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4
	mov	DWORD PTR tv186[ebp], eax
	mov	DWORD PTR tv186[ebp+4], ecx
	fild	QWORD PTR tv186[ebp]
	fild	QWORD PTR ?m_llQPFTicksPerSec@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA
	fdivp	ST(1), ST(0)
	fstp	QWORD PTR _fAppTime$87611[ebp]

; 325  :             return (FLOAT) fAppTime;

	fld	QWORD PTR _fAppTime$87611[ebp]
	fstp	DWORD PTR tv189[ebp]
	fld	DWORD PTR tv189[ebp]
	jmp	$LN11@DXUtil_Tim
$LN18@DXUtil_Tim:

; 326  :         }
; 327  :     
; 328  :         // Reset the timer
; 329  :         if( command == TIMER_RESET )

	cmp	DWORD PTR _command$[ebp], 0
	jne	SHORT $LN17@DXUtil_Tim

; 330  :         {
; 331  :             m_llBaseTime        = qwTime.QuadPart;

	mov	eax, DWORD PTR _qwTime$87603[ebp]
	mov	DWORD PTR ?m_llBaseTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA, eax
	mov	ecx, DWORD PTR _qwTime$87603[ebp+4]
	mov	DWORD PTR ?m_llBaseTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4, ecx

; 332  :             m_llLastElapsedTime = qwTime.QuadPart;

	mov	eax, DWORD PTR _qwTime$87603[ebp]
	mov	DWORD PTR ?m_llLastElapsedTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA, eax
	mov	ecx, DWORD PTR _qwTime$87603[ebp+4]
	mov	DWORD PTR ?m_llLastElapsedTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4, ecx

; 333  :             m_llStopTime        = 0;

	mov	DWORD PTR ?m_llStopTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA, 0
	mov	DWORD PTR ?m_llStopTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4, 0

; 334  :             m_bTimerStopped     = FALSE;

	mov	DWORD PTR ?m_bTimerStopped@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4HA, 0

; 335  :             return 0.0f;

	fldz
	jmp	$LN11@DXUtil_Tim
$LN17@DXUtil_Tim:

; 336  :         }
; 337  :     
; 338  :         // Start the timer
; 339  :         if( command == TIMER_START )

	cmp	DWORD PTR _command$[ebp], 1
	jne	SHORT $LN16@DXUtil_Tim

; 340  :         {
; 341  :             if( m_bTimerStopped )

	cmp	DWORD PTR ?m_bTimerStopped@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4HA, 0
	je	SHORT $LN15@DXUtil_Tim

; 342  :                 m_llBaseTime += qwTime.QuadPart - m_llStopTime;

	mov	eax, DWORD PTR _qwTime$87603[ebp]
	sub	eax, DWORD PTR ?m_llStopTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA
	mov	ecx, DWORD PTR _qwTime$87603[ebp+4]
	sbb	ecx, DWORD PTR ?m_llStopTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4
	add	eax, DWORD PTR ?m_llBaseTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA
	mov	edx, DWORD PTR ?m_llBaseTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4
	adc	edx, ecx
	mov	DWORD PTR ?m_llBaseTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA, eax
	mov	DWORD PTR ?m_llBaseTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4, edx
$LN15@DXUtil_Tim:

; 343  :             m_llStopTime = 0;

	mov	DWORD PTR ?m_llStopTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA, 0
	mov	DWORD PTR ?m_llStopTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4, 0

; 344  :             m_llLastElapsedTime = qwTime.QuadPart;

	mov	eax, DWORD PTR _qwTime$87603[ebp]
	mov	DWORD PTR ?m_llLastElapsedTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA, eax
	mov	ecx, DWORD PTR _qwTime$87603[ebp+4]
	mov	DWORD PTR ?m_llLastElapsedTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4, ecx

; 345  :             m_bTimerStopped = FALSE;

	mov	DWORD PTR ?m_bTimerStopped@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4HA, 0

; 346  :             return 0.0f;

	fldz
	jmp	$LN11@DXUtil_Tim
$LN16@DXUtil_Tim:

; 347  :         }
; 348  :     
; 349  :         // Stop the timer
; 350  :         if( command == TIMER_STOP )

	cmp	DWORD PTR _command$[ebp], 2
	jne	SHORT $LN14@DXUtil_Tim

; 351  :         {
; 352  :             m_llStopTime = qwTime.QuadPart;

	mov	eax, DWORD PTR _qwTime$87603[ebp]
	mov	DWORD PTR ?m_llStopTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA, eax
	mov	ecx, DWORD PTR _qwTime$87603[ebp+4]
	mov	DWORD PTR ?m_llStopTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4, ecx

; 353  :             m_llLastElapsedTime = qwTime.QuadPart;

	mov	eax, DWORD PTR _qwTime$87603[ebp]
	mov	DWORD PTR ?m_llLastElapsedTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA, eax
	mov	ecx, DWORD PTR _qwTime$87603[ebp+4]
	mov	DWORD PTR ?m_llLastElapsedTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4, ecx

; 354  :             m_bTimerStopped = TRUE;

	mov	DWORD PTR ?m_bTimerStopped@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4HA, 1

; 355  :             return 0.0f;

	fldz
	jmp	$LN11@DXUtil_Tim
$LN14@DXUtil_Tim:

; 356  :         }
; 357  :     
; 358  :         // Advance the timer by 1/10th second
; 359  :         if( command == TIMER_ADVANCE )

	cmp	DWORD PTR _command$[ebp], 3
	jne	SHORT $LN13@DXUtil_Tim

; 360  :         {
; 361  :             m_llStopTime += m_llQPFTicksPerSec/10;

	push	0
	push	10					; 0000000aH
	mov	eax, DWORD PTR ?m_llQPFTicksPerSec@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4
	push	eax
	mov	ecx, DWORD PTR ?m_llQPFTicksPerSec@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA
	push	ecx
	call	__alldiv
	add	eax, DWORD PTR ?m_llStopTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA
	mov	ecx, DWORD PTR ?m_llStopTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4
	adc	ecx, edx
	mov	DWORD PTR ?m_llStopTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA, eax
	mov	DWORD PTR ?m_llStopTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4, ecx

; 362  :             return 0.0f;

	fldz
	jmp	$LN11@DXUtil_Tim
$LN13@DXUtil_Tim:

; 363  :         }
; 364  : 
; 365  :         if( command == TIMER_GETABSOLUTETIME )

	cmp	DWORD PTR _command$[ebp], 4
	jne	SHORT $LN12@DXUtil_Tim

; 366  :         {
; 367  :             fTime = qwTime.QuadPart / (double) m_llQPFTicksPerSec;

	fild	QWORD PTR _qwTime$87603[ebp]
	fild	QWORD PTR ?m_llQPFTicksPerSec@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA
	fdivp	ST(1), ST(0)
	fstp	QWORD PTR _fTime$87601[ebp]

; 368  :             return (FLOAT) fTime;

	fld	QWORD PTR _fTime$87601[ebp]
	fstp	DWORD PTR tv231[ebp]
	fld	DWORD PTR tv231[ebp]
	jmp	$LN11@DXUtil_Tim
$LN12@DXUtil_Tim:

; 369  :         }
; 370  : 
; 371  :         return -1.0f; // Invalid command specified

	fld	DWORD PTR __real@bf800000
	jmp	$LN11@DXUtil_Tim

; 372  :     }
; 373  :     else

	jmp	$LN11@DXUtil_Tim
$LN22@DXUtil_Tim:

; 374  :     {
; 375  :         // Get the time using timeGetTime()
; 376  :         static double m_fLastElapsedTime  = 0.0;
; 377  :         static double m_fBaseTime         = 0.0;
; 378  :         static double m_fStopTime         = 0.0;
; 379  :         double fTime;
; 380  :         double fElapsedTime;
; 381  :         
; 382  :         // Get either the current time or the stop time, depending
; 383  :         // on whether we're stopped and what command was sent
; 384  :         if( m_fStopTime != 0.0 && command != TIMER_START && command != TIMER_GETABSOLUTETIME)

	fldz
	fcomp	QWORD PTR ?m_fStopTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN10@DXUtil_Tim
	cmp	DWORD PTR _command$[ebp], 1
	je	SHORT $LN10@DXUtil_Tim
	cmp	DWORD PTR _command$[ebp], 4
	je	SHORT $LN10@DXUtil_Tim

; 385  :             fTime = m_fStopTime;

	fld	QWORD PTR ?m_fStopTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA
	fstp	QWORD PTR _fTime$87630[ebp]

; 386  :         else

	jmp	SHORT $LN9@DXUtil_Tim
$LN10@DXUtil_Tim:

; 387  :             fTime = timeGetTime() * 0.001;

	mov	esi, esp
	call	DWORD PTR __imp__timeGetTime@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv242[ebp], eax
	mov	DWORD PTR tv242[ebp+4], 0
	fild	QWORD PTR tv242[ebp]
	fmul	QWORD PTR __real@3f50624dd2f1a9fc
	fstp	QWORD PTR _fTime$87630[ebp]
$LN9@DXUtil_Tim:

; 388  :     
; 389  :         // Return the elapsed time
; 390  :         if( command == TIMER_GETELAPSEDTIME )

	cmp	DWORD PTR _command$[ebp], 6
	jne	SHORT $LN8@DXUtil_Tim

; 391  :         {   
; 392  :             fElapsedTime = (double) (fTime - m_fLastElapsedTime);

	fld	QWORD PTR _fTime$87630[ebp]
	fsub	QWORD PTR ?m_fLastElapsedTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA
	fstp	QWORD PTR _fElapsedTime$87631[ebp]

; 393  :             m_fLastElapsedTime = fTime;

	fld	QWORD PTR _fTime$87630[ebp]
	fstp	QWORD PTR ?m_fLastElapsedTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA

; 394  :             return (FLOAT) fElapsedTime;

	fld	QWORD PTR _fElapsedTime$87631[ebp]
	fstp	DWORD PTR tv248[ebp]
	fld	DWORD PTR tv248[ebp]
	jmp	$LN11@DXUtil_Tim
$LN8@DXUtil_Tim:

; 395  :         }
; 396  :     
; 397  :         // Return the current time
; 398  :         if( command == TIMER_GETAPPTIME )

	cmp	DWORD PTR _command$[ebp], 5
	jne	SHORT $LN7@DXUtil_Tim

; 399  :         {
; 400  :             return (FLOAT) (fTime - m_fBaseTime);

	fld	QWORD PTR _fTime$87630[ebp]
	fsub	QWORD PTR ?m_fBaseTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA
	fstp	DWORD PTR tv252[ebp]
	fld	DWORD PTR tv252[ebp]
	jmp	$LN11@DXUtil_Tim
$LN7@DXUtil_Tim:

; 401  :         }
; 402  :     
; 403  :         // Reset the timer
; 404  :         if( command == TIMER_RESET )

	cmp	DWORD PTR _command$[ebp], 0
	jne	SHORT $LN6@DXUtil_Tim

; 405  :         {
; 406  :             m_fBaseTime         = fTime;

	fld	QWORD PTR _fTime$87630[ebp]
	fstp	QWORD PTR ?m_fBaseTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA

; 407  :             m_fLastElapsedTime  = fTime;

	fld	QWORD PTR _fTime$87630[ebp]
	fstp	QWORD PTR ?m_fLastElapsedTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA

; 408  :             m_fStopTime         = 0;

	fldz
	fstp	QWORD PTR ?m_fStopTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA

; 409  :             m_bTimerStopped     = FALSE;

	mov	DWORD PTR ?m_bTimerStopped@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4HA, 0

; 410  :             return 0.0f;

	fldz
	jmp	$LN11@DXUtil_Tim
$LN6@DXUtil_Tim:

; 411  :         }
; 412  :     
; 413  :         // Start the timer
; 414  :         if( command == TIMER_START )

	cmp	DWORD PTR _command$[ebp], 1
	jne	SHORT $LN5@DXUtil_Tim

; 415  :         {
; 416  :             if( m_bTimerStopped )

	cmp	DWORD PTR ?m_bTimerStopped@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4HA, 0
	je	SHORT $LN4@DXUtil_Tim

; 417  :                 m_fBaseTime += fTime - m_fStopTime;

	fld	QWORD PTR _fTime$87630[ebp]
	fsub	QWORD PTR ?m_fStopTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA
	fadd	QWORD PTR ?m_fBaseTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA
	fstp	QWORD PTR ?m_fBaseTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA
$LN4@DXUtil_Tim:

; 418  :             m_fStopTime = 0.0f;

	fldz
	fstp	QWORD PTR ?m_fStopTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA

; 419  :             m_fLastElapsedTime  = fTime;

	fld	QWORD PTR _fTime$87630[ebp]
	fstp	QWORD PTR ?m_fLastElapsedTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA

; 420  :             m_bTimerStopped = FALSE;

	mov	DWORD PTR ?m_bTimerStopped@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4HA, 0

; 421  :             return 0.0f;

	fldz
	jmp	SHORT $LN11@DXUtil_Tim
$LN5@DXUtil_Tim:

; 422  :         }
; 423  :     
; 424  :         // Stop the timer
; 425  :         if( command == TIMER_STOP )

	cmp	DWORD PTR _command$[ebp], 2
	jne	SHORT $LN3@DXUtil_Tim

; 426  :         {
; 427  :             m_fStopTime = fTime;

	fld	QWORD PTR _fTime$87630[ebp]
	fstp	QWORD PTR ?m_fStopTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA

; 428  :             m_fLastElapsedTime  = fTime;

	fld	QWORD PTR _fTime$87630[ebp]
	fstp	QWORD PTR ?m_fLastElapsedTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA

; 429  :             m_bTimerStopped = TRUE;

	mov	DWORD PTR ?m_bTimerStopped@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4HA, 1

; 430  :             return 0.0f;

	fldz
	jmp	SHORT $LN11@DXUtil_Tim
$LN3@DXUtil_Tim:

; 431  :         }
; 432  :     
; 433  :         // Advance the timer by 1/10th second
; 434  :         if( command == TIMER_ADVANCE )

	cmp	DWORD PTR _command$[ebp], 3
	jne	SHORT $LN2@DXUtil_Tim

; 435  :         {
; 436  :             m_fStopTime += 0.1f;

	fld	QWORD PTR ?m_fStopTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA
	fadd	QWORD PTR __real@3fb99999a0000000
	fstp	QWORD PTR ?m_fStopTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA

; 437  :             return 0.0f;

	fldz
	jmp	SHORT $LN11@DXUtil_Tim
$LN2@DXUtil_Tim:

; 438  :         }
; 439  : 
; 440  :         if( command == TIMER_GETABSOLUTETIME )

	cmp	DWORD PTR _command$[ebp], 4
	jne	SHORT $LN1@DXUtil_Tim

; 441  :         {
; 442  :             return (FLOAT) fTime;

	fld	QWORD PTR _fTime$87630[ebp]
	fstp	DWORD PTR tv268[ebp]
	fld	DWORD PTR tv268[ebp]
	jmp	SHORT $LN11@DXUtil_Tim
$LN1@DXUtil_Tim:

; 443  :         }
; 444  : 
; 445  :         return -1.0f; // Invalid command specified

	fld	DWORD PTR __real@bf800000
$LN11@DXUtil_Tim:

; 446  :     }
; 447  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN30@DXUtil_Tim
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 312				; 00000138H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN30@DXUtil_Tim:
	DD	2
	DD	$LN29@DXUtil_Tim
$LN29@DXUtil_Tim:
	DD	-12					; fffffff4H
	DD	8
	DD	$LN27@DXUtil_Tim
	DD	-60					; ffffffc4H
	DD	8
	DD	$LN28@DXUtil_Tim
$LN28@DXUtil_Tim:
	DB	113					; 00000071H
	DB	119					; 00000077H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
$LN27@DXUtil_Tim:
	DB	113					; 00000071H
	DB	119					; 00000077H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	115					; 00000073H
	DB	80					; 00000050H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	83					; 00000053H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	0
?DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z ENDP		; DXUtil_Timer
_TEXT	ENDS
PUBLIC	?DXUtil_ConvertAnsiStringToWide@@YAXPA_WPBDH@Z	; DXUtil_ConvertAnsiStringToWide
EXTRN	__imp__MultiByteToWideChar@24:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?DXUtil_ConvertAnsiStringToWide@@YAXPA_WPBDH@Z
_TEXT	SEGMENT
_wstrDestination$ = 8					; size = 4
_strSource$ = 12					; size = 4
_cchDestChar$ = 16					; size = 4
?DXUtil_ConvertAnsiStringToWide@@YAXPA_WPBDH@Z PROC	; DXUtil_ConvertAnsiStringToWide, COMDAT

; 460  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 461  :     if( wstrDestination==NULL || strSource==NULL )

	cmp	DWORD PTR _wstrDestination$[ebp], 0
	je	SHORT $LN2@DXUtil_Con
	cmp	DWORD PTR _strSource$[ebp], 0
	jne	SHORT $LN3@DXUtil_Con
$LN2@DXUtil_Con:

; 462  :         return;

	jmp	SHORT $LN4@DXUtil_Con
$LN3@DXUtil_Con:

; 463  : 
; 464  :     if( cchDestChar == -1 )

	cmp	DWORD PTR _cchDestChar$[ebp], -1
	jne	SHORT $LN1@DXUtil_Con

; 465  :         cchDestChar = strlen(strSource)+1;

	mov	eax, DWORD PTR _strSource$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 1
	mov	DWORD PTR _cchDestChar$[ebp], eax
$LN1@DXUtil_Con:

; 466  : 
; 467  :     MultiByteToWideChar( CP_ACP, 0, strSource, -1, 
; 468  :                          wstrDestination, cchDestChar-1 );

	mov	eax, DWORD PTR _cchDestChar$[ebp]
	sub	eax, 1
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _wstrDestination$[ebp]
	push	ecx
	push	-1
	mov	edx, DWORD PTR _strSource$[ebp]
	push	edx
	push	0
	push	0
	call	DWORD PTR __imp__MultiByteToWideChar@24
	cmp	esi, esp
	call	__RTC_CheckEsp

; 469  : 
; 470  :     wstrDestination[cchDestChar-1] = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _cchDestChar$[ebp]
	mov	edx, DWORD PTR _wstrDestination$[ebp]
	mov	WORD PTR [edx+ecx*2-2], ax
$LN4@DXUtil_Con:

; 471  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUtil_ConvertAnsiStringToWide@@YAXPA_WPBDH@Z ENDP	; DXUtil_ConvertAnsiStringToWide
_TEXT	ENDS
PUBLIC	?DXUtil_ConvertWideStringToAnsi@@YAXPADPB_WH@Z	; DXUtil_ConvertWideStringToAnsi
EXTRN	__imp__WideCharToMultiByte@32:PROC
EXTRN	_wcslen:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?DXUtil_ConvertWideStringToAnsi@@YAXPADPB_WH@Z
_TEXT	SEGMENT
_strDestination$ = 8					; size = 4
_wstrSource$ = 12					; size = 4
_cchDestChar$ = 16					; size = 4
?DXUtil_ConvertWideStringToAnsi@@YAXPADPB_WH@Z PROC	; DXUtil_ConvertWideStringToAnsi, COMDAT

; 484  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 485  :     if( strDestination==NULL || wstrSource==NULL )

	cmp	DWORD PTR _strDestination$[ebp], 0
	je	SHORT $LN2@DXUtil_Con@2
	cmp	DWORD PTR _wstrSource$[ebp], 0
	jne	SHORT $LN3@DXUtil_Con@2
$LN2@DXUtil_Con@2:

; 486  :         return;

	jmp	SHORT $LN4@DXUtil_Con@2
$LN3@DXUtil_Con@2:

; 487  : 
; 488  :     if( cchDestChar == -1 )

	cmp	DWORD PTR _cchDestChar$[ebp], -1
	jne	SHORT $LN1@DXUtil_Con@2

; 489  :         cchDestChar = wcslen(wstrSource)+1;

	mov	eax, DWORD PTR _wstrSource$[ebp]
	push	eax
	call	_wcslen
	add	esp, 4
	add	eax, 1
	mov	DWORD PTR _cchDestChar$[ebp], eax
$LN1@DXUtil_Con@2:

; 490  : 
; 491  :     WideCharToMultiByte( CP_ACP, 0, wstrSource, -1, strDestination, 
; 492  :                          cchDestChar-1, NULL, NULL );

	mov	esi, esp
	push	0
	push	0
	mov	eax, DWORD PTR _cchDestChar$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _strDestination$[ebp]
	push	ecx
	push	-1
	mov	edx, DWORD PTR _wstrSource$[ebp]
	push	edx
	push	0
	push	0
	call	DWORD PTR __imp__WideCharToMultiByte@32
	cmp	esi, esp
	call	__RTC_CheckEsp

; 493  : 
; 494  :     strDestination[cchDestChar-1] = 0;

	mov	eax, DWORD PTR _strDestination$[ebp]
	add	eax, DWORD PTR _cchDestChar$[ebp]
	mov	BYTE PTR [eax-1], 0
$LN4@DXUtil_Con@2:

; 495  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUtil_ConvertWideStringToAnsi@@YAXPADPB_WH@Z ENDP	; DXUtil_ConvertWideStringToAnsi
_TEXT	ENDS
PUBLIC	?DXUtil_ConvertGenericStringToAnsi@@YAXPADPBDH@Z ; DXUtil_ConvertGenericStringToAnsi
EXTRN	_strncpy:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?DXUtil_ConvertGenericStringToAnsi@@YAXPADPBDH@Z
_TEXT	SEGMENT
_strDestination$ = 8					; size = 4
_tstrSource$ = 12					; size = 4
_cchDestChar$ = 16					; size = 4
?DXUtil_ConvertGenericStringToAnsi@@YAXPADPBDH@Z PROC	; DXUtil_ConvertGenericStringToAnsi, COMDAT

; 508  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 509  :     if( strDestination==NULL || tstrSource==NULL || cchDestChar == 0 )

	cmp	DWORD PTR _strDestination$[ebp], 0
	je	SHORT $LN3@DXUtil_Con@3
	cmp	DWORD PTR _tstrSource$[ebp], 0
	je	SHORT $LN3@DXUtil_Con@3
	cmp	DWORD PTR _cchDestChar$[ebp], 0
	jne	SHORT $LN4@DXUtil_Con@3
$LN3@DXUtil_Con@3:

; 510  :         return;

	jmp	SHORT $LN5@DXUtil_Con@3
$LN4@DXUtil_Con@3:

; 511  : 
; 512  : #ifdef _UNICODE
; 513  :     DXUtil_ConvertWideStringToAnsi( strDestination, tstrSource, cchDestChar );
; 514  : #else
; 515  :     if( cchDestChar == -1 )

	cmp	DWORD PTR _cchDestChar$[ebp], -1
	jne	SHORT $LN2@DXUtil_Con@3

; 516  :     {
; 517  :         strcpy( strDestination, tstrSource );

	mov	eax, DWORD PTR _tstrSource$[ebp]
	push	eax
	mov	ecx, DWORD PTR _strDestination$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 518  :     }
; 519  :     else

	jmp	SHORT $LN5@DXUtil_Con@3
$LN2@DXUtil_Con@3:

; 520  :     {
; 521  :         strncpy( strDestination, tstrSource, cchDestChar );

	mov	eax, DWORD PTR _cchDestChar$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tstrSource$[ebp]
	push	ecx
	mov	edx, DWORD PTR _strDestination$[ebp]
	push	edx
	call	_strncpy
	add	esp, 12					; 0000000cH

; 522  :         strDestination[cchDestChar-1] = '\0';

	mov	eax, DWORD PTR _strDestination$[ebp]
	add	eax, DWORD PTR _cchDestChar$[ebp]
	mov	BYTE PTR [eax-1], 0
$LN5@DXUtil_Con@3:

; 523  :     }
; 524  : #endif
; 525  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUtil_ConvertGenericStringToAnsi@@YAXPADPBDH@Z ENDP	; DXUtil_ConvertGenericStringToAnsi
_TEXT	ENDS
PUBLIC	?DXUtil_ConvertGenericStringToWide@@YAXPA_WPBDH@Z ; DXUtil_ConvertGenericStringToWide
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?DXUtil_ConvertGenericStringToWide@@YAXPA_WPBDH@Z
_TEXT	SEGMENT
_wstrDestination$ = 8					; size = 4
_tstrSource$ = 12					; size = 4
_cchDestChar$ = 16					; size = 4
?DXUtil_ConvertGenericStringToWide@@YAXPA_WPBDH@Z PROC	; DXUtil_ConvertGenericStringToWide, COMDAT

; 538  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 539  :     if( wstrDestination==NULL || tstrSource==NULL || cchDestChar == 0 )

	cmp	DWORD PTR _wstrDestination$[ebp], 0
	je	SHORT $LN1@DXUtil_Con@4
	cmp	DWORD PTR _tstrSource$[ebp], 0
	je	SHORT $LN1@DXUtil_Con@4
	cmp	DWORD PTR _cchDestChar$[ebp], 0
	jne	SHORT $LN2@DXUtil_Con@4
$LN1@DXUtil_Con@4:

; 540  :         return;

	jmp	SHORT $LN3@DXUtil_Con@4
$LN2@DXUtil_Con@4:

; 541  : 
; 542  : #ifdef _UNICODE
; 543  :     if( cchDestChar == -1 )
; 544  :     {
; 545  :         wcscpy( wstrDestination, tstrSource );
; 546  :     }
; 547  :     else
; 548  :     {
; 549  :         wcsncpy( wstrDestination, tstrSource, cchDestChar );
; 550  :         wstrDestination[cchDestChar-1] = L'\0';
; 551  :     }
; 552  : #else
; 553  :     DXUtil_ConvertAnsiStringToWide( wstrDestination, tstrSource, cchDestChar );

	mov	eax, DWORD PTR _cchDestChar$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tstrSource$[ebp]
	push	ecx
	mov	edx, DWORD PTR _wstrDestination$[ebp]
	push	edx
	call	?DXUtil_ConvertAnsiStringToWide@@YAXPA_WPBDH@Z ; DXUtil_ConvertAnsiStringToWide
	add	esp, 12					; 0000000cH
$LN3@DXUtil_Con@4:

; 554  : #endif
; 555  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUtil_ConvertGenericStringToWide@@YAXPA_WPBDH@Z ENDP	; DXUtil_ConvertGenericStringToWide
_TEXT	ENDS
PUBLIC	?DXUtil_ConvertAnsiStringToGeneric@@YAXPADPBDH@Z ; DXUtil_ConvertAnsiStringToGeneric
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?DXUtil_ConvertAnsiStringToGeneric@@YAXPADPBDH@Z
_TEXT	SEGMENT
_tstrDestination$ = 8					; size = 4
_strSource$ = 12					; size = 4
_cchDestChar$ = 16					; size = 4
?DXUtil_ConvertAnsiStringToGeneric@@YAXPADPBDH@Z PROC	; DXUtil_ConvertAnsiStringToGeneric, COMDAT

; 568  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 569  :     if( tstrDestination==NULL || strSource==NULL || cchDestChar == 0 )

	cmp	DWORD PTR _tstrDestination$[ebp], 0
	je	SHORT $LN3@DXUtil_Con@5
	cmp	DWORD PTR _strSource$[ebp], 0
	je	SHORT $LN3@DXUtil_Con@5
	cmp	DWORD PTR _cchDestChar$[ebp], 0
	jne	SHORT $LN4@DXUtil_Con@5
$LN3@DXUtil_Con@5:

; 570  :         return;

	jmp	SHORT $LN5@DXUtil_Con@5
$LN4@DXUtil_Con@5:

; 571  :         
; 572  : #ifdef _UNICODE
; 573  :     DXUtil_ConvertAnsiStringToWide( tstrDestination, strSource, cchDestChar );
; 574  : #else
; 575  :     if( cchDestChar == -1 )

	cmp	DWORD PTR _cchDestChar$[ebp], -1
	jne	SHORT $LN2@DXUtil_Con@5

; 576  :     {
; 577  :         strcpy( tstrDestination, strSource );

	mov	eax, DWORD PTR _strSource$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tstrDestination$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 578  :     }
; 579  :     else

	jmp	SHORT $LN5@DXUtil_Con@5
$LN2@DXUtil_Con@5:

; 580  :     {
; 581  :         strncpy( tstrDestination, strSource, cchDestChar );

	mov	eax, DWORD PTR _cchDestChar$[ebp]
	push	eax
	mov	ecx, DWORD PTR _strSource$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tstrDestination$[ebp]
	push	edx
	call	_strncpy
	add	esp, 12					; 0000000cH

; 582  :         tstrDestination[cchDestChar-1] = '\0';

	mov	eax, DWORD PTR _tstrDestination$[ebp]
	add	eax, DWORD PTR _cchDestChar$[ebp]
	mov	BYTE PTR [eax-1], 0
$LN5@DXUtil_Con@5:

; 583  :     }
; 584  : #endif
; 585  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUtil_ConvertAnsiStringToGeneric@@YAXPADPBDH@Z ENDP	; DXUtil_ConvertAnsiStringToGeneric
_TEXT	ENDS
PUBLIC	?DXUtil_ConvertWideStringToGeneric@@YAXPADPB_WH@Z ; DXUtil_ConvertWideStringToGeneric
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?DXUtil_ConvertWideStringToGeneric@@YAXPADPB_WH@Z
_TEXT	SEGMENT
_tstrDestination$ = 8					; size = 4
_wstrSource$ = 12					; size = 4
_cchDestChar$ = 16					; size = 4
?DXUtil_ConvertWideStringToGeneric@@YAXPADPB_WH@Z PROC	; DXUtil_ConvertWideStringToGeneric, COMDAT

; 598  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 599  :     if( tstrDestination==NULL || wstrSource==NULL || cchDestChar == 0 )

	cmp	DWORD PTR _tstrDestination$[ebp], 0
	je	SHORT $LN1@DXUtil_Con@6
	cmp	DWORD PTR _wstrSource$[ebp], 0
	je	SHORT $LN1@DXUtil_Con@6
	cmp	DWORD PTR _cchDestChar$[ebp], 0
	jne	SHORT $LN2@DXUtil_Con@6
$LN1@DXUtil_Con@6:

; 600  :         return;

	jmp	SHORT $LN3@DXUtil_Con@6
$LN2@DXUtil_Con@6:

; 601  : 
; 602  : #ifdef _UNICODE
; 603  :     if( cchDestChar == -1 )
; 604  :     {
; 605  :         wcscpy( tstrDestination, wstrSource );
; 606  :     }
; 607  :     else
; 608  :     {
; 609  :         wcsncpy( tstrDestination, wstrSource, cchDestChar );
; 610  :         tstrDestination[cchDestChar-1] = L'\0';
; 611  :     }
; 612  : #else
; 613  :     DXUtil_ConvertWideStringToAnsi( tstrDestination, wstrSource, cchDestChar );

	mov	eax, DWORD PTR _cchDestChar$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wstrSource$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tstrDestination$[ebp]
	push	edx
	call	?DXUtil_ConvertWideStringToAnsi@@YAXPADPB_WH@Z ; DXUtil_ConvertWideStringToAnsi
	add	esp, 12					; 0000000cH
$LN3@DXUtil_Con@6:

; 614  : #endif
; 615  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUtil_ConvertWideStringToGeneric@@YAXPADPB_WH@Z ENDP	; DXUtil_ConvertWideStringToGeneric
_TEXT	ENDS
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_0M@JDCEFKLB@?$CIhr?$DN?$CF08lx?$CJ?6?$AA@	; `string'
PUBLIC	??_C@_09LJPPHFCJ@?$CFs?$CI?$CFld?$CJ?3?5?$AA@	; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?_DbgOut@@YAJPADKJ0@Z				; _DbgOut
EXTRN	__imp__OutputDebugStringA@4:PROC
EXTRN	__imp__wsprintfA:PROC
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JDCEFKLB@?$CIhr?$DN?$CF08lx?$CJ?6?$AA@
CONST	SEGMENT
??_C@_0M@JDCEFKLB@?$CIhr?$DN?$CF08lx?$CJ?6?$AA@ DB '(hr=%08lx)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09LJPPHFCJ@?$CFs?$CI?$CFld?$CJ?3?5?$AA@
CONST	SEGMENT
??_C@_09LJPPHFCJ@?$CFs?$CI?$CFld?$CJ?3?5?$AA@ DB '%s(%ld): ', 00H ; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?_DbgOut@@YAJPADKJ0@Z
_TEXT	SEGMENT
_buffer$ = -264						; size = 256
__$ArrayPad$ = -4					; size = 4
_strFile$ = 8						; size = 4
_dwLine$ = 12						; size = 4
_hr$ = 16						; size = 4
_strMsg$ = 20						; size = 4
?_DbgOut@@YAJPADKJ0@Z PROC				; _DbgOut, COMDAT

; 625  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 460				; 000001ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-460]
	mov	ecx, 115				; 00000073H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 626  :     TCHAR buffer[256];
; 627  :     wsprintf( buffer, _T("%s(%ld): "), strFile, dwLine );

	mov	esi, esp
	mov	eax, DWORD PTR _dwLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _strFile$[ebp]
	push	ecx
	push	OFFSET ??_C@_09LJPPHFCJ@?$CFs?$CI?$CFld?$CJ?3?5?$AA@
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 628  :     OutputDebugString( buffer );

	mov	esi, esp
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR __imp__OutputDebugStringA@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 629  :     OutputDebugString( strMsg );

	mov	esi, esp
	mov	eax, DWORD PTR _strMsg$[ebp]
	push	eax
	call	DWORD PTR __imp__OutputDebugStringA@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 630  : 
; 631  :     if( hr )

	cmp	DWORD PTR _hr$[ebp], 0
	je	SHORT $LN1@DbgOut

; 632  :     {
; 633  :         wsprintf( buffer, _T("(hr=%08lx)\n"), hr );

	mov	esi, esp
	mov	eax, DWORD PTR _hr$[ebp]
	push	eax
	push	OFFSET ??_C@_0M@JDCEFKLB@?$CIhr?$DN?$CF08lx?$CJ?6?$AA@
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 634  :         OutputDebugString( buffer );

	mov	esi, esp
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR __imp__OutputDebugStringA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@DbgOut:

; 635  :     }
; 636  : 
; 637  :     OutputDebugString( _T("\n") );

	mov	esi, esp
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	DWORD PTR __imp__OutputDebugStringA@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 638  : 
; 639  :     return hr;

	mov	eax, DWORD PTR _hr$[ebp]

; 640  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@DbgOut
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 460				; 000001ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN6@DbgOut:
	DD	1
	DD	$LN5@DbgOut
$LN5@DbgOut:
	DD	-264					; fffffef8H
	DD	256					; 00000100H
	DD	$LN4@DbgOut
$LN4@DbgOut:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
?_DbgOut@@YAJPADKJ0@Z ENDP				; _DbgOut
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?DXUtil_Trace@@YAXPADZZ				; DXUtil_Trace
EXTRN	__vsnprintf:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?DXUtil_Trace@@YAXPADZZ
_TEXT	SEGMENT
_args$ = -532						; size = 4
_strBuffer$ = -520					; size = 512
__$ArrayPad$ = -4					; size = 4
_strMsg$ = 8						; size = 4
?DXUtil_Trace@@YAXPADZZ PROC				; DXUtil_Trace, COMDAT

; 651  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 728				; 000002d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-728]
	mov	ecx, 182				; 000000b6H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 652  : #if defined(DEBUG) | defined(_DEBUG)
; 653  :     TCHAR strBuffer[512];
; 654  :     
; 655  :     va_list args;
; 656  :     va_start(args, strMsg);

	lea	eax, DWORD PTR _strMsg$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 657  :     _vsntprintf( strBuffer, 512, strMsg, args );

	mov	eax, DWORD PTR _args$[ebp]
	push	eax
	mov	ecx, DWORD PTR _strMsg$[ebp]
	push	ecx
	push	512					; 00000200H
	lea	edx, DWORD PTR _strBuffer$[ebp]
	push	edx
	call	__vsnprintf
	add	esp, 16					; 00000010H

; 658  :     va_end(args);

	mov	DWORD PTR _args$[ebp], 0

; 659  : 
; 660  :     OutputDebugString( strBuffer );

	mov	esi, esp
	lea	eax, DWORD PTR _strBuffer$[ebp]
	push	eax
	call	DWORD PTR __imp__OutputDebugStringA@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 661  : #else
; 662  :     UNREFERENCED_PARAMETER(strMsg);
; 663  : #endif
; 664  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@DXUtil_Tra
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 728				; 000002d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN5@DXUtil_Tra:
	DD	1
	DD	$LN4@DXUtil_Tra
$LN4@DXUtil_Tra:
	DD	-520					; fffffdf8H
	DD	512					; 00000200H
	DD	$LN3@DXUtil_Tra
$LN3@DXUtil_Tra:
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
?DXUtil_Trace@@YAXPADZZ ENDP				; DXUtil_Trace
_TEXT	ENDS
PUBLIC	??_C@_0CI@FDANOHPD@?$HL?$CF8X?9?$CF4X?9?$CF4X?9?$CF2X?$CF2X?9?$CF2X?$CF2X?$CF2X?$CF2X@ ; `string'
PUBLIC	?DXUtil_ConvertStringToGUID@@YAHPBDPAU_GUID@@@Z	; DXUtil_ConvertStringToGUID
EXTRN	_memset:PROC
EXTRN	_sscanf:PROC
;	COMDAT ??_C@_0CI@FDANOHPD@?$HL?$CF8X?9?$CF4X?9?$CF4X?9?$CF2X?$CF2X?9?$CF2X?$CF2X?$CF2X?$CF2X@
CONST	SEGMENT
??_C@_0CI@FDANOHPD@?$HL?$CF8X?9?$CF4X?9?$CF4X?9?$CF2X?$CF2X?9?$CF2X?$CF2X?$CF2X?$CF2X@ DB '{'
	DB	'%8X-%4X-%4X-%2X%2X-%2X%2X%2X%2X%2X%2X}', 00H ; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?DXUtil_ConvertStringToGUID@@YAHPBDPAU_GUID@@@Z
_TEXT	SEGMENT
_aiTmp$ = -44						; size = 40
_strIn$ = 8						; size = 4
_pGuidOut$ = 12						; size = 4
?DXUtil_ConvertStringToGUID@@YAHPBDPAU_GUID@@@Z PROC	; DXUtil_ConvertStringToGUID, COMDAT

; 674  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 675  :     UINT aiTmp[10];
; 676  : 
; 677  :     if( _stscanf( strIn, TEXT("{%8X-%4X-%4X-%2X%2X-%2X%2X%2X%2X%2X%2X}"),
; 678  :                     &pGuidOut->Data1, 
; 679  :                     &aiTmp[0], &aiTmp[1], 
; 680  :                     &aiTmp[2], &aiTmp[3],
; 681  :                     &aiTmp[4], &aiTmp[5],
; 682  :                     &aiTmp[6], &aiTmp[7],
; 683  :                     &aiTmp[8], &aiTmp[9] ) != 11 )

	lea	eax, DWORD PTR _aiTmp$[ebp+36]
	push	eax
	lea	ecx, DWORD PTR _aiTmp$[ebp+32]
	push	ecx
	lea	edx, DWORD PTR _aiTmp$[ebp+28]
	push	edx
	lea	eax, DWORD PTR _aiTmp$[ebp+24]
	push	eax
	lea	ecx, DWORD PTR _aiTmp$[ebp+20]
	push	ecx
	lea	edx, DWORD PTR _aiTmp$[ebp+16]
	push	edx
	lea	eax, DWORD PTR _aiTmp$[ebp+12]
	push	eax
	lea	ecx, DWORD PTR _aiTmp$[ebp+8]
	push	ecx
	lea	edx, DWORD PTR _aiTmp$[ebp+4]
	push	edx
	lea	eax, DWORD PTR _aiTmp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pGuidOut$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CI@FDANOHPD@?$HL?$CF8X?9?$CF4X?9?$CF4X?9?$CF2X?$CF2X?9?$CF2X?$CF2X?$CF2X?$CF2X@
	mov	edx, DWORD PTR _strIn$[ebp]
	push	edx
	call	_sscanf
	add	esp, 52					; 00000034H
	cmp	eax, 11					; 0000000bH
	je	SHORT $LN2@DXUtil_Con@7

; 684  :     {
; 685  :         ZeroMemory( pGuidOut, sizeof(GUID) );

	push	16					; 00000010H
	push	0
	mov	eax, DWORD PTR _pGuidOut$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 686  :         return FALSE;

	xor	eax, eax
	jmp	SHORT $LN3@DXUtil_Con@7

; 687  :     }
; 688  :     else

	jmp	SHORT $LN3@DXUtil_Con@7
$LN2@DXUtil_Con@7:

; 689  :     {
; 690  :         pGuidOut->Data2       = (USHORT) aiTmp[0];

	mov	eax, DWORD PTR _pGuidOut$[ebp]
	mov	cx, WORD PTR _aiTmp$[ebp]
	mov	WORD PTR [eax+4], cx

; 691  :         pGuidOut->Data3       = (USHORT) aiTmp[1];

	mov	eax, DWORD PTR _pGuidOut$[ebp]
	mov	cx, WORD PTR _aiTmp$[ebp+4]
	mov	WORD PTR [eax+6], cx

; 692  :         pGuidOut->Data4[0]    = (BYTE) aiTmp[2];

	mov	eax, DWORD PTR _pGuidOut$[ebp]
	mov	cl, BYTE PTR _aiTmp$[ebp+8]
	mov	BYTE PTR [eax+8], cl

; 693  :         pGuidOut->Data4[1]    = (BYTE) aiTmp[3];

	mov	eax, DWORD PTR _pGuidOut$[ebp]
	mov	cl, BYTE PTR _aiTmp$[ebp+12]
	mov	BYTE PTR [eax+9], cl

; 694  :         pGuidOut->Data4[2]    = (BYTE) aiTmp[4];

	mov	eax, DWORD PTR _pGuidOut$[ebp]
	mov	cl, BYTE PTR _aiTmp$[ebp+16]
	mov	BYTE PTR [eax+10], cl

; 695  :         pGuidOut->Data4[3]    = (BYTE) aiTmp[5];

	mov	eax, DWORD PTR _pGuidOut$[ebp]
	mov	cl, BYTE PTR _aiTmp$[ebp+20]
	mov	BYTE PTR [eax+11], cl

; 696  :         pGuidOut->Data4[4]    = (BYTE) aiTmp[6];

	mov	eax, DWORD PTR _pGuidOut$[ebp]
	mov	cl, BYTE PTR _aiTmp$[ebp+24]
	mov	BYTE PTR [eax+12], cl

; 697  :         pGuidOut->Data4[5]    = (BYTE) aiTmp[7];

	mov	eax, DWORD PTR _pGuidOut$[ebp]
	mov	cl, BYTE PTR _aiTmp$[ebp+28]
	mov	BYTE PTR [eax+13], cl

; 698  :         pGuidOut->Data4[6]    = (BYTE) aiTmp[8];

	mov	eax, DWORD PTR _pGuidOut$[ebp]
	mov	cl, BYTE PTR _aiTmp$[ebp+32]
	mov	BYTE PTR [eax+14], cl

; 699  :         pGuidOut->Data4[7]    = (BYTE) aiTmp[9];

	mov	eax, DWORD PTR _pGuidOut$[ebp]
	mov	cl, BYTE PTR _aiTmp$[ebp+36]
	mov	BYTE PTR [eax+15], cl

; 700  :         return TRUE;

	mov	eax, 1
$LN3@DXUtil_Con@7:

; 701  :     }
; 702  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@DXUtil_Con@7
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN7@DXUtil_Con@7:
	DD	1
	DD	$LN6@DXUtil_Con@7
$LN6@DXUtil_Con@7:
	DD	-44					; ffffffd4H
	DD	40					; 00000028H
	DD	$LN5@DXUtil_Con@7
$LN5@DXUtil_Con@7:
	DB	97					; 00000061H
	DB	105					; 00000069H
	DB	84					; 00000054H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
?DXUtil_ConvertStringToGUID@@YAHPBDPAU_GUID@@@Z ENDP	; DXUtil_ConvertStringToGUID
_TEXT	ENDS
PUBLIC	??_C@_0DO@OBIAHMKG@?$HL?$CF0?48X?9?$CF0?44X?9?$CF0?44X?9?$CF0?42X?$CF0?42X?9?$CF0@ ; `string'
PUBLIC	?DXUtil_ConvertGUIDToString@@YAXPBU_GUID@@PAD@Z	; DXUtil_ConvertGUIDToString
;	COMDAT ??_C@_0DO@OBIAHMKG@?$HL?$CF0?48X?9?$CF0?44X?9?$CF0?44X?9?$CF0?42X?$CF0?42X?9?$CF0@
CONST	SEGMENT
??_C@_0DO@OBIAHMKG@?$HL?$CF0?48X?9?$CF0?44X?9?$CF0?44X?9?$CF0?42X?$CF0?42X?9?$CF0@ DB '{'
	DB	'%0.8X-%0.4X-%0.4X-%0.2X%0.2X-%0.2X%0.2X%0.2X%0.2X%0.2X%0.2X}', 00H ; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?DXUtil_ConvertGUIDToString@@YAXPBU_GUID@@PAD@Z
_TEXT	SEGMENT
_pGuidIn$ = 8						; size = 4
_strOut$ = 12						; size = 4
?DXUtil_ConvertGUIDToString@@YAXPBU_GUID@@PAD@Z PROC	; DXUtil_ConvertGUIDToString, COMDAT

; 712  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 713  :     _stprintf( strOut, TEXT("{%0.8X-%0.4X-%0.4X-%0.2X%0.2X-%0.2X%0.2X%0.2X%0.2X%0.2X%0.2X}"),
; 714  :                pGuidIn->Data1, pGuidIn->Data2, pGuidIn->Data3,
; 715  :                pGuidIn->Data4[0], pGuidIn->Data4[1],
; 716  :                pGuidIn->Data4[2], pGuidIn->Data4[3],
; 717  :                pGuidIn->Data4[4], pGuidIn->Data4[5],
; 718  :                pGuidIn->Data4[6], pGuidIn->Data4[7] );

	mov	eax, DWORD PTR _pGuidIn$[ebp]
	movzx	ecx, BYTE PTR [eax+15]
	push	ecx
	mov	edx, DWORD PTR _pGuidIn$[ebp]
	movzx	eax, BYTE PTR [edx+14]
	push	eax
	mov	ecx, DWORD PTR _pGuidIn$[ebp]
	movzx	edx, BYTE PTR [ecx+13]
	push	edx
	mov	eax, DWORD PTR _pGuidIn$[ebp]
	movzx	ecx, BYTE PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _pGuidIn$[ebp]
	movzx	eax, BYTE PTR [edx+11]
	push	eax
	mov	ecx, DWORD PTR _pGuidIn$[ebp]
	movzx	edx, BYTE PTR [ecx+10]
	push	edx
	mov	eax, DWORD PTR _pGuidIn$[ebp]
	movzx	ecx, BYTE PTR [eax+9]
	push	ecx
	mov	edx, DWORD PTR _pGuidIn$[ebp]
	movzx	eax, BYTE PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _pGuidIn$[ebp]
	movzx	edx, WORD PTR [ecx+6]
	push	edx
	mov	eax, DWORD PTR _pGuidIn$[ebp]
	movzx	ecx, WORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _pGuidIn$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	OFFSET ??_C@_0DO@OBIAHMKG@?$HL?$CF0?48X?9?$CF0?44X?9?$CF0?44X?9?$CF0?42X?$CF0?42X?9?$CF0@
	mov	ecx, DWORD PTR _strOut$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 52					; 00000034H

; 719  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUtil_ConvertGUIDToString@@YAXPBU_GUID@@PAD@Z ENDP	; DXUtil_ConvertGUIDToString
_TEXT	ENDS
END
