; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\vice-players-master\Client\scripting\CScripts.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	??0CScripts@@QAE@XZ				; CScripts::CScripts
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??0CTimerPool@@QAE@XZ:PROC			; CTimerPool::CTimerPool
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT xdata$x
; File d:\vice-players-master\client\scripting\cscripts.cpp
xdata$x	SEGMENT
__unwindtable$??0CScripts@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CScripts@@QAE@XZ$0
__ehfuncinfo$??0CScripts@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CScripts@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu /ZI
rtc$IMZ	ENDS
;	COMDAT ??0CScripts@@QAE@XZ
_TEXT	SEGMENT
tv76 = -256						; size = 4
$T209567 = -248						; size = 4
$T209568 = -236						; size = 4
_i$209253 = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0CScripts@@QAE@XZ PROC				; CScripts::CScripts, COMDAT
; _this$ = ecx

; 19   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CScripts@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 20   : 	// reset all script slots
; 21   : 	for(int i = 0; i < MAX_SCRIPTS; i++) {

	mov	DWORD PTR _i$209253[ebp], 0
	jmp	SHORT $LN3@CScripts
$LN2@CScripts:
	mov	eax, DWORD PTR _i$209253[ebp]
	add	eax, 1
	mov	DWORD PTR _i$209253[ebp], eax
$LN3@CScripts:
	cmp	DWORD PTR _i$209253[ebp], 10		; 0000000aH
	jge	SHORT $LN1@CScripts

; 22   : 		m_pScripts[i] = NULL;

	mov	eax, DWORD PTR _i$209253[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4], 0

; 23   : 	}

	jmp	SHORT $LN2@CScripts
$LN1@CScripts:

; 24   : 	m_pTimerPool = new CTimerPool();

	push	400					; 00000190H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T209568[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T209568[ebp], 0
	je	SHORT $LN6@CScripts
	mov	ecx, DWORD PTR $T209568[ebp]
	call	??0CTimerPool@@QAE@XZ			; CTimerPool::CTimerPool
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN7@CScripts
$LN6@CScripts:
	mov	DWORD PTR tv76[ebp], 0
$LN7@CScripts:
	mov	eax, DWORD PTR tv76[ebp]
	mov	DWORD PTR $T209567[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T209567[ebp]
	mov	DWORD PTR [ecx+2600], edx

; 25   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CScripts@@QAE@XZ$0:
	mov	eax, DWORD PTR $T209568[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$??0CScripts@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-260]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CScripts@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CScripts@@QAE@XZ ENDP				; CScripts::CScripts
PUBLIC	??_GCScript@@QAEPAXI@Z				; CScript::`scalar deleting destructor'
PUBLIC	??1CScripts@@QAE@XZ				; CScripts::~CScripts
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1CScripts@@QAE@XZ
_TEXT	SEGMENT
tv75 = -244						; size = 4
$T209594 = -236						; size = 4
$T209595 = -224						; size = 4
_i$209264 = -20						; size = 4
_this$ = -8						; size = 4
??1CScripts@@QAE@XZ PROC				; CScripts::~CScripts, COMDAT
; _this$ = ecx

; 28   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 29   : 	for(int i = 0; i < MAX_SCRIPTS; i++) {

	mov	DWORD PTR _i$209264[ebp], 0
	jmp	SHORT $LN4@CScripts@2
$LN3@CScripts@2:
	mov	eax, DWORD PTR _i$209264[ebp]
	add	eax, 1
	mov	DWORD PTR _i$209264[ebp], eax
$LN4@CScripts@2:
	cmp	DWORD PTR _i$209264[ebp], 10		; 0000000aH
	jge	SHORT $LN5@CScripts@2

; 30   : 		if(m_pScripts[i] != NULL) delete m_pScripts[i];

	mov	eax, DWORD PTR _i$209264[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	je	SHORT $LN1@CScripts@2
	mov	eax, DWORD PTR _i$209264[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T209595[ebp], edx
	mov	eax, DWORD PTR $T209595[ebp]
	mov	DWORD PTR $T209594[ebp], eax
	cmp	DWORD PTR $T209594[ebp], 0
	je	SHORT $LN7@CScripts@2
	push	1
	mov	ecx, DWORD PTR $T209594[ebp]
	call	??_GCScript@@QAEPAXI@Z
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN1@CScripts@2
$LN7@CScripts@2:
	mov	DWORD PTR tv75[ebp], 0
$LN1@CScripts@2:

; 31   : 		m_pScripts[i] = NULL;

	mov	eax, DWORD PTR _i$209264[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4], 0
	jmp	SHORT $LN3@CScripts@2
$LN5@CScripts@2:

; 32   : 	}
; 33   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1CScripts@@QAE@XZ ENDP				; CScripts::~CScripts
_TEXT	ENDS
EXTRN	??1CScript@@QAE@XZ:PROC				; CScript::~CScript
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_GCScript@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_GCScript@@QAEPAXI@Z PROC				; CScript::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CScript@@QAE@XZ			; CScript::~CScript
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCScript@@QAEPAXI@Z ENDP				; CScript::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?GetScriptName@CScript@@QAEPADXZ		; CScript::GetScriptName
PUBLIC	?LoadScript@CScripts@@QAEHPBD@Z			; CScripts::LoadScript
EXTRN	??0CScript@@QAE@PBD@Z:PROC			; CScript::CScript
EXTRN	_strcmp:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?LoadScript@CScripts@@QAEHPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadScript@CScripts@@QAEHPBD@Z$0
__ehfuncinfo$?LoadScript@CScripts@@QAEHPBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?LoadScript@CScripts@@QAEHPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCsu /ZI
xdata$x	ENDS
;	COMDAT ?LoadScript@CScripts@@QAEHPBD@Z
_TEXT	SEGMENT
tv128 = -280						; size = 4
$T209602 = -272						; size = 4
$T209603 = -260						; size = 4
_i$209286 = -56						; size = 4
_iSlot$ = -44						; size = 4
_i$209279 = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
_szScriptName$ = 8					; size = 4
?LoadScript@CScripts@@QAEHPBD@Z PROC			; CScripts::LoadScript, COMDAT
; _this$ = ecx

; 36   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LoadScript@CScripts@@QAEHPBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 268				; 0000010cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-280]
	mov	ecx, 67					; 00000043H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 37   : 	// make sure a script with the same name isn't already loaded
; 38   : 	for(int i = 0; i < MAX_SCRIPTS; i++) {

	mov	DWORD PTR _i$209279[ebp], 0
	jmp	SHORT $LN11@LoadScript
$LN10@LoadScript:
	mov	eax, DWORD PTR _i$209279[ebp]
	add	eax, 1
	mov	DWORD PTR _i$209279[ebp], eax
$LN11@LoadScript:
	cmp	DWORD PTR _i$209279[ebp], 10		; 0000000aH
	jge	SHORT $LN9@LoadScript

; 39   : 		if(!m_pScripts[i]) continue;

	mov	eax, DWORD PTR _i$209279[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	jne	SHORT $LN8@LoadScript
	jmp	SHORT $LN10@LoadScript
$LN8@LoadScript:

; 40   : 		if(!strcmp(m_pScripts[i]->GetScriptName(), szScriptName)) {

	mov	eax, DWORD PTR _szScriptName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$209279[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4]
	call	?GetScriptName@CScript@@QAEPADXZ	; CScript::GetScriptName
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN7@LoadScript

; 41   : 			// a script with the same name already exists
; 42   : 			return false;

	xor	eax, eax
	jmp	$LN12@LoadScript
$LN7@LoadScript:

; 43   : 		}
; 44   : 	}

	jmp	SHORT $LN10@LoadScript
$LN9@LoadScript:

; 45   : 
; 46   : 	// find a free script slot
; 47   : 	int iSlot = -1;

	mov	DWORD PTR _iSlot$[ebp], -1

; 48   : 
; 49   : 	for(int i = 0; i < MAX_SCRIPTS; i++) {

	mov	DWORD PTR _i$209286[ebp], 0
	jmp	SHORT $LN6@LoadScript
$LN5@LoadScript:
	mov	eax, DWORD PTR _i$209286[ebp]
	add	eax, 1
	mov	DWORD PTR _i$209286[ebp], eax
$LN6@LoadScript:
	cmp	DWORD PTR _i$209286[ebp], 10		; 0000000aH
	jge	SHORT $LN4@LoadScript

; 50   : 		if(!m_pScripts[i]) {

	mov	eax, DWORD PTR _i$209286[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	jne	SHORT $LN3@LoadScript

; 51   : 			// found a free slot
; 52   : 			iSlot = i;

	mov	eax, DWORD PTR _i$209286[ebp]
	mov	DWORD PTR _iSlot$[ebp], eax

; 53   : 			break;

	jmp	SHORT $LN4@LoadScript
$LN3@LoadScript:

; 54   : 		}
; 55   : 	}

	jmp	SHORT $LN5@LoadScript
$LN4@LoadScript:

; 56   : 
; 57   : 	if(iSlot == -1) {

	cmp	DWORD PTR _iSlot$[ebp], -1
	jne	SHORT $LN2@LoadScript

; 58   : 		// no free script slot found
; 59   : 		return false;

	xor	eax, eax
	jmp	SHORT $LN12@LoadScript
$LN2@LoadScript:

; 60   : 	}
; 61   : 
; 62   : 	if(m_pScripts[iSlot] == NULL)

	mov	eax, DWORD PTR _iSlot$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	jne	SHORT $LN1@LoadScript

; 63   : 	{
; 64   : 		m_pScripts[iSlot] = new CScript(szScriptName);

	push	772					; 00000304H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T209603[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T209603[ebp], 0
	je	SHORT $LN14@LoadScript
	mov	eax, DWORD PTR _szScriptName$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T209603[ebp]
	call	??0CScript@@QAE@PBD@Z			; CScript::CScript
	mov	DWORD PTR tv128[ebp], eax
	jmp	SHORT $LN15@LoadScript
$LN14@LoadScript:
	mov	DWORD PTR tv128[ebp], 0
$LN15@LoadScript:
	mov	ecx, DWORD PTR tv128[ebp]
	mov	DWORD PTR $T209602[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _iSlot$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T209602[ebp]
	mov	DWORD PTR [eax+edx*4], ecx
$LN1@LoadScript:

; 65   : 	}
; 66   : 	// script loaded successfully
; 67   : 	return iSlot;

	mov	eax, DWORD PTR _iSlot$[ebp]
$LN12@LoadScript:

; 68   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 280				; 00000118H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LoadScript@CScripts@@QAEHPBD@Z$0:
	mov	eax, DWORD PTR $T209603[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?LoadScript@CScripts@@QAEHPBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-284]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LoadScript@CScripts@@QAEHPBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LoadScript@CScripts@@QAEHPBD@Z ENDP			; CScripts::LoadScript
PUBLIC	?UnloadScript@CScripts@@QAE_NPBD@Z		; CScripts::UnloadScript
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?UnloadScript@CScripts@@QAE_NPBD@Z
_TEXT	SEGMENT
tv80 = -244						; size = 4
$T209615 = -236						; size = 4
$T209616 = -224						; size = 4
_i$209301 = -20						; size = 4
_this$ = -8						; size = 4
_szScriptName$ = 8					; size = 4
?UnloadScript@CScripts@@QAE_NPBD@Z PROC			; CScripts::UnloadScript, COMDAT
; _this$ = ecx

; 71   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 72   : 	// find the script slot
; 73   : 	for(int i = 0; i < MAX_SCRIPTS; i++) {

	mov	DWORD PTR _i$209301[ebp], 0
	jmp	SHORT $LN4@UnloadScri
$LN3@UnloadScri:
	mov	eax, DWORD PTR _i$209301[ebp]
	add	eax, 1
	mov	DWORD PTR _i$209301[ebp], eax
$LN4@UnloadScri:
	cmp	DWORD PTR _i$209301[ebp], 10		; 0000000aH
	jge	SHORT $LN2@UnloadScri

; 74   : 		if(!strcmp(m_pScripts[i]->GetScriptName(), szScriptName)) {

	mov	eax, DWORD PTR _szScriptName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$209301[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4]
	call	?GetScriptName@CScript@@QAEPADXZ	; CScript::GetScriptName
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN1@UnloadScri

; 75   : 			// found the script slot, unload the script
; 76   : 
; 77   : 			delete m_pScripts[i];

	mov	eax, DWORD PTR _i$209301[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T209616[ebp], edx
	mov	eax, DWORD PTR $T209616[ebp]
	mov	DWORD PTR $T209615[ebp], eax
	cmp	DWORD PTR $T209615[ebp], 0
	je	SHORT $LN7@UnloadScri
	push	1
	mov	ecx, DWORD PTR $T209615[ebp]
	call	??_GCScript@@QAEPAXI@Z
	mov	DWORD PTR tv80[ebp], eax
	jmp	SHORT $LN8@UnloadScri
$LN7@UnloadScri:
	mov	DWORD PTR tv80[ebp], 0
$LN8@UnloadScri:

; 78   : 
; 79   : 			m_pScripts[i] = NULL;

	mov	eax, DWORD PTR _i$209301[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4], 0

; 80   : 			// script unloaded successfully
; 81   : 			return true;

	mov	al, 1
	jmp	SHORT $LN5@UnloadScri
$LN1@UnloadScri:

; 82   : 		}
; 83   : 	}

	jmp	$LN3@UnloadScri
$LN2@UnloadScri:

; 84   : 
; 85   : 	// script not found
; 86   : 	return false;

	xor	al, al
$LN5@UnloadScri:

; 87   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?UnloadScript@CScripts@@QAE_NPBD@Z ENDP			; CScripts::UnloadScript
_TEXT	ENDS
PUBLIC	?GetVM@CScript@@QAEPAUSQVM@@XZ			; CScript::GetVM
PUBLIC	?Call@CScripts@@QAEXPBDHPAUSQObjectPtr@@@Z	; CScripts::Call
EXTRN	_sq_settop:PROC
EXTRN	_sq_call:PROC
EXTRN	_sq_pushobject:PROC
EXTRN	_sq_get:PROC
EXTRN	_sq_pushstring:PROC
EXTRN	_sq_pushroottable:PROC
EXTRN	_sq_gettop:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?Call@CScripts@@QAEXPBDHPAUSQObjectPtr@@@Z
_TEXT	SEGMENT
$T209621 = -264						; size = 8
_j$209323 = -56						; size = 4
_iTop$209320 = -44					; size = 4
_pVM$209319 = -32					; size = 4
_i$209314 = -20						; size = 4
_this$ = -8						; size = 4
_szFunc$ = 8						; size = 4
_iArgCount$ = 12					; size = 4
_pArguments$ = 16					; size = 4
?Call@CScripts@@QAEXPBDHPAUSQObjectPtr@@@Z PROC		; CScripts::Call, COMDAT
; _this$ = ecx

; 90   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 268				; 0000010cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-268]
	mov	ecx, 67					; 00000043H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 91   : 	for(int i = 0; i < MAX_SCRIPTS; i++) {

	mov	DWORD PTR _i$209314[ebp], 0
	jmp	SHORT $LN9@Call
$LN8@Call:
	mov	eax, DWORD PTR _i$209314[ebp]
	add	eax, 1
	mov	DWORD PTR _i$209314[ebp], eax
$LN9@Call:
	cmp	DWORD PTR _i$209314[ebp], 10		; 0000000aH
	jge	$LN10@Call

; 92   : 		if(m_pScripts[i]) {

	mov	eax, DWORD PTR _i$209314[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	je	$LN6@Call

; 93   : 			// get the script vm pointer
; 94   : 			SQVM * pVM = m_pScripts[i]->GetVM();

	mov	eax, DWORD PTR _i$209314[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]
	call	?GetVM@CScript@@QAEPAUSQVM@@XZ		; CScript::GetVM
	mov	DWORD PTR _pVM$209319[ebp], eax

; 95   : 
; 96   : 			// Get the stack top
; 97   : 			int iTop = sq_gettop(pVM);

	mov	eax, DWORD PTR _pVM$209319[ebp]
	push	eax
	call	_sq_gettop
	add	esp, 4
	mov	DWORD PTR _iTop$209320[ebp], eax

; 98   : 
; 99   : 			// Push the root table onto the stack
; 100  : 			sq_pushroottable(pVM);

	mov	eax, DWORD PTR _pVM$209319[ebp]
	push	eax
	call	_sq_pushroottable
	add	esp, 4

; 101  : 
; 102  : 			// Push the function name onto the stack
; 103  : 			sq_pushstring(pVM, szFunc, -1);

	push	-1
	mov	eax, DWORD PTR _szFunc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pVM$209319[ebp]
	push	ecx
	call	_sq_pushstring
	add	esp, 12					; 0000000cH

; 104  : 
; 105  : 			if(SQ_SUCCEEDED(sq_get(pVM, -2))) {

	push	-2					; fffffffeH
	mov	eax, DWORD PTR _pVM$209319[ebp]
	push	eax
	call	_sq_get
	add	esp, 8
	test	eax, eax
	jl	SHORT $LN5@Call

; 106  : 				// Push the root table onto the stack
; 107  : 				sq_pushroottable(pVM);

	mov	eax, DWORD PTR _pVM$209319[ebp]
	push	eax
	call	_sq_pushroottable
	add	esp, 4

; 108  : 
; 109  : 				if(pArguments != NULL)

	cmp	DWORD PTR _pArguments$[ebp], 0
	je	SHORT $LN4@Call

; 110  : 				{
; 111  : 					for(int j = 0; j < iArgCount; ++j)

	mov	DWORD PTR _j$209323[ebp], 0
	jmp	SHORT $LN3@Call
$LN2@Call:
	mov	eax, DWORD PTR _j$209323[ebp]
	add	eax, 1
	mov	DWORD PTR _j$209323[ebp], eax
$LN3@Call:
	mov	eax, DWORD PTR _j$209323[ebp]
	cmp	eax, DWORD PTR _iArgCount$[ebp]
	jge	SHORT $LN4@Call

; 112  : 						sq_pushobject(pVM, pArguments[j]);

	mov	eax, DWORD PTR _j$209323[ebp]
	mov	ecx, DWORD PTR _pArguments$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8]
	mov	eax, DWORD PTR [ecx+eax*8+4]
	mov	DWORD PTR $T209621[ebp], edx
	mov	DWORD PTR $T209621[ebp+4], eax
	mov	ecx, DWORD PTR $T209621[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T209621[ebp]
	push	edx
	mov	eax, DWORD PTR _pVM$209319[ebp]
	push	eax
	call	_sq_pushobject
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN2@Call
$LN4@Call:

; 113  : 						//pVM->Push(pArguments[j]);
; 114  : 				}
; 115  : 				sq_call(pVM, iArgCount + 1, true, true);

	push	1
	push	1
	mov	eax, DWORD PTR _iArgCount$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _pVM$209319[ebp]
	push	ecx
	call	_sq_call
	add	esp, 16					; 00000010H
$LN5@Call:

; 116  : 
; 117  : 			}
; 118  : 
; 119  : 			// Restore the stack top
; 120  : 			sq_settop(pVM, iTop);

	mov	eax, DWORD PTR _iTop$209320[ebp]
	push	eax
	mov	ecx, DWORD PTR _pVM$209319[ebp]
	push	ecx
	call	_sq_settop
	add	esp, 8
$LN6@Call:

; 121  : 		}

	jmp	$LN8@Call
$LN10@Call:

; 122  : 	}
; 123  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 268				; 0000010cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?Call@CScripts@@QAEXPBDHPAUSQObjectPtr@@@Z ENDP		; CScripts::Call
_TEXT	ENDS
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$Read@_N@BitStream@RakNet@@QAE_NAA_N@Z	; RakNet::BitStream::Read<bool>
PUBLIC	??$Read@M@BitStream@RakNet@@QAE_NAAM@Z		; RakNet::BitStream::Read<float>
PUBLIC	??$Read@H@BitStream@RakNet@@QAE_NAAH@Z		; RakNet::BitStream::Read<int>
PUBLIC	__$ArrayPad$
PUBLIC	?Call@CScripts@@QAEXPAVBitStream@RakNet@@@Z	; CScripts::Call
EXTRN	?ResetReadPointer@BitStream@RakNet@@QAEXXZ:PROC	; RakNet::BitStream::ResetReadPointer
EXTRN	_sq_pushbool:PROC
EXTRN	_sq_pushfloat:PROC
EXTRN	_sq_pushinteger:PROC
EXTRN	?Read@BitStream@RakNet@@QAE_NPADI@Z:PROC	; RakNet::BitStream::Read
EXTRN	__fltused:DWORD
EXTRN	@_RTC_CheckStackVars@8:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Call@CScripts@@QAEXPAVBitStream@RakNet@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Call@CScripts@@QAEXPAVBitStream@RakNet@@@Z$0
__ehfuncinfo$?Call@CScripts@@QAEXPAVBitStream@RakNet@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Call@CScripts@@QAEXPAVBitStream@RakNet@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCsu /ZI
xdata$x	ENDS
;	COMDAT ?Call@CScripts@@QAEXPAVBitStream@RakNet@@@Z
_TEXT	SEGMENT
_str$209367 = -724					; size = 32
_szStr$209366 = -684					; size = 256
_len$209365 = -420					; size = 4
_val$209362 = -405					; size = 1
_val$209356 = -396					; size = 4
_val$209353 = -384					; size = 4
_type$209351 = -372					; size = 4
_j$209347 = -360					; size = 4
_iTop$209344 = -348					; size = 4
_pVM$209343 = -336					; size = 4
_szFunc$209339 = -324					; size = 256
_funcLen$209338 = -60					; size = 4
_iArgCount$209337 = -48					; size = 4
_i$209332 = -36						; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_bitStream$ = 8						; size = 4
?Call@CScripts@@QAEXPAVBitStream@RakNet@@@Z PROC	; CScripts::Call, COMDAT
; _this$ = ecx

; 126  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Call@CScripts@@QAEXPAVBitStream@RakNet@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 908				; 0000038cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-920]
	mov	ecx, 227				; 000000e3H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 127  : 	for(int i = 0; i < MAX_SCRIPTS; i++) {

	mov	DWORD PTR _i$209332[ebp], 0
	jmp	SHORT $LN16@Call@2
$LN15@Call@2:
	mov	eax, DWORD PTR _i$209332[ebp]
	add	eax, 1
	mov	DWORD PTR _i$209332[ebp], eax
$LN16@Call@2:
	cmp	DWORD PTR _i$209332[ebp], 10		; 0000000aH
	jge	$LN14@Call@2

; 128  : 		if(m_pScripts[i]) {

	mov	eax, DWORD PTR _i$209332[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	je	$LN13@Call@2

; 129  : 
; 130  : 			int iArgCount = 0;

	mov	DWORD PTR _iArgCount$209337[ebp], 0

; 131  : 			int funcLen = 0;

	mov	DWORD PTR _funcLen$209338[ebp], 0

; 132  : 			CHAR szFunc[256];
; 133  : 			bitStream->Read(funcLen);

	lea	eax, DWORD PTR _funcLen$209338[ebp]
	push	eax
	mov	ecx, DWORD PTR _bitStream$[ebp]
	call	??$Read@H@BitStream@RakNet@@QAE_NAAH@Z	; RakNet::BitStream::Read<int>

; 134  : 			bitStream->Read(iArgCount);

	lea	eax, DWORD PTR _iArgCount$209337[ebp]
	push	eax
	mov	ecx, DWORD PTR _bitStream$[ebp]
	call	??$Read@H@BitStream@RakNet@@QAE_NAAH@Z	; RakNet::BitStream::Read<int>

; 135  : 			bitStream->Read(szFunc, funcLen);

	mov	eax, DWORD PTR _funcLen$209338[ebp]
	push	eax
	lea	ecx, DWORD PTR _szFunc$209339[ebp]
	push	ecx
	mov	ecx, DWORD PTR _bitStream$[ebp]
	call	?Read@BitStream@RakNet@@QAE_NPADI@Z	; RakNet::BitStream::Read

; 136  : 			szFunc[funcLen] = '\0';

	mov	eax, DWORD PTR _funcLen$209338[ebp]
	mov	BYTE PTR _szFunc$209339[ebp+eax], 0

; 137  : 
; 138  : 			// get the script vm pointer
; 139  : 			SQVM * pVM = m_pScripts[i]->GetVM();

	mov	eax, DWORD PTR _i$209332[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]
	call	?GetVM@CScript@@QAEPAUSQVM@@XZ		; CScript::GetVM
	mov	DWORD PTR _pVM$209343[ebp], eax

; 140  : 
; 141  : 			// Get the stack top
; 142  : 			int iTop = sq_gettop(pVM);

	mov	eax, DWORD PTR _pVM$209343[ebp]
	push	eax
	call	_sq_gettop
	add	esp, 4
	mov	DWORD PTR _iTop$209344[ebp], eax

; 143  : 
; 144  : 			// Push the root table onto the stack
; 145  : 			sq_pushroottable(pVM);

	mov	eax, DWORD PTR _pVM$209343[ebp]
	push	eax
	call	_sq_pushroottable
	add	esp, 4

; 146  : 
; 147  : 			// Push the function name onto the stack
; 148  : 			sq_pushstring(pVM, szFunc, -1);

	push	-1
	lea	eax, DWORD PTR _szFunc$209339[ebp]
	push	eax
	mov	ecx, DWORD PTR _pVM$209343[ebp]
	push	ecx
	call	_sq_pushstring
	add	esp, 12					; 0000000cH

; 149  : 
; 150  : 			if(SQ_SUCCEEDED(sq_get(pVM, -2)))

	push	-2					; fffffffeH
	mov	eax, DWORD PTR _pVM$209343[ebp]
	push	eax
	call	_sq_get
	add	esp, 8
	test	eax, eax
	jl	$LN12@Call@2

; 151  : 			{
; 152  : 				// Push the root table onto the stack
; 153  : 				sq_pushroottable(pVM);

	mov	eax, DWORD PTR _pVM$209343[ebp]
	push	eax
	call	_sq_pushroottable
	add	esp, 4

; 154  : 
; 155  : 				if(iArgCount > 0)

	cmp	DWORD PTR _iArgCount$209337[ebp], 0
	jle	$LN8@Call@2

; 156  : 				{
; 157  : 					for(int j = 0; i < iArgCount; i++)

	mov	DWORD PTR _j$209347[ebp], 0
	jmp	SHORT $LN10@Call@2
$LN9@Call@2:
	mov	eax, DWORD PTR _i$209332[ebp]
	add	eax, 1
	mov	DWORD PTR _i$209332[ebp], eax
$LN10@Call@2:
	mov	eax, DWORD PTR _i$209332[ebp]
	cmp	eax, DWORD PTR _iArgCount$209337[ebp]
	jge	$LN8@Call@2

; 158  : 					{
; 159  : 						int type;
; 160  : 						bitStream->Read(type);

	lea	eax, DWORD PTR _type$209351[ebp]
	push	eax
	mov	ecx, DWORD PTR _bitStream$[ebp]
	call	??$Read@H@BitStream@RakNet@@QAE_NAAH@Z	; RakNet::BitStream::Read<int>

; 161  : 						if(type == OT_INTEGER)

	cmp	DWORD PTR _type$209351[ebp], 83886082	; 05000002H
	jne	SHORT $LN7@Call@2

; 162  : 						{
; 163  : 							int val;
; 164  : 							bitStream->Read(val);

	lea	eax, DWORD PTR _val$209353[ebp]
	push	eax
	mov	ecx, DWORD PTR _bitStream$[ebp]
	call	??$Read@H@BitStream@RakNet@@QAE_NAAH@Z	; RakNet::BitStream::Read<int>

; 165  : 							sq_pushinteger(pVM, val);

	mov	eax, DWORD PTR _val$209353[ebp]
	push	eax
	mov	ecx, DWORD PTR _pVM$209343[ebp]
	push	ecx
	call	_sq_pushinteger
	add	esp, 8
	jmp	$LN1@Call@2
$LN7@Call@2:

; 166  : 						}
; 167  : 						else if(type == OT_FLOAT)

	cmp	DWORD PTR _type$209351[ebp], 83886084	; 05000004H
	jne	SHORT $LN5@Call@2

; 168  : 						{
; 169  : 							float val;
; 170  : 							bitStream->Read(val);

	lea	eax, DWORD PTR _val$209356[ebp]
	push	eax
	mov	ecx, DWORD PTR _bitStream$[ebp]
	call	??$Read@M@BitStream@RakNet@@QAE_NAAM@Z	; RakNet::BitStream::Read<float>

; 171  : 							sq_pushfloat(pVM, val);

	push	ecx
	fld	DWORD PTR _val$209356[ebp]
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _pVM$209343[ebp]
	push	eax
	call	_sq_pushfloat
	add	esp, 8
	jmp	$LN1@Call@2
$LN5@Call@2:

; 172  : 						}
; 173  : 						else if(type == OT_BOOL)

	cmp	DWORD PTR _type$209351[ebp], 16777224	; 01000008H
	jne	SHORT $LN3@Call@2

; 174  : 						{
; 175  : 							bool val;
; 176  : 							bitStream->Read(val);

	lea	eax, DWORD PTR _val$209362[ebp]
	push	eax
	mov	ecx, DWORD PTR _bitStream$[ebp]
	call	??$Read@_N@BitStream@RakNet@@QAE_NAA_N@Z ; RakNet::BitStream::Read<bool>

; 177  : 							sq_pushbool(pVM, val);

	movzx	eax, BYTE PTR _val$209362[ebp]
	push	eax
	mov	ecx, DWORD PTR _pVM$209343[ebp]
	push	ecx
	call	_sq_pushbool
	add	esp, 8
	jmp	$LN1@Call@2
$LN3@Call@2:

; 178  : 						}
; 179  : 						else if(type == OT_STRING)

	cmp	DWORD PTR _type$209351[ebp], 134217744	; 08000010H
	jne	SHORT $LN1@Call@2

; 180  : 						{
; 181  : 							int len;
; 182  : 							bitStream->Read(len);

	lea	eax, DWORD PTR _len$209365[ebp]
	push	eax
	mov	ecx, DWORD PTR _bitStream$[ebp]
	call	??$Read@H@BitStream@RakNet@@QAE_NAAH@Z	; RakNet::BitStream::Read<int>

; 183  : 							CHAR szStr[256];
; 184  : 							bitStream->Read(szStr, len);

	mov	eax, DWORD PTR _len$209365[ebp]
	push	eax
	lea	ecx, DWORD PTR _szStr$209366[ebp]
	push	ecx
	mov	ecx, DWORD PTR _bitStream$[ebp]
	call	?Read@BitStream@RakNet@@QAE_NPADI@Z	; RakNet::BitStream::Read

; 185  : 							szStr[len] = '\0';

	mov	eax, DWORD PTR _len$209365[ebp]
	mov	BYTE PTR _szStr$209366[ebp+eax], 0

; 186  : 							std::string str = szStr;

	lea	eax, DWORD PTR _szStr$209366[ebp]
	push	eax
	lea	ecx, DWORD PTR _str$209367[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 187  : 							sq_pushstring(pVM, str.c_str(), -1);

	push	-1
	lea	ecx, DWORD PTR _str$209367[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	mov	eax, DWORD PTR _pVM$209343[ebp]
	push	eax
	call	_sq_pushstring
	add	esp, 12					; 0000000cH

; 188  : 						}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _str$209367[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN1@Call@2:

; 189  : 					}

	jmp	$LN9@Call@2
$LN8@Call@2:

; 190  : 				}
; 191  : 				sq_call(pVM, iArgCount + 1, true, true);

	push	1
	push	1
	mov	eax, DWORD PTR _iArgCount$209337[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _pVM$209343[ebp]
	push	ecx
	call	_sq_call
	add	esp, 16					; 00000010H
$LN12@Call@2:

; 192  : 			}
; 193  : 			// Restore the stack top
; 194  : 			sq_settop(pVM, iTop);

	mov	eax, DWORD PTR _iTop$209344[ebp]
	push	eax
	mov	ecx, DWORD PTR _pVM$209343[ebp]
	push	ecx
	call	_sq_settop
	add	esp, 8

; 195  : 			bitStream->ResetReadPointer();

	mov	ecx, DWORD PTR _bitStream$[ebp]
	call	?ResetReadPointer@BitStream@RakNet@@QAEXXZ ; RakNet::BitStream::ResetReadPointer
$LN13@Call@2:

; 196  : 		}

	jmp	$LN15@Call@2
$LN14@Call@2:

; 197  : 	}
; 198  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN32@Call@2
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 920				; 00000398H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN32@Call@2:
	DD	10					; 0000000aH
	DD	$LN31@Call@2
$LN31@Call@2:
	DD	-48					; ffffffd0H
	DD	4
	DD	$LN20@Call@2
	DD	-60					; ffffffc4H
	DD	4
	DD	$LN21@Call@2
	DD	-324					; fffffebcH
	DD	256					; 00000100H
	DD	$LN22@Call@2
	DD	-372					; fffffe8cH
	DD	4
	DD	$LN23@Call@2
	DD	-384					; fffffe80H
	DD	4
	DD	$LN24@Call@2
	DD	-396					; fffffe74H
	DD	4
	DD	$LN25@Call@2
	DD	-405					; fffffe6bH
	DD	1
	DD	$LN26@Call@2
	DD	-420					; fffffe5cH
	DD	4
	DD	$LN27@Call@2
	DD	-684					; fffffd54H
	DD	256					; 00000100H
	DD	$LN28@Call@2
	DD	-724					; fffffd2cH
	DD	32					; 00000020H
	DD	$LN29@Call@2
$LN29@Call@2:
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$LN28@Call@2:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$LN27@Call@2:
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
$LN26@Call@2:
	DB	118					; 00000076H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	0
$LN25@Call@2:
	DB	118					; 00000076H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	0
$LN24@Call@2:
	DB	118					; 00000076H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	0
$LN23@Call@2:
	DB	116					; 00000074H
	DB	121					; 00000079H
	DB	112					; 00000070H
	DB	101					; 00000065H
	DB	0
$LN22@Call@2:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	70					; 00000046H
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	0
$LN21@Call@2:
	DB	102					; 00000066H
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	76					; 0000004cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
$LN20@Call@2:
	DB	105					; 00000069H
	DB	65					; 00000041H
	DB	114					; 00000072H
	DB	103					; 00000067H
	DB	67					; 00000043H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Call@CScripts@@QAEXPAVBitStream@RakNet@@@Z$0:
	lea	ecx, DWORD PTR _str$209367[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?Call@CScripts@@QAEXPAVBitStream@RakNet@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-924]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Call@CScripts@@QAEXPAVBitStream@RakNet@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Call@CScripts@@QAEXPAVBitStream@RakNet@@@Z ENDP	; CScripts::Call
PUBLIC	??_C@_06KPNMIEPC@onInit?$AA@			; `string'
PUBLIC	?onInit@CScripts@@QAEXH@Z			; CScripts::onInit
;	COMDAT ??_C@_06KPNMIEPC@onInit?$AA@
CONST	SEGMENT
??_C@_06KPNMIEPC@onInit?$AA@ DB 'onInit', 00H		; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?onInit@CScripts@@QAEXH@Z
_TEXT	SEGMENT
_iTop$209374 = -32					; size = 4
_pVM$209373 = -20					; size = 4
_this$ = -8						; size = 4
_iScript$ = 8						; size = 4
?onInit@CScripts@@QAEXH@Z PROC				; CScripts::onInit, COMDAT
; _this$ = ecx

; 201  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 202  : 		if(m_pScripts[iScript]) {

	mov	eax, DWORD PTR _iScript$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	je	SHORT $LN3@onInit

; 203  : 			// get the script vm pointer
; 204  : 			SQVM * pVM = m_pScripts[iScript]->GetVM();

	mov	eax, DWORD PTR _iScript$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]
	call	?GetVM@CScript@@QAEPAUSQVM@@XZ		; CScript::GetVM
	mov	DWORD PTR _pVM$209373[ebp], eax

; 205  : 
; 206  : 			// Get the stack top
; 207  : 			int iTop = sq_gettop(pVM);

	mov	eax, DWORD PTR _pVM$209373[ebp]
	push	eax
	call	_sq_gettop
	add	esp, 4
	mov	DWORD PTR _iTop$209374[ebp], eax

; 208  : 
; 209  : 			// Push the root table onto the stack
; 210  : 			sq_pushroottable(pVM);

	mov	eax, DWORD PTR _pVM$209373[ebp]
	push	eax
	call	_sq_pushroottable
	add	esp, 4

; 211  : 
; 212  : 			// Push the function name onto the stack
; 213  : 			sq_pushstring(pVM, "onInit", -1);

	push	-1
	push	OFFSET ??_C@_06KPNMIEPC@onInit?$AA@
	mov	eax, DWORD PTR _pVM$209373[ebp]
	push	eax
	call	_sq_pushstring
	add	esp, 12					; 0000000cH

; 214  : 
; 215  : 			// Get the closure for the function
; 216  : 			if(SQ_SUCCEEDED(sq_get(pVM, -2))) {

	push	-2					; fffffffeH
	mov	eax, DWORD PTR _pVM$209373[ebp]
	push	eax
	call	_sq_get
	add	esp, 8
	test	eax, eax
	jl	SHORT $LN1@onInit

; 217  : 				// Push the root table onto the stack
; 218  : 				sq_pushroottable(pVM);

	mov	eax, DWORD PTR _pVM$209373[ebp]
	push	eax
	call	_sq_pushroottable
	add	esp, 4

; 219  : 
; 220  : 				// Call the function
; 221  : 				sq_call(pVM, 1, true, true);

	push	1
	push	1
	push	1
	mov	eax, DWORD PTR _pVM$209373[ebp]
	push	eax
	call	_sq_call
	add	esp, 16					; 00000010H
$LN1@onInit:

; 222  : 			}
; 223  : 
; 224  : 			// Restore the stack top
; 225  : 			sq_settop(pVM, iTop);

	mov	eax, DWORD PTR _iTop$209374[ebp]
	push	eax
	mov	ecx, DWORD PTR _pVM$209373[ebp]
	push	ecx
	call	_sq_settop
	add	esp, 8
$LN3@onInit:

; 226  : 		}
; 227  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?onInit@CScripts@@QAEXH@Z ENDP				; CScripts::onInit
_TEXT	ENDS
PUBLIC	??_C@_06BPFOGBLA@onExit?$AA@			; `string'
PUBLIC	?onExit@CScripts@@QAEXXZ			; CScripts::onExit
;	COMDAT ??_C@_06BPFOGBLA@onExit?$AA@
CONST	SEGMENT
??_C@_06BPFOGBLA@onExit?$AA@ DB 'onExit', 00H		; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?onExit@CScripts@@QAEXXZ
_TEXT	SEGMENT
_iTop$209386 = -44					; size = 4
_pVM$209385 = -32					; size = 4
_i$209380 = -20						; size = 4
_this$ = -8						; size = 4
?onExit@CScripts@@QAEXXZ PROC				; CScripts::onExit, COMDAT
; _this$ = ecx

; 230  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 231  : 	for(int i = 0; i < MAX_SCRIPTS; i++) {

	mov	DWORD PTR _i$209380[ebp], 0
	jmp	SHORT $LN5@onExit
$LN4@onExit:
	mov	eax, DWORD PTR _i$209380[ebp]
	add	eax, 1
	mov	DWORD PTR _i$209380[ebp], eax
$LN5@onExit:
	cmp	DWORD PTR _i$209380[ebp], 10		; 0000000aH
	jge	$LN6@onExit

; 232  : 		if(m_pScripts[i]) {

	mov	eax, DWORD PTR _i$209380[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	je	SHORT $LN2@onExit

; 233  : 			// get the script vm pointer
; 234  : 			SQVM * pVM = m_pScripts[i]->GetVM();

	mov	eax, DWORD PTR _i$209380[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]
	call	?GetVM@CScript@@QAEPAUSQVM@@XZ		; CScript::GetVM
	mov	DWORD PTR _pVM$209385[ebp], eax

; 235  : 
; 236  : 			// Get the stack top
; 237  : 			int iTop = sq_gettop(pVM);

	mov	eax, DWORD PTR _pVM$209385[ebp]
	push	eax
	call	_sq_gettop
	add	esp, 4
	mov	DWORD PTR _iTop$209386[ebp], eax

; 238  : 
; 239  : 			// Push the root table onto the stack
; 240  : 			sq_pushroottable(pVM);

	mov	eax, DWORD PTR _pVM$209385[ebp]
	push	eax
	call	_sq_pushroottable
	add	esp, 4

; 241  : 
; 242  : 			// Push the function name onto the stack
; 243  : 			sq_pushstring(pVM, "onExit", -1);

	push	-1
	push	OFFSET ??_C@_06BPFOGBLA@onExit?$AA@
	mov	eax, DWORD PTR _pVM$209385[ebp]
	push	eax
	call	_sq_pushstring
	add	esp, 12					; 0000000cH

; 244  : 
; 245  : 			// Get the closure for the function
; 246  : 			if(SQ_SUCCEEDED(sq_get(pVM, -2))) {

	push	-2					; fffffffeH
	mov	eax, DWORD PTR _pVM$209385[ebp]
	push	eax
	call	_sq_get
	add	esp, 8
	test	eax, eax
	jl	SHORT $LN1@onExit

; 247  : 				// Push the root table onto the stack
; 248  : 				sq_pushroottable(pVM);

	mov	eax, DWORD PTR _pVM$209385[ebp]
	push	eax
	call	_sq_pushroottable
	add	esp, 4

; 249  : 
; 250  : 				// Call the function
; 251  : 				sq_call(pVM, 1, true, true);

	push	1
	push	1
	push	1
	mov	eax, DWORD PTR _pVM$209385[ebp]
	push	eax
	call	_sq_call
	add	esp, 16					; 00000010H
$LN1@onExit:

; 252  : 			}
; 253  : 
; 254  : 			// Restore the stack top
; 255  : 			sq_settop(pVM, iTop);

	mov	eax, DWORD PTR _iTop$209386[ebp]
	push	eax
	mov	ecx, DWORD PTR _pVM$209385[ebp]
	push	ecx
	call	_sq_settop
	add	esp, 8
$LN2@onExit:

; 256  : 		}

	jmp	$LN4@onExit
$LN6@onExit:

; 257  : 	}
; 258  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?onExit@CScripts@@QAEXXZ ENDP				; CScripts::onExit
_TEXT	ENDS
PUBLIC	??_C@_07EKOOMDCB@onPulse?$AA@			; `string'
PUBLIC	?onPulse@CScripts@@QAEXXZ			; CScripts::onPulse
;	COMDAT ??_C@_07EKOOMDCB@onPulse?$AA@
CONST	SEGMENT
??_C@_07EKOOMDCB@onPulse?$AA@ DB 'onPulse', 00H		; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?onPulse@CScripts@@QAEXXZ
_TEXT	SEGMENT
_iTop$209398 = -44					; size = 4
_pVM$209397 = -32					; size = 4
_i$209392 = -20						; size = 4
_this$ = -8						; size = 4
?onPulse@CScripts@@QAEXXZ PROC				; CScripts::onPulse, COMDAT
; _this$ = ecx

; 261  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 262  : 	for(int i = 0; i < MAX_SCRIPTS; i++) {

	mov	DWORD PTR _i$209392[ebp], 0
	jmp	SHORT $LN5@onPulse
$LN4@onPulse:
	mov	eax, DWORD PTR _i$209392[ebp]
	add	eax, 1
	mov	DWORD PTR _i$209392[ebp], eax
$LN5@onPulse:
	cmp	DWORD PTR _i$209392[ebp], 10		; 0000000aH
	jge	$LN6@onPulse

; 263  : 		if(m_pScripts[i]) {

	mov	eax, DWORD PTR _i$209392[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	je	SHORT $LN2@onPulse

; 264  : 			// get the script vm pointer
; 265  : 			SQVM * pVM = m_pScripts[i]->GetVM();

	mov	eax, DWORD PTR _i$209392[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]
	call	?GetVM@CScript@@QAEPAUSQVM@@XZ		; CScript::GetVM
	mov	DWORD PTR _pVM$209397[ebp], eax

; 266  : 
; 267  : 			// Get the stack top
; 268  : 			int iTop = sq_gettop(pVM);

	mov	eax, DWORD PTR _pVM$209397[ebp]
	push	eax
	call	_sq_gettop
	add	esp, 4
	mov	DWORD PTR _iTop$209398[ebp], eax

; 269  : 
; 270  : 			// Push the root table onto the stack
; 271  : 			sq_pushroottable(pVM);

	mov	eax, DWORD PTR _pVM$209397[ebp]
	push	eax
	call	_sq_pushroottable
	add	esp, 4

; 272  : 
; 273  : 			// Push the function name onto the stack
; 274  : 			sq_pushstring(pVM, "onPulse", -1);

	push	-1
	push	OFFSET ??_C@_07EKOOMDCB@onPulse?$AA@
	mov	eax, DWORD PTR _pVM$209397[ebp]
	push	eax
	call	_sq_pushstring
	add	esp, 12					; 0000000cH

; 275  : 
; 276  : 			// Get the closure for the function
; 277  : 			if(SQ_SUCCEEDED(sq_get(pVM, -2))) {

	push	-2					; fffffffeH
	mov	eax, DWORD PTR _pVM$209397[ebp]
	push	eax
	call	_sq_get
	add	esp, 8
	test	eax, eax
	jl	SHORT $LN1@onPulse

; 278  : 				// Push the root table onto the stack
; 279  : 				sq_pushroottable(pVM);

	mov	eax, DWORD PTR _pVM$209397[ebp]
	push	eax
	call	_sq_pushroottable
	add	esp, 4

; 280  : 
; 281  : 				// Call the function
; 282  : 				sq_call(pVM, 1, true, true);

	push	1
	push	1
	push	1
	mov	eax, DWORD PTR _pVM$209397[ebp]
	push	eax
	call	_sq_call
	add	esp, 16					; 00000010H
$LN1@onPulse:

; 283  : 			}
; 284  : 
; 285  : 			// Restore the stack top
; 286  : 			sq_settop(pVM, iTop);

	mov	eax, DWORD PTR _iTop$209398[ebp]
	push	eax
	mov	ecx, DWORD PTR _pVM$209397[ebp]
	push	ecx
	call	_sq_settop
	add	esp, 8
$LN2@onPulse:

; 287  : 		}

	jmp	$LN4@onPulse
$LN6@onPulse:

; 288  : 	}
; 289  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?onPulse@CScripts@@QAEXXZ ENDP				; CScripts::onPulse
_TEXT	ENDS
PUBLIC	??_C@_08HCGNMKBN@onRender?$AA@			; `string'
PUBLIC	?onRender@CScripts@@QAEXXZ			; CScripts::onRender
;	COMDAT ??_C@_08HCGNMKBN@onRender?$AA@
CONST	SEGMENT
??_C@_08HCGNMKBN@onRender?$AA@ DB 'onRender', 00H	; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?onRender@CScripts@@QAEXXZ
_TEXT	SEGMENT
_iTop$209410 = -44					; size = 4
_pVM$209409 = -32					; size = 4
_i$209404 = -20						; size = 4
_this$ = -8						; size = 4
?onRender@CScripts@@QAEXXZ PROC				; CScripts::onRender, COMDAT
; _this$ = ecx

; 292  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 293  : 	for(int i = 0; i < MAX_SCRIPTS; i++) {

	mov	DWORD PTR _i$209404[ebp], 0
	jmp	SHORT $LN5@onRender
$LN4@onRender:
	mov	eax, DWORD PTR _i$209404[ebp]
	add	eax, 1
	mov	DWORD PTR _i$209404[ebp], eax
$LN5@onRender:
	cmp	DWORD PTR _i$209404[ebp], 10		; 0000000aH
	jge	$LN6@onRender

; 294  : 		if(m_pScripts[i]) {

	mov	eax, DWORD PTR _i$209404[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	je	SHORT $LN2@onRender

; 295  : 			// get the script vm pointer
; 296  : 			SQVM * pVM = m_pScripts[i]->GetVM();

	mov	eax, DWORD PTR _i$209404[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]
	call	?GetVM@CScript@@QAEPAUSQVM@@XZ		; CScript::GetVM
	mov	DWORD PTR _pVM$209409[ebp], eax

; 297  : 
; 298  : 			// Get the stack top
; 299  : 			int iTop = sq_gettop(pVM);

	mov	eax, DWORD PTR _pVM$209409[ebp]
	push	eax
	call	_sq_gettop
	add	esp, 4
	mov	DWORD PTR _iTop$209410[ebp], eax

; 300  : 
; 301  : 			// Push the root table onto the stack
; 302  : 			sq_pushroottable(pVM);

	mov	eax, DWORD PTR _pVM$209409[ebp]
	push	eax
	call	_sq_pushroottable
	add	esp, 4

; 303  : 
; 304  : 			// Push the function name onto the stack
; 305  : 			sq_pushstring(pVM, "onRender", -1);

	push	-1
	push	OFFSET ??_C@_08HCGNMKBN@onRender?$AA@
	mov	eax, DWORD PTR _pVM$209409[ebp]
	push	eax
	call	_sq_pushstring
	add	esp, 12					; 0000000cH

; 306  : 
; 307  : 			// Get the closure for the function
; 308  : 			if(SQ_SUCCEEDED(sq_get(pVM, -2))) {

	push	-2					; fffffffeH
	mov	eax, DWORD PTR _pVM$209409[ebp]
	push	eax
	call	_sq_get
	add	esp, 8
	test	eax, eax
	jl	SHORT $LN1@onRender

; 309  : 				// Push the root table onto the stack
; 310  : 				sq_pushroottable(pVM);

	mov	eax, DWORD PTR _pVM$209409[ebp]
	push	eax
	call	_sq_pushroottable
	add	esp, 4

; 311  : 
; 312  : 				// Call the function
; 313  : 				sq_call(pVM, 1, true, true);

	push	1
	push	1
	push	1
	mov	eax, DWORD PTR _pVM$209409[ebp]
	push	eax
	call	_sq_call
	add	esp, 16					; 00000010H
$LN1@onRender:

; 314  : 			}
; 315  : 
; 316  : 			// Restore the stack top
; 317  : 			sq_settop(pVM, iTop);

	mov	eax, DWORD PTR _iTop$209410[ebp]
	push	eax
	mov	ecx, DWORD PTR _pVM$209409[ebp]
	push	ecx
	call	_sq_settop
	add	esp, 8
$LN2@onRender:

; 318  : 		}

	jmp	$LN4@onRender
$LN6@onRender:

; 319  : 	}
; 320  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?onRender@CScripts@@QAEXXZ ENDP				; CScripts::onRender
_TEXT	ENDS
PUBLIC	??_C@_0O@GCFHILBK@onTimerCreate?$AA@		; `string'
PUBLIC	?onTimerCreate@CScripts@@QAEXH@Z		; CScripts::onTimerCreate
;	COMDAT ??_C@_0O@GCFHILBK@onTimerCreate?$AA@
CONST	SEGMENT
??_C@_0O@GCFHILBK@onTimerCreate?$AA@ DB 'onTimerCreate', 00H ; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?onTimerCreate@CScripts@@QAEXH@Z
_TEXT	SEGMENT
_iTop$209423 = -44					; size = 4
_pVM$209422 = -32					; size = 4
_i$209417 = -20						; size = 4
_this$ = -8						; size = 4
_timerId$ = 8						; size = 4
?onTimerCreate@CScripts@@QAEXH@Z PROC			; CScripts::onTimerCreate, COMDAT
; _this$ = ecx

; 1059 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1060 : 	for(int i = 0; i < MAX_SCRIPTS; i++) {

	mov	DWORD PTR _i$209417[ebp], 0
	jmp	SHORT $LN5@onTimerCre
$LN4@onTimerCre:
	mov	eax, DWORD PTR _i$209417[ebp]
	add	eax, 1
	mov	DWORD PTR _i$209417[ebp], eax
$LN5@onTimerCre:
	cmp	DWORD PTR _i$209417[ebp], 10		; 0000000aH
	jge	$LN6@onTimerCre

; 1061 : 		if(m_pScripts[i]) {

	mov	eax, DWORD PTR _i$209417[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	je	$LN2@onTimerCre

; 1062 : 			// get the script vm pointer
; 1063 : 			SQVM * pVM = m_pScripts[i]->GetVM();

	mov	eax, DWORD PTR _i$209417[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]
	call	?GetVM@CScript@@QAEPAUSQVM@@XZ		; CScript::GetVM
	mov	DWORD PTR _pVM$209422[ebp], eax

; 1064 : 
; 1065 : 			// Get the stack top
; 1066 : 			int iTop = sq_gettop(pVM);

	mov	eax, DWORD PTR _pVM$209422[ebp]
	push	eax
	call	_sq_gettop
	add	esp, 4
	mov	DWORD PTR _iTop$209423[ebp], eax

; 1067 : 
; 1068 : 			// Push the root table onto the stack
; 1069 : 			sq_pushroottable(pVM);

	mov	eax, DWORD PTR _pVM$209422[ebp]
	push	eax
	call	_sq_pushroottable
	add	esp, 4

; 1070 : 
; 1071 : 			// Push the function name onto the stack
; 1072 : 			sq_pushstring(pVM, "onTimerCreate", -1);

	push	-1
	push	OFFSET ??_C@_0O@GCFHILBK@onTimerCreate?$AA@
	mov	eax, DWORD PTR _pVM$209422[ebp]
	push	eax
	call	_sq_pushstring
	add	esp, 12					; 0000000cH

; 1073 : 
; 1074 : 			// Get the closure for the function
; 1075 : 			if(SQ_SUCCEEDED(sq_get(pVM, -2))) {

	push	-2					; fffffffeH
	mov	eax, DWORD PTR _pVM$209422[ebp]
	push	eax
	call	_sq_get
	add	esp, 8
	test	eax, eax
	jl	SHORT $LN1@onTimerCre

; 1076 : 				// Push the root table onto the stack
; 1077 : 				sq_pushroottable(pVM);

	mov	eax, DWORD PTR _pVM$209422[ebp]
	push	eax
	call	_sq_pushroottable
	add	esp, 4

; 1078 : 
; 1079 : 				// Push the timer id onto the stack
; 1080 : 				sq_pushinteger(pVM, timerId);

	mov	eax, DWORD PTR _timerId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pVM$209422[ebp]
	push	ecx
	call	_sq_pushinteger
	add	esp, 8

; 1081 : 
; 1082 : 				// Call the function
; 1083 : 				sq_call(pVM, 2, true, true);

	push	1
	push	1
	push	2
	mov	eax, DWORD PTR _pVM$209422[ebp]
	push	eax
	call	_sq_call
	add	esp, 16					; 00000010H
$LN1@onTimerCre:

; 1084 : 			}
; 1085 : 
; 1086 : 			// Restore the stack top
; 1087 : 			sq_settop(pVM, iTop);

	mov	eax, DWORD PTR _iTop$209423[ebp]
	push	eax
	mov	ecx, DWORD PTR _pVM$209422[ebp]
	push	ecx
	call	_sq_settop
	add	esp, 8
$LN2@onTimerCre:

; 1088 : 		}

	jmp	$LN4@onTimerCre
$LN6@onTimerCre:

; 1089 : 	}
; 1090 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?onTimerCreate@CScripts@@QAEXH@Z ENDP			; CScripts::onTimerCreate
_TEXT	ENDS
PUBLIC	??_C@_0P@PODCOEGJ@onTimerDestroy?$AA@		; `string'
PUBLIC	?onTimerDestroy@CScripts@@QAEXH@Z		; CScripts::onTimerDestroy
;	COMDAT ??_C@_0P@PODCOEGJ@onTimerDestroy?$AA@
CONST	SEGMENT
??_C@_0P@PODCOEGJ@onTimerDestroy?$AA@ DB 'onTimerDestroy', 00H ; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?onTimerDestroy@CScripts@@QAEXH@Z
_TEXT	SEGMENT
_iTop$209436 = -44					; size = 4
_pVM$209435 = -32					; size = 4
_i$209430 = -20						; size = 4
_this$ = -8						; size = 4
_timerId$ = 8						; size = 4
?onTimerDestroy@CScripts@@QAEXH@Z PROC			; CScripts::onTimerDestroy, COMDAT
; _this$ = ecx

; 1093 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1094 : 	for(int i = 0; i < MAX_SCRIPTS; i++) {

	mov	DWORD PTR _i$209430[ebp], 0
	jmp	SHORT $LN5@onTimerDes
$LN4@onTimerDes:
	mov	eax, DWORD PTR _i$209430[ebp]
	add	eax, 1
	mov	DWORD PTR _i$209430[ebp], eax
$LN5@onTimerDes:
	cmp	DWORD PTR _i$209430[ebp], 10		; 0000000aH
	jge	$LN6@onTimerDes

; 1095 : 		if(m_pScripts[i]) {

	mov	eax, DWORD PTR _i$209430[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	je	$LN2@onTimerDes

; 1096 : 			// get the script vm pointer
; 1097 : 			SQVM * pVM = m_pScripts[i]->GetVM();

	mov	eax, DWORD PTR _i$209430[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]
	call	?GetVM@CScript@@QAEPAUSQVM@@XZ		; CScript::GetVM
	mov	DWORD PTR _pVM$209435[ebp], eax

; 1098 : 
; 1099 : 			// Get the stack top
; 1100 : 			int iTop = sq_gettop(pVM);

	mov	eax, DWORD PTR _pVM$209435[ebp]
	push	eax
	call	_sq_gettop
	add	esp, 4
	mov	DWORD PTR _iTop$209436[ebp], eax

; 1101 : 
; 1102 : 			// Push the root table onto the stack
; 1103 : 			sq_pushroottable(pVM);

	mov	eax, DWORD PTR _pVM$209435[ebp]
	push	eax
	call	_sq_pushroottable
	add	esp, 4

; 1104 : 
; 1105 : 			// Push the function name onto the stack
; 1106 : 			sq_pushstring(pVM, "onTimerDestroy", -1);

	push	-1
	push	OFFSET ??_C@_0P@PODCOEGJ@onTimerDestroy?$AA@
	mov	eax, DWORD PTR _pVM$209435[ebp]
	push	eax
	call	_sq_pushstring
	add	esp, 12					; 0000000cH

; 1107 : 
; 1108 : 			// Get the closure for the function
; 1109 : 			if(SQ_SUCCEEDED(sq_get(pVM, -2))) {

	push	-2					; fffffffeH
	mov	eax, DWORD PTR _pVM$209435[ebp]
	push	eax
	call	_sq_get
	add	esp, 8
	test	eax, eax
	jl	SHORT $LN1@onTimerDes

; 1110 : 				// Push the root table onto the stack
; 1111 : 				sq_pushroottable(pVM);

	mov	eax, DWORD PTR _pVM$209435[ebp]
	push	eax
	call	_sq_pushroottable
	add	esp, 4

; 1112 : 
; 1113 : 				// Push the timer id onto the stack
; 1114 : 				sq_pushinteger(pVM, timerId);

	mov	eax, DWORD PTR _timerId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pVM$209435[ebp]
	push	ecx
	call	_sq_pushinteger
	add	esp, 8

; 1115 : 
; 1116 : 				// Call the function
; 1117 : 				sq_call(pVM, 2, true, true);

	push	1
	push	1
	push	2
	mov	eax, DWORD PTR _pVM$209435[ebp]
	push	eax
	call	_sq_call
	add	esp, 16					; 00000010H
$LN1@onTimerDes:

; 1118 : 			}
; 1119 : 
; 1120 : 			// Restore the stack top
; 1121 : 			sq_settop(pVM, iTop);

	mov	eax, DWORD PTR _iTop$209436[ebp]
	push	eax
	mov	ecx, DWORD PTR _pVM$209435[ebp]
	push	ecx
	call	_sq_settop
	add	esp, 8
$LN2@onTimerDes:

; 1122 : 		}

	jmp	$LN4@onTimerDes
$LN6@onTimerDes:

; 1123 : 	}
; 1124 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?onTimerDestroy@CScripts@@QAEXH@Z ENDP			; CScripts::onTimerDestroy
_TEXT	ENDS
PUBLIC	?DoEndianSwap@BitStream@RakNet@@SA_NXZ		; RakNet::BitStream::DoEndianSwap
EXTRN	?ReverseBytes@BitStream@RakNet@@SAXPAE0I@Z:PROC	; RakNet::BitStream::ReverseBytes
EXTRN	?ReadBits@BitStream@RakNet@@QAE_NPAEI_N@Z:PROC	; RakNet::BitStream::ReadBits
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\vice-players-master\raknet\bitstream.h
;	COMDAT ??$Read@H@BitStream@RakNet@@QAE_NAAH@Z
_TEXT	SEGMENT
_output$209447 = -20					; size = 4
_this$ = -8						; size = 4
_outTemplateVar$ = 8					; size = 4
??$Read@H@BitStream@RakNet@@QAE_NAAH@Z PROC		; RakNet::BitStream::Read<int>, COMDAT
; _this$ = ecx

; 1423 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1424 : #ifdef _MSC_VER
; 1425 : #pragma warning(disable:4127)   // conditional expression is constant
; 1426 : #endif
; 1427 : 		if (sizeof(outTemplateVar)==1)

	xor	eax, eax
	je	SHORT $LN5@Read

; 1428 : 			return ReadBits( ( unsigned char* ) &outTemplateVar, sizeof(templateType) * 8, true );

	push	1
	push	32					; 00000020H
	mov	eax, DWORD PTR _outTemplateVar$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadBits@BitStream@RakNet@@QAE_NPAEI_N@Z ; RakNet::BitStream::ReadBits
	jmp	SHORT $LN6@Read

; 1429 : 		else

	jmp	SHORT $LN6@Read
$LN5@Read:

; 1430 : 		{
; 1431 : #ifndef __BITSTREAM_NATIVE_END
; 1432 : #ifdef _MSC_VER
; 1433 : #pragma warning(disable:4244)   // '=' : conversion from 'unsigned long' to 'unsigned short', possible loss of data
; 1434 : #endif
; 1435 : 			if (DoEndianSwap())

	call	?DoEndianSwap@BitStream@RakNet@@SA_NXZ	; RakNet::BitStream::DoEndianSwap
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@Read

; 1436 : 			{
; 1437 : 				unsigned char output[sizeof(templateType)];
; 1438 : 				if (ReadBits( ( unsigned char* ) output, sizeof(templateType) * 8, true ))

	push	1
	push	32					; 00000020H
	lea	eax, DWORD PTR _output$209447[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadBits@BitStream@RakNet@@QAE_NPAEI_N@Z ; RakNet::BitStream::ReadBits
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Read

; 1439 : 				{
; 1440 : 					ReverseBytes(output, (unsigned char*)&outTemplateVar, sizeof(templateType));

	push	4
	mov	eax, DWORD PTR _outTemplateVar$[ebp]
	push	eax
	lea	ecx, DWORD PTR _output$209447[ebp]
	push	ecx
	call	?ReverseBytes@BitStream@RakNet@@SAXPAE0I@Z ; RakNet::BitStream::ReverseBytes
	add	esp, 12					; 0000000cH

; 1441 : 					return true;

	mov	al, 1
	jmp	SHORT $LN6@Read
$LN2@Read:

; 1442 : 				}
; 1443 : 				return false;

	xor	al, al
	jmp	SHORT $LN6@Read

; 1444 : 			}
; 1445 : 			else

	jmp	SHORT $LN6@Read
$LN3@Read:

; 1446 : #endif
; 1447 : 				return ReadBits( ( unsigned char* ) & outTemplateVar, sizeof(templateType) * 8, true );

	push	1
	push	32					; 00000020H
	mov	eax, DWORD PTR _outTemplateVar$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadBits@BitStream@RakNet@@QAE_NPAEI_N@Z ; RakNet::BitStream::ReadBits
$LN6@Read:

; 1448 : 		}
; 1449 : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@Read
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN10@Read:
	DD	1
	DD	$LN9@Read
$LN9@Read:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN8@Read
$LN8@Read:
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	112					; 00000070H
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	0
??$Read@H@BitStream@RakNet@@QAE_NAAH@Z ENDP		; RakNet::BitStream::Read<int>
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ??$Read@M@BitStream@RakNet@@QAE_NAAM@Z
_TEXT	SEGMENT
_output$209464 = -20					; size = 4
_this$ = -8						; size = 4
_outTemplateVar$ = 8					; size = 4
??$Read@M@BitStream@RakNet@@QAE_NAAM@Z PROC		; RakNet::BitStream::Read<float>, COMDAT
; _this$ = ecx

; 1423 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1424 : #ifdef _MSC_VER
; 1425 : #pragma warning(disable:4127)   // conditional expression is constant
; 1426 : #endif
; 1427 : 		if (sizeof(outTemplateVar)==1)

	xor	eax, eax
	je	SHORT $LN5@Read@2

; 1428 : 			return ReadBits( ( unsigned char* ) &outTemplateVar, sizeof(templateType) * 8, true );

	push	1
	push	32					; 00000020H
	mov	eax, DWORD PTR _outTemplateVar$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadBits@BitStream@RakNet@@QAE_NPAEI_N@Z ; RakNet::BitStream::ReadBits
	jmp	SHORT $LN6@Read@2

; 1429 : 		else

	jmp	SHORT $LN6@Read@2
$LN5@Read@2:

; 1430 : 		{
; 1431 : #ifndef __BITSTREAM_NATIVE_END
; 1432 : #ifdef _MSC_VER
; 1433 : #pragma warning(disable:4244)   // '=' : conversion from 'unsigned long' to 'unsigned short', possible loss of data
; 1434 : #endif
; 1435 : 			if (DoEndianSwap())

	call	?DoEndianSwap@BitStream@RakNet@@SA_NXZ	; RakNet::BitStream::DoEndianSwap
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@Read@2

; 1436 : 			{
; 1437 : 				unsigned char output[sizeof(templateType)];
; 1438 : 				if (ReadBits( ( unsigned char* ) output, sizeof(templateType) * 8, true ))

	push	1
	push	32					; 00000020H
	lea	eax, DWORD PTR _output$209464[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadBits@BitStream@RakNet@@QAE_NPAEI_N@Z ; RakNet::BitStream::ReadBits
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Read@2

; 1439 : 				{
; 1440 : 					ReverseBytes(output, (unsigned char*)&outTemplateVar, sizeof(templateType));

	push	4
	mov	eax, DWORD PTR _outTemplateVar$[ebp]
	push	eax
	lea	ecx, DWORD PTR _output$209464[ebp]
	push	ecx
	call	?ReverseBytes@BitStream@RakNet@@SAXPAE0I@Z ; RakNet::BitStream::ReverseBytes
	add	esp, 12					; 0000000cH

; 1441 : 					return true;

	mov	al, 1
	jmp	SHORT $LN6@Read@2
$LN2@Read@2:

; 1442 : 				}
; 1443 : 				return false;

	xor	al, al
	jmp	SHORT $LN6@Read@2

; 1444 : 			}
; 1445 : 			else

	jmp	SHORT $LN6@Read@2
$LN3@Read@2:

; 1446 : #endif
; 1447 : 				return ReadBits( ( unsigned char* ) & outTemplateVar, sizeof(templateType) * 8, true );

	push	1
	push	32					; 00000020H
	mov	eax, DWORD PTR _outTemplateVar$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadBits@BitStream@RakNet@@QAE_NPAEI_N@Z ; RakNet::BitStream::ReadBits
$LN6@Read@2:

; 1448 : 		}
; 1449 : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@Read@2
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN10@Read@2:
	DD	1
	DD	$LN9@Read@2
$LN9@Read@2:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN8@Read@2
$LN8@Read@2:
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	112					; 00000070H
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	0
??$Read@M@BitStream@RakNet@@QAE_NAAM@Z ENDP		; RakNet::BitStream::Read<float>
_TEXT	ENDS
PUBLIC	?IsNetworkOrder@BitStream@RakNet@@SA_NXZ	; RakNet::BitStream::IsNetworkOrder
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?DoEndianSwap@BitStream@RakNet@@SA_NXZ
_TEXT	SEGMENT
?DoEndianSwap@BitStream@RakNet@@SA_NXZ PROC		; RakNet::BitStream::DoEndianSwap, COMDAT

; 863  : 		inline static bool DoEndianSwap(void) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 864  : #ifndef __BITSTREAM_NATIVE_END
; 865  : 			return IsNetworkOrder()==false;

	call	?IsNetworkOrder@BitStream@RakNet@@SA_NXZ ; RakNet::BitStream::IsNetworkOrder
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 866  : #else
; 867  : 			return false;
; 868  : #endif
; 869  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DoEndianSwap@BitStream@RakNet@@SA_NXZ ENDP		; RakNet::BitStream::DoEndianSwap
_TEXT	ENDS
PUBLIC	?r@?1??IsNetworkOrder@BitStream@RakNet@@SA_NXZ@4_NB ; `RakNet::BitStream::IsNetworkOrder'::`2'::r
PUBLIC	??_B?1??IsNetworkOrder@BitStream@RakNet@@SA_NXZ@51 ; `RakNet::BitStream::IsNetworkOrder'::`2'::`local static guard'
EXTRN	?IsNetworkOrderInternal@BitStream@RakNet@@SA_NXZ:PROC ; RakNet::BitStream::IsNetworkOrderInternal
;	COMDAT ?r@?1??IsNetworkOrder@BitStream@RakNet@@SA_NXZ@4_NB
_BSS	SEGMENT
?r@?1??IsNetworkOrder@BitStream@RakNet@@SA_NXZ@4_NB DB 01H DUP (?) ; `RakNet::BitStream::IsNetworkOrder'::`2'::r
_BSS	ENDS
;	COMDAT ??_B?1??IsNetworkOrder@BitStream@RakNet@@SA_NXZ@51
_BSS	SEGMENT
??_B?1??IsNetworkOrder@BitStream@RakNet@@SA_NXZ@51 DD 01H DUP (?) ; `RakNet::BitStream::IsNetworkOrder'::`2'::`local static guard'
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?IsNetworkOrder@BitStream@RakNet@@SA_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?IsNetworkOrder@BitStream@RakNet@@SA_NXZ$0
__ehfuncinfo$?IsNetworkOrder@BitStream@RakNet@@SA_NXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?IsNetworkOrder@BitStream@RakNet@@SA_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCsu /ZI
xdata$x	ENDS
;	COMDAT ?IsNetworkOrder@BitStream@RakNet@@SA_NXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
?IsNetworkOrder@BitStream@RakNet@@SA_NXZ PROC		; RakNet::BitStream::IsNetworkOrder, COMDAT

; 874  : 		inline static bool IsNetworkOrder(void) {static const bool r = IsNetworkOrderInternal(); return r;}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?IsNetworkOrder@BitStream@RakNet@@SA_NXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR ??_B?1??IsNetworkOrder@BitStream@RakNet@@SA_NXZ@51
	and	eax, 1
	jne	SHORT $LN1@IsNetworkO
	mov	eax, DWORD PTR ??_B?1??IsNetworkOrder@BitStream@RakNet@@SA_NXZ@51
	or	eax, 1
	mov	DWORD PTR ??_B?1??IsNetworkOrder@BitStream@RakNet@@SA_NXZ@51, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	?IsNetworkOrderInternal@BitStream@RakNet@@SA_NXZ ; RakNet::BitStream::IsNetworkOrderInternal
	mov	BYTE PTR ?r@?1??IsNetworkOrder@BitStream@RakNet@@SA_NXZ@4_NB, al ; `RakNet::BitStream::IsNetworkOrder'::`2'::r
	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN1@IsNetworkO:
	mov	al, BYTE PTR ?r@?1??IsNetworkOrder@BitStream@RakNet@@SA_NXZ@4_NB ; `RakNet::BitStream::IsNetworkOrder'::`2'::r
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?IsNetworkOrder@BitStream@RakNet@@SA_NXZ$0:
	mov	eax, DWORD PTR ??_B?1??IsNetworkOrder@BitStream@RakNet@@SA_NXZ@51
	and	eax, -2					; fffffffeH
	mov	DWORD PTR ??_B?1??IsNetworkOrder@BitStream@RakNet@@SA_NXZ@51, eax
	ret	0
__ehhandler$?IsNetworkOrder@BitStream@RakNet@@SA_NXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?IsNetworkOrder@BitStream@RakNet@@SA_NXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?IsNetworkOrder@BitStream@RakNet@@SA_NXZ ENDP		; RakNet::BitStream::IsNetworkOrder
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??$Read@_N@BitStream@RakNet@@QAE_NAA_N@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_outTemplateVar$ = 8					; size = 4
??$Read@_N@BitStream@RakNet@@QAE_NAA_N@Z PROC		; RakNet::BitStream::Read<bool>, COMDAT
; _this$ = ecx

; 1485 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1486 : 		if ( readOffset + 1 > numberOfBitsUsed )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	cmp	ecx, DWORD PTR [edx]
	jbe	SHORT $LN3@Read@3

; 1487 : 			return false;

	xor	al, al
	jmp	SHORT $LN4@Read@3
$LN3@Read@3:

; 1488 : 
; 1489 : 		if ( data[ readOffset >> 3 ] & ( 0x80 >> ( readOffset & 7 ) ) )   // Is it faster to just write it out here?

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shr	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	movzx	edx, BYTE PTR [eax+ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 7
	mov	eax, 128				; 00000080H
	sar	eax, cl
	and	edx, eax
	je	SHORT $LN2@Read@3

; 1490 : 			outTemplateVar = true;

	mov	eax, DWORD PTR _outTemplateVar$[ebp]
	mov	BYTE PTR [eax], 1

; 1491 : 		else

	jmp	SHORT $LN1@Read@3
$LN2@Read@3:

; 1492 : 			outTemplateVar = false;

	mov	eax, DWORD PTR _outTemplateVar$[ebp]
	mov	BYTE PTR [eax], 0
$LN1@Read@3:

; 1493 : 
; 1494 : 		// Has to be on a different line for Mac
; 1495 : 		readOffset++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1496 : 
; 1497 : 		return true;

	mov	al, 1
$LN4@Read@3:

; 1498 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??$Read@_N@BitStream@RakNet@@QAE_NAA_N@Z ENDP		; RakNet::BitStream::Read<bool>
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\vice-players-master\client\scripting\cscript.h
_TEXT	ENDS
;	COMDAT ?GetVM@CScript@@QAEPAUSQVM@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetVM@CScript@@QAEPAUSQVM@@XZ PROC			; CScript::GetVM, COMDAT
; _this$ = ecx

; 28   : 	SQVM * GetVM() { return m_pVM; };

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetVM@CScript@@QAEPAUSQVM@@XZ ENDP			; CScript::GetVM
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ?GetScriptName@CScript@@QAEPADXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetScriptName@CScript@@QAEPADXZ PROC			; CScript::GetScriptName, COMDAT
; _this$ = ecx

; 30   : 	char * GetScriptName() { return (char*)&m_szScriptName; };

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetScriptName@CScript@@QAEPADXZ ENDP			; CScript::GetScriptName
_TEXT	ENDS
PUBLIC	??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ ; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xstring
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCsu /ZI
xdata$x	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
$T209687 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 651  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T209687[ebp], esp
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 652  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 653  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 654  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
__ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCsu /ZI
xdata$x	ENDS
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 905  : 		{	// destroy the string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 906  : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 907  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ
__ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 1650 : 		{	// return pointer to null-terminated nonmutable array

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1651 : 		return (_Myptr());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr

; 1652 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
PUBLIC	??1_String_base@std@@QAE@XZ			; std::_String_base::~_String_base
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_String_base@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??1_Container_base_secure@std@@QAE@XZ		; std::_Container_base_secure::~_Container_base_secure
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1_String_base@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1_String_base@std@@QAE@XZ PROC			; std::_String_base::~_String_base, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_secure@std@@QAE@XZ	; std::_Container_base_secure::~_Container_base_secure
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1_String_base@std@@QAE@XZ ENDP			; std::_String_base::~_String_base
_TEXT	ENDS
PUBLIC	?_Orphan_all@_Container_base_secure@std@@QBEXXZ	; std::_Container_base_secure::_Orphan_all
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1_Container_base_secure@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1_Container_base_secure@std@@QAE@XZ PROC		; std::_Container_base_secure::~_Container_base_secure, COMDAT
; _this$ = ecx

; 113  : 		{	// destroy the container

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 114  : 		_Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_all@_Container_base_secure@std@@QBEXXZ ; std::_Container_base_secure::_Orphan_all

; 115  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Container_base_secure@std@@QAE@XZ ENDP		; std::_Container_base_secure::~_Container_base_secure
_TEXT	ENDS
EXTRN	??1_Lockit@std@@QAE@XZ:PROC			; std::_Lockit::~_Lockit
EXTRN	??0_Lockit@std@@QAE@H@Z:PROC			; std::_Lockit::_Lockit
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?_Orphan_all@_Container_base_secure@std@@QBEXXZ
_TEXT	SEGMENT
__Pnext$9026 = -32					; size = 4
__Lock$ = -20						; size = 4
_this$ = -8						; size = 4
?_Orphan_all@_Container_base_secure@std@@QBEXXZ PROC	; std::_Container_base_secure::_Orphan_all, COMDAT
; _this$ = ecx

; 217  : 	{	// orphan all iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 218  : 	_Lockit _Lock(_LOCK_DEBUG);

	push	3
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 219  : 	if (_Myfirstiter != _IGNORE_MYITERLIST)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], -3			; fffffffdH
	je	SHORT $LN4@Orphan_all

; 220  : 		{
; 221  : 		for (_Iterator_base **_Pnext = (_Iterator_base **)&_Myfirstiter;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __Pnext$9026[ebp], eax
	jmp	SHORT $LN3@Orphan_all
$LN2@Orphan_all:

; 222  : 			*_Pnext != 0; *_Pnext = (*_Pnext)->_Mynextiter)

	mov	eax, DWORD PTR __Pnext$9026[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Pnext$9026[ebp]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx], eax
$LN3@Orphan_all:
	mov	eax, DWORD PTR __Pnext$9026[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@Orphan_all

; 223  : 			(*_Pnext)->_Mycont = 0;

	mov	eax, DWORD PTR __Pnext$9026[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], 0
	jmp	SHORT $LN2@Orphan_all
$LN1@Orphan_all:

; 224  : 		*(_Iterator_base **)&_Myfirstiter = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$LN4@Orphan_all:

; 225  : 		}
; 226  : 	}

	lea	ecx, DWORD PTR __Lock$[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@Orphan_all
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN10@Orphan_all:
	DD	1
	DD	$LN9@Orphan_all
$LN9@Orphan_all:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN8@Orphan_all
$LN8@Orphan_all:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
?_Orphan_all@_Container_base_secure@std@@QBEXXZ ENDP	; std::_Container_base_secure::_Orphan_all
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z		; std::_Debug_pointer<char>
PUBLIC	??_C@_1IM@EDGMOHHN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; `string'
;	COMDAT ??_C@_1IM@EDGMOHHN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xstring
CONST	SEGMENT
??_C@_1IM@EDGMOHHN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, '9', 00H, '.', 00H, '0', 00H, '\', 00H, 'v', 00H, 'c'
	DB	00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l', 00H, 'u', 00H
	DB	'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 's', 00H, 't', 00H, 'r'
	DB	00H, 'i', 00H, 'n', 00H, 'g', 00H, 00H, 00H	; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1083 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1084 : 		_DEBUG_POINTER(_Ptr);

	push	1084					; 0000043cH
	push	OFFSET ??_C@_1IM@EDGMOHHN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z	; std::_Debug_pointer<char>
	add	esp, 12					; 0000000cH

; 1085 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1086 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
EXTRN	_strlen:PROC
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 447  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 448  : //		_DEBUG_POINTER(_First);
; 449  : 		return (::strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	_strlen
	add	esp, 4

; 450  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z ; std::_Traits_helper::copy_s<std::char_traits<char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT
__Ptr$196307 = -20					; size = 4
_this$ = -8						; size = 4
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2148 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2149 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $LN4@Tidy
	jmp	SHORT $LN3@Tidy
$LN4@Tidy:

; 2150 : 			;
; 2151 : 		else if (_BUF_SIZE <= _Myres)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+28], 16			; 00000010H
	jb	SHORT $LN3@Tidy

; 2152 : 			{	// copy any leftovers to small buffer and deallocate
; 2153 : 			_Elem *_Ptr = _Bx._Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Ptr$196307[ebp], ecx

; 2154 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN1@Tidy

; 2155 : 				_Traits_helper::copy_s<_Traits>(_Bx._Buf, _BUF_SIZE, _Ptr, _Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$196307[ebp]
	push	ecx
	push	16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	push	edx
	call	??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z ; std::_Traits_helper::copy_s<std::char_traits<char> >
	add	esp, 16					; 00000010H
$LN1@Tidy:

; 2156 : 			_Mybase::_Alval.deallocate(_Ptr, _Myres + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$196307[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate
$LN3@Tidy:

; 2157 : 			}
; 2158 : 		_Myres = _BUF_SIZE - 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], 15			; 0000000fH

; 2159 : 		_Eos(_Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2160 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IBEPBDXZ
_TEXT	SEGMENT
tv70 = -208						; size = 4
_this$ = -8						; size = 4
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2174 : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2175 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+28], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv70[ebp], edx
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	mov	DWORD PTR tv70[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv70[ebp]

; 2176 : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
_TEXT	ENDS
PUBLIC	??0?$allocator@D@std@@QAE@ABV01@@Z		; std::allocator<char>::allocator<char>
PUBLIC	??0_String_base@std@@QAE@XZ			; std::_String_base::_String_base
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Al$ = 8						; size = 1
??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z PROC ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 472  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_String_base@std@@QAE@XZ
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0?$allocator@D@std@@QAE@ABV01@@Z	; std::allocator<char>::allocator<char>

; 473  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ENDP ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
PUBLIC	??0_Container_base_secure@std@@QAE@XZ		; std::_Container_base_secure::_Container_base_secure
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0_String_base@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_String_base@std@@QAE@XZ PROC			; std::_String_base::_String_base, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_secure@std@@QAE@XZ	; std::_Container_base_secure::_Container_base_secure
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0_String_base@std@@QAE@XZ ENDP			; std::_String_base::_String_base
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??0_Container_base_secure@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_Container_base_secure@std@@QAE@XZ PROC		; std::_Container_base_secure::_Container_base_secure, COMDAT
; _this$ = ecx

; 99   : 		{	// construct childless container

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 100  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Container_base_secure@std@@QAE@XZ ENDP		; std::_Container_base_secure::_Container_base_secure
_TEXT	ENDS
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1064 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1065 : 
; 1066 :  #if _HAS_ITERATOR_DEBUGGING
; 1067 : 		if (_Count != 0)

	cmp	DWORD PTR __Count$[ebp], 0
	je	SHORT $LN3@assign

; 1068 : 			_DEBUG_POINTER(_Ptr);

	push	1068					; 0000042cH
	push	OFFSET ??_C@_1IM@EDGMOHHN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z	; std::_Debug_pointer<char>
	add	esp, 12					; 0000000cH
$LN3@assign:

; 1069 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1070 : 
; 1071 : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 1072 : 			return (assign(*this, _Ptr - _Myptr(), _Count));	// substring

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $LN4@assign
$LN2@assign:

; 1073 : 
; 1074 : 		if (_Grow(_Count))

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@assign

; 1075 : 			{	// make room and assign new stuff
; 1076 : 			_Traits_helper::copy_s<_Traits>(_Myptr(), _Myres, _Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	push	eax
	call	??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z ; std::_Traits_helper::copy_s<std::char_traits<char> >
	add	esp, 16					; 00000010H

; 1077 : 			_Eos(_Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign:

; 1078 : 			}
; 1079 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN4@assign:

; 1080 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
EXTRN	?_Xran@_String_base@std@@SAXXZ:PROC		; std::_String_base::_Xran
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
CONST	SEGMENT
?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB DD 0ffffffffH ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -20						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1046 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1047 : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN5@assign@2

; 1048 : 			_String_base::_Xran();	// _Roff off end

	call	?_Xran@_String_base@std@@SAXXZ		; std::_String_base::_Xran
$LN5@assign@2:

; 1049 : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 1050 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $LN4@assign@2

; 1051 : 			_Num = _Count;	// trim _Num to size

	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], eax
$LN4@assign@2:

; 1052 : 
; 1053 : 		if (this == &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@assign@2

; 1054 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
	push	eax
	mov	ecx, DWORD PTR __Roff$[ebp]
	add	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	edx, DWORD PTR __Roff$[ebp]
	push	edx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	jmp	SHORT $LN2@assign@2
$LN3@assign@2:

; 1055 : 		else if (_Grow(_Num))

	push	0
	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign@2

; 1056 : 			{	// make room and assign new stuff
; 1057 : 			_Traits_helper::copy_s<_Traits>(_Myptr(), _Myres, _Right._Myptr() + _Roff, _Num);

	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	push	eax
	call	??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z ; std::_Traits_helper::copy_s<std::char_traits<char> >
	add	esp, 16					; 00000010H

; 1058 : 			_Eos(_Num);

	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign@2:

; 1059 : 			}
; 1060 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 1061 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1665 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1666 : 		return (_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+24]

; 1667 : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
PUBLIC	??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z ; std::_Traits_helper::move_s<std::char_traits<char> >
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$196290 = -20					; size = 4
_this$ = -8						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1262 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1263 : 		if (_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN3@erase

; 1264 : 			_String_base::_Xran();	// _Off off end

	call	?_Xran@_String_base@std@@SAXXZ		; std::_String_base::_Xran
$LN3@erase:

; 1265 : 		if (_Mysize - _Off < _Count)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	sub	ecx, DWORD PTR __Off$[ebp]
	cmp	ecx, DWORD PTR __Count$[ebp]
	jae	SHORT $LN2@erase

; 1266 : 			_Count = _Mysize - _Off;	// trim _Count

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	sub	ecx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Count$[ebp], ecx
$LN2@erase:

; 1267 : 		if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@erase

; 1268 : 			{	// move elements down
; 1269 : 			_Traits_helper::move_s<_Traits>(_Myptr() + _Off, _Myres - _Off, _Myptr() + _Off + _Count,
; 1270 : 				_Mysize - _Off - _Count);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	sub	ecx, DWORD PTR __Off$[ebp]
	sub	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	sub	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	push	eax
	call	??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z ; std::_Traits_helper::move_s<std::char_traits<char> >
	add	esp, 16					; 00000010H

; 1271 : 			size_type _Newsize = _Mysize - _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	sub	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$196290[ebp], ecx

; 1272 : 			_Eos(_Newsize);

	mov	eax, DWORD PTR __Newsize$196290[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@erase:

; 1273 : 			}
; 1274 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 1275 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z
_TEXT	SEGMENT
$T209752 = -209						; size = 1
_this$ = -8						; size = 4
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2113 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2114 : 		_Traits::assign(_Myptr()[_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T209752[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+24], ecx
	lea	edx, DWORD PTR $T209752[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2115 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\iosfwd
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 424  : 		{	// assign an element

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 425  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 426  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
EXTRN	?_Xlen@_String_base@std@@SAXXZ:PROC		; std::_String_base::_Xlen
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT
tv80 = -208						; size = 4
_this$ = -8						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2119 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2120 : 			if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN6@Grow

; 2121 : 			_String_base::_Xlen();	// result too long

	call	?_Xlen@_String_base@std@@SAXXZ		; std::_String_base::_Xlen
$LN6@Grow:

; 2122 : 		if (_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN5@Grow

; 2123 : 			_Copy(_Newsize, _Mysize);	// reallocate to grow

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	jmp	SHORT $LN4@Grow
$LN5@Grow:

; 2124 : 		else if (_Trim && _Newsize < _BUF_SIZE)

	movzx	eax, BYTE PTR __Trim$[ebp]
	test	eax, eax
	je	SHORT $LN3@Grow
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $LN3@Grow

; 2125 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2126 : 				_Newsize < _Mysize ? _Newsize : _Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+24]
	jae	SHORT $LN9@Grow
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv80[ebp], edx
	jmp	SHORT $LN10@Grow
$LN9@Grow:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR tv80[ebp], ecx
$LN10@Grow:
	mov	edx, DWORD PTR tv80[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	jmp	SHORT $LN4@Grow
$LN3@Grow:

; 2127 : 		else if (_Newsize == 0)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $LN4@Grow

; 2128 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2129 : 		return (0 < _Newsize);	// return true only if more work to do

	xor	eax, eax
	cmp	eax, DWORD PTR __Newsize$[ebp]
	sbb	eax, eax
	neg	eax

; 2130 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEPADXZ
_TEXT	SEGMENT
tv70 = -208						; size = 4
_this$ = -8						; size = 4
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEPADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2169 : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2170 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+28], 16			; 00000010H
	jb	SHORT $LN3@Myptr@2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv70[ebp], edx
	jmp	SHORT $LN4@Myptr@2
$LN3@Myptr@2:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	mov	DWORD PTR tv70[ebp], eax
$LN4@Myptr@2:
	mov	eax, DWORD PTR tv70[ebp]

; 2171 : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEPADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
tv73 = -220						; size = 4
__Num$ = -20						; size = 4
_this$ = -8						; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1670 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1671 : 		size_type _Num = _Mybase::_Alval.max_size();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1672 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $LN3@max_size
	mov	DWORD PTR tv73[ebp], 1
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	eax, DWORD PTR __Num$[ebp]
	sub	eax, 1
	mov	DWORD PTR tv73[ebp], eax
$LN4@max_size:
	mov	eax, DWORD PTR tv73[ebp]

; 1673 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
EXTRN	__CxxThrowException@8:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$5
; Function compile flags: /Odtp /RTCsu /ZI
xdata$x	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
_TEXT	SEGMENT
tv157 = -248						; size = 4
tv156 = -248						; size = 4
__Ptr$ = -48						; size = 4
__Newres$ = -36						; size = 4
_this$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2083 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-248]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2084 : 		size_type _Newres = _Newsize | _ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 2085 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $LN6@Copy

; 2086 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], eax

; 2087 : 		else if (_Newres / 3 < _Myres / 2

	jmp	SHORT $LN5@Copy
$LN6@Copy:

; 2088 : 			&& _Myres <= max_size() - _Myres / 2)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	shr	ecx, 1
	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	esi, 3
	div	esi
	cmp	eax, ecx
	jae	SHORT $LN5@Copy
	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [eax+28]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+28], eax
	ja	SHORT $LN5@Copy

; 2089 : 			_Newres = _Myres + _Myres / 2;	// grow exponentially if possible

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	shr	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+28]
	mov	DWORD PTR __Newres$[ebp], ecx
$LN5@Copy:

; 2090 : 		_Elem *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 2091 : 
; 2092 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2093 : 			_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

	mov	eax, DWORD PTR __Newres$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
	mov	DWORD PTR tv156[ebp], eax
	mov	ecx, DWORD PTR tv156[ebp]
	mov	DWORD PTR __Ptr$[ebp], ecx
	jmp	SHORT $LN9@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$0:

; 2094 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 2095 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], eax

; 2096 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 2097 : 				_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

	mov	eax, DWORD PTR __Newres$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
	mov	DWORD PTR tv157[ebp], eax
	mov	ecx, DWORD PTR tv157[ebp]
	mov	DWORD PTR __Ptr$[ebp], ecx
	jmp	SHORT $LN11@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$1:

; 2098 : 			_CATCH_ALL
; 2099 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2100 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 2101 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 1
	mov	eax, __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$2
	ret	0
$LN11@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$2:

; 2102 : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 1
	mov	eax, __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$3
	ret	0
$LN9@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$3:

; 2103 : 
; 2104 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $LN1@Copy

; 2105 : 			_Traits_helper::copy_s<_Traits>(_Ptr, _Newres + 1, _Myptr(), _Oldlen);	// copy existing elements

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR __Newres$[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	call	??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z ; std::_Traits_helper::copy_s<std::char_traits<char> >
	add	esp, 16					; 00000010H
$LN1@Copy:

; 2106 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2107 : 		_Bx._Ptr = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 2108 : 		_Myres = _Newres;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 2109 : 		_Eos(_Oldlen);

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN8@Copy:

; 2110 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 248				; 000000f8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-252]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 146  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xstring
_TEXT	ENDS
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2133 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2134 : 		if (_Ptr == 0 || _Ptr < _Myptr() || _Myptr() + _Mysize <= _Ptr)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+24]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
$LN2@Inside:

; 2135 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $LN4@Inside

; 2136 : 		else

	jmp	SHORT $LN4@Inside
$LN3@Inside:

; 2137 : 			return (true);

	mov	al, 1
$LN4@Inside:

; 2138 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -220						; size = 4
__Count$ = -20						; size = 4
_this$ = -8						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], -1

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@2
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@2
$LN3@max_size@2:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@2:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
PUBLIC	??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; `string'
EXTRN	?_Debug_message@std@@YAXPB_W0I@Z:PROC		; std::_Debug_message
;	COMDAT ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
CONST	SEGMENT
??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ DB 'i'
	DB	00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd', 00H
	DB	' ', 00H, 'n', 00H, 'u', 00H, 'l', 00H, 'l', 00H, ' ', 00H, 'p'
	DB	00H, 'o', 00H, 'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H
	DB	00H, 00H					; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__File$ = 12						; size = 4
__Line$ = 16						; size = 4
??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z PROC		; std::_Debug_pointer<char>, COMDAT

; 1537 : 	{	// test iterator for non-singularity, const pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1538 : 	if (_First == 0)

	cmp	DWORD PTR __First$[ebp], 0
	jne	SHORT $LN2@Debug_poin

; 1539 : 		_DEBUG_ERROR2("invalid null pointer", _File, _Line);

	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	push	OFFSET ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
	call	?_Debug_message@std@@YAXPB_W0I@Z	; std::_Debug_message
	add	esp, 12					; 0000000cH
$LN2@Debug_poin:

; 1540 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ENDP		; std::_Debug_pointer<char>
_TEXT	ENDS
PUBLIC	??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z ; std::_Traits_helper::copy_s<std::char_traits<char> >
PUBLIC	??$_Char_traits_cat@U?$char_traits@D@std@@@std@@YA?AU_Secure_char_traits_tag@0@XZ ; std::_Char_traits_cat<std::char_traits<char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\iosfwd
;	COMDAT ??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z
_TEXT	SEGMENT
$T209802 = -197						; size = 1
__First1$ = 8						; size = 4
__Size$ = 12						; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z PROC ; std::_Traits_helper::copy_s<std::char_traits<char> >, COMDAT

; 588  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 589  : 		return copy_s<_Traits>(_First1, _Size, _First2, _Count, _Char_traits_cat<_Traits>());

	call	??$_Char_traits_cat@U?$char_traits@D@std@@@std@@YA?AU_Secure_char_traits_tag@0@XZ ; std::_Char_traits_cat<std::char_traits<char> >
	mov	BYTE PTR $T209802[ebp], al
	movzx	eax, BYTE PTR $T209802[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __Size$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First1$[ebp]
	push	ecx
	call	??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z ; std::_Traits_helper::copy_s<std::char_traits<char> >
	add	esp, 20					; 00000014H

; 590  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z ENDP ; std::_Traits_helper::copy_s<std::char_traits<char> >
_TEXT	ENDS
PUBLIC	??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z ; std::_Traits_helper::move_s<std::char_traits<char> >
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z
_TEXT	SEGMENT
$T209805 = -197						; size = 1
__First1$ = 8						; size = 4
__Size$ = 12						; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z PROC ; std::_Traits_helper::move_s<std::char_traits<char> >, COMDAT

; 615  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 616  : 		return move_s<_Traits>(_First1, _Size, _First2, _Count, _Char_traits_cat<_Traits>());

	call	??$_Char_traits_cat@U?$char_traits@D@std@@@std@@YA?AU_Secure_char_traits_tag@0@XZ ; std::_Char_traits_cat<std::char_traits<char> >
	mov	BYTE PTR $T209805[ebp], al
	movzx	eax, BYTE PTR $T209805[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __Size$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First1$[ebp]
	push	ecx
	call	??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z ; std::_Traits_helper::move_s<std::char_traits<char> >
	add	esp, 20					; 00000014H

; 617  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z ENDP ; std::_Traits_helper::move_s<std::char_traits<char> >
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Odtp /RTCsu /ZI
xdata$x	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
$T209808 = -208						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 212				; 000000d4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-212]
	mov	ecx, 53					; 00000035H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 1
	jae	SHORT $LN2@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T209808[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T209808[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate:

; 44   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 212				; 000000d4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1bad_alloc@std@@UAE@XZ		; std::bad_alloc::~bad_alloc
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@2
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@2:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0exception@std@@QAE@ABV01@@Z		; std::exception::exception
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\iosfwd
_TEXT	ENDS
;	COMDAT ??$_Char_traits_cat@U?$char_traits@D@std@@@std@@YA?AU_Secure_char_traits_tag@0@XZ
_TEXT	SEGMENT
__Secure$ = -5						; size = 1
??$_Char_traits_cat@U?$char_traits@D@std@@@std@@YA?AU_Secure_char_traits_tag@0@XZ PROC ; std::_Char_traits_cat<std::char_traits<char> >, COMDAT

; 575  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 576  : 		typename _Char_traits_category<_Traits>::_Secure_char_traits _Secure;
; 577  : 		return (_Secure);

	mov	al, BYTE PTR __Secure$[ebp]

; 578  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Char_trait
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@Char_trait:
	DD	1
	DD	$LN4@Char_trait
$LN4@Char_trait:
	DD	-5					; fffffffbH
	DD	1
	DD	$LN3@Char_trait
$LN3@Char_trait:
	DB	95					; 0000005fH
	DB	83					; 00000053H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	0
??$_Char_traits_cat@U?$char_traits@D@std@@@std@@YA?AU_Secure_char_traits_tag@0@XZ ENDP ; std::_Char_traits_cat<std::char_traits<char> >
_TEXT	ENDS
PUBLIC	?_Copy_s@?$char_traits@D@std@@SAPADPADIPBDI@Z	; std::char_traits<char>::_Copy_s
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size$ = 12						; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
___formal$ = 24						; size = 1
??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z PROC ; std::_Traits_helper::copy_s<std::char_traits<char> >, COMDAT

; 596  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 597  : 		return _Traits::_Copy_s(_First1, _Size, _First2, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Size$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	?_Copy_s@?$char_traits@D@std@@SAPADPADIPBDI@Z ; std::char_traits<char>::_Copy_s
	add	esp, 16					; 00000010H

; 598  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z ENDP ; std::_Traits_helper::copy_s<std::char_traits<char> >
_TEXT	ENDS
EXTRN	_memcpy_s:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?_Copy_s@?$char_traits@D@std@@SAPADPADIPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size_in_bytes$ = 12					; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
?_Copy_s@?$char_traits@D@std@@SAPADPADIPBDI@Z PROC	; std::char_traits<char>::_Copy_s, COMDAT

; 462  : 		{	// copy [_First1, _First1 + _Count) to [_First2, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 463  : //		_DEBUG_POINTER(_First1);
; 464  : //		_DEBUG_POINTER(_First2);
; 465  : 		_CRT_SECURE_MEMCPY(_First1, _Size_in_bytes, _First2, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Size_in_bytes$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memcpy_s
	add	esp, 16					; 00000010H

; 466  : 		return _First1;

	mov	eax, DWORD PTR __First1$[ebp]

; 467  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Copy_s@?$char_traits@D@std@@SAPADPADIPBDI@Z ENDP	; std::char_traits<char>::_Copy_s
_TEXT	ENDS
PUBLIC	?_Move_s@?$char_traits@D@std@@SAPADPADIPBDI@Z	; std::char_traits<char>::_Move_s
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size$ = 12						; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
___formal$ = 24						; size = 1
??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z PROC ; std::_Traits_helper::move_s<std::char_traits<char> >, COMDAT

; 623  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 624  : 		return _Traits::_Move_s(_First1, _Size, _First2, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Size$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	?_Move_s@?$char_traits@D@std@@SAPADPADIPBDI@Z ; std::char_traits<char>::_Move_s
	add	esp, 16					; 00000010H

; 625  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z ENDP ; std::_Traits_helper::move_s<std::char_traits<char> >
_TEXT	ENDS
EXTRN	_memmove_s:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?_Move_s@?$char_traits@D@std@@SAPADPADIPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size_in_bytes$ = 12					; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
?_Move_s@?$char_traits@D@std@@SAPADPADIPBDI@Z PROC	; std::char_traits<char>::_Move_s, COMDAT

; 486  : 		{	// move [_First1, _First1 + _Count) to [_First2, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 487  : //		_DEBUG_POINTER(_First1);
; 488  : //		_DEBUG_POINTER(_First2);
; 489  : 		_CRT_SECURE_MEMMOVE(_First1, _Size_in_bytes, _First2, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Size_in_bytes$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memmove_s
	add	esp, 16					; 00000010H

; 490  : 		return _First1;

	mov	eax, DWORD PTR __First1$[ebp]

; 491  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Move_s@?$char_traits@D@std@@SAPADPADIPBDI@Z ENDP	; std::char_traits<char>::_Move_s
_TEXT	ENDS
END
