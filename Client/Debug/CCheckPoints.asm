; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\vice-players-master\Client\net\CCheckPoints.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
_disable_marker DW 0164H
	DB	'i', 00H
	ORG $+11
	ORG $+1
_set_marker_color DW 0165H
	DB	'vi', 00H
	ORG $+10
	ORG $+1
_create_icon_marker_without_sphere DW 04ceH
	DB	'fffiv', 00H
	ORG $+7
	ORG $+1
CONST	ENDS
PUBLIC	?GetSphereFromIndex@@YAPAUSPHERE_TYPE@@E@Z	; GetSphereFromIndex
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT rtc$TMZ
; File d:\vice-players-master\client\net\ccheckpoints.cpp
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu /ZI
rtc$IMZ	ENDS
;	COMDAT ?GetSphereFromIndex@@YAPAUSPHERE_TYPE@@E@Z
_TEXT	SEGMENT
_index$ = 8						; size = 1
?GetSphereFromIndex@@YAPAUSPHERE_TYPE@@E@Z PROC		; GetSphereFromIndex, COMDAT

; 34   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 35   : 	if(index >= MAX_SPHERES)

	movzx	eax, BYTE PTR _index$[ebp]
	cmp	eax, 16					; 00000010H
	jl	SHORT $LN1@GetSphereF

; 36   : 	{
; 37   : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN2@GetSphereF
$LN1@GetSphereF:

; 38   : 	}
; 39   : 
; 40   : 	return (SPHERE_TYPE *)(VAR_Spheres + (index * sizeof(SPHERE_TYPE)));

	movzx	eax, BYTE PTR _index$[ebp]
	imul	eax, 24					; 00000018H
	add	eax, 8459560				; 00811528H
$LN2@GetSphereF:

; 41   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSphereFromIndex@@YAPAUSPHERE_TYPE@@E@Z ENDP		; GetSphereFromIndex
_TEXT	ENDS
PUBLIC	?GetFreeSphereIndex@@YAEXZ			; GetFreeSphereIndex
EXTRN	__RTC_CheckEsp:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?GetFreeSphereIndex@@YAEXZ
_TEXT	SEGMENT
_pSphere$209275 = -20					; size = 4
_i$209271 = -5						; size = 1
?GetFreeSphereIndex@@YAEXZ PROC				; GetFreeSphereIndex, COMDAT

; 44   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 45   : 	for(EntityId i = 0; i < MAX_SPHERES; i++)

	mov	BYTE PTR _i$209271[ebp], 0
	jmp	SHORT $LN4@GetFreeSph
$LN3@GetFreeSph:
	mov	al, BYTE PTR _i$209271[ebp]
	add	al, 1
	mov	BYTE PTR _i$209271[ebp], al
$LN4@GetFreeSph:
	movzx	eax, BYTE PTR _i$209271[ebp]
	cmp	eax, 16					; 00000010H
	jge	SHORT $LN2@GetFreeSph

; 46   : 	{
; 47   : 		SPHERE_TYPE * pSphere = GetSphereFromIndex(i);

	movzx	eax, BYTE PTR _i$209271[ebp]
	push	eax
	call	?GetSphereFromIndex@@YAPAUSPHERE_TYPE@@E@Z ; GetSphereFromIndex
	add	esp, 4
	mov	DWORD PTR _pSphere$209275[ebp], eax

; 48   : 
; 49   : 		if(pSphere && pSphere->byteInUse == 0)

	cmp	DWORD PTR _pSphere$209275[ebp], 0
	je	SHORT $LN1@GetFreeSph
	mov	eax, DWORD PTR _pSphere$209275[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN1@GetFreeSph

; 50   : 		{
; 51   : 			return i;

	mov	al, BYTE PTR _i$209271[ebp]
	jmp	SHORT $LN5@GetFreeSph
$LN1@GetFreeSph:

; 52   : 		}
; 53   : 	}

	jmp	SHORT $LN3@GetFreeSph
$LN2@GetFreeSph:

; 54   : 
; 55   : 	return 0xFF;

	or	al, 255					; 000000ffH
$LN5@GetFreeSph:

; 56   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFreeSphereIndex@@YAEXZ ENDP				; GetFreeSphereIndex
_TEXT	ENDS
PUBLIC	?CreateSphere@@YAEPAUVector3@@M@Z		; CreateSphere
EXTRN	_memcpy:PROC
EXTRN	__fltused:DWORD
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?CreateSphere@@YAEPAUVector3@@M@Z
_TEXT	SEGMENT
_pSphere$209283 = -20					; size = 4
_index$ = -5						; size = 1
_vecCenter$ = 8						; size = 4
_fRadius$ = 12						; size = 4
?CreateSphere@@YAEPAUVector3@@M@Z PROC			; CreateSphere, COMDAT

; 59   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 60   : 	EntityId index = GetFreeSphereIndex();

	call	?GetFreeSphereIndex@@YAEXZ		; GetFreeSphereIndex
	mov	BYTE PTR _index$[ebp], al

; 61   : 
; 62   : 	if(index != 0xFF)

	movzx	eax, BYTE PTR _index$[ebp]
	cmp	eax, 255				; 000000ffH
	je	SHORT $LN1@CreateSphe

; 63   : 	{
; 64   : 		SPHERE_TYPE * pSphere = GetSphereFromIndex(index);

	movzx	eax, BYTE PTR _index$[ebp]
	push	eax
	call	?GetSphereFromIndex@@YAPAUSPHERE_TYPE@@E@Z ; GetSphereFromIndex
	add	esp, 4
	mov	DWORD PTR _pSphere$209283[ebp], eax

; 65   : 		pSphere->byteInUse = 1;

	mov	eax, DWORD PTR _pSphere$209283[ebp]
	mov	BYTE PTR [eax], 1

; 66   : 		pSphere->dwUniqueId = (index + 0xDEADBEEF);

	movzx	eax, BYTE PTR _index$[ebp]
	sub	eax, 559038737				; 21524111H
	mov	ecx, DWORD PTR _pSphere$209283[ebp]
	mov	DWORD PTR [ecx+4], eax

; 67   : 		memcpy(&pSphere->vecCenter, vecCenter, sizeof(Vector3));

	push	12					; 0000000cH
	mov	eax, DWORD PTR _vecCenter$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pSphere$209283[ebp]
	add	ecx, 8
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 68   : 		pSphere->fRadius = fRadius;

	mov	eax, DWORD PTR _pSphere$209283[ebp]
	fld	DWORD PTR _fRadius$[ebp]
	fstp	DWORD PTR [eax+20]
$LN1@CreateSphe:

; 69   : 	}
; 70   : 
; 71   : 	return index;

	mov	al, BYTE PTR _index$[ebp]

; 72   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?CreateSphere@@YAEPAUVector3@@M@Z ENDP			; CreateSphere
_TEXT	ENDS
PUBLIC	?sqrt@@YAMM@Z					; sqrt
PUBLIC	?GetDistanceBetweenPoints3D@@YAMMMMMMM@Z	; GetDistanceBetweenPoints3D
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?GetDistanceBetweenPoints3D@@YAMMMMMMM@Z
_TEXT	SEGMENT
tv131 = -232						; size = 4
_newz$ = -32						; size = 4
_newy$ = -20						; size = 4
_newx$ = -8						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_z$ = 16						; size = 4
_xx$ = 20						; size = 4
_yy$ = 24						; size = 4
_zz$ = 28						; size = 4
?GetDistanceBetweenPoints3D@@YAMMMMMMM@Z PROC		; GetDistanceBetweenPoints3D, COMDAT

; 75   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 76   :     float newx = (xx - x);

	fld	DWORD PTR _xx$[ebp]
	fsub	DWORD PTR _x$[ebp]
	fstp	DWORD PTR _newx$[ebp]

; 77   :     float newy = (yy - y);

	fld	DWORD PTR _yy$[ebp]
	fsub	DWORD PTR _y$[ebp]
	fstp	DWORD PTR _newy$[ebp]

; 78   :     float newz = (zz - z);

	fld	DWORD PTR _zz$[ebp]
	fsub	DWORD PTR _z$[ebp]
	fstp	DWORD PTR _newz$[ebp]

; 79   :     return sqrt(newx * newx + newy * newy + newz * newz);

	fld	DWORD PTR _newx$[ebp]
	fmul	DWORD PTR _newx$[ebp]
	fld	DWORD PTR _newy$[ebp]
	fmul	DWORD PTR _newy$[ebp]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _newz$[ebp]
	fmul	DWORD PTR _newz$[ebp]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR tv131[ebp]
	fld	DWORD PTR tv131[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4

; 80   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDistanceBetweenPoints3D@@YAMMMMMMM@Z ENDP		; GetDistanceBetweenPoints3D
_TEXT	ENDS
PUBLIC	??0Vector3@@QAE@XZ				; Vector3::Vector3
PUBLIC	??0CCheckpoint@@QAE@EUVector3@@EM@Z		; CCheckpoint::CCheckpoint
EXTRN	?ShowMarker@CGame@@QAEXHH@Z:PROC		; CGame::ShowMarker
EXTRN	?SetMarkerColor@CGame@@QAEXHH@Z:PROC		; CGame::SetMarkerColor
EXTRN	?pGame@@3PAVCGame@@A:DWORD			; pGame
EXTRN	?ScriptCommand@@YAHPBUSCRIPT_COMMAND@@ZZ:PROC	; ScriptCommand
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0CCheckpoint@@QAE@EUVector3@@EM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_id$ = 8						; size = 1
_vecPos$ = 12						; size = 12
_type$ = 24						; size = 1
_radius$ = 28						; size = 4
??0CCheckpoint@@QAE@EUVector3@@EM@Z PROC		; CCheckpoint::CCheckpoint, COMDAT
; _this$ = ecx

; 84   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0Vector3@@QAE@XZ			; Vector3::Vector3

; 85   : 	m_iID = id;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _id$[ebp]
	mov	BYTE PTR [eax], cl

; 86   : 	memcpy(&m_vecPos, &vecPos, sizeof(Vector3));

	push	12					; 0000000cH
	lea	eax, DWORD PTR _vecPos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 87   : 	m_byteType = type;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _type$[ebp]
	mov	BYTE PTR [eax+28], cl

; 88   : 	m_fRadius = radius;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _radius$[ebp]
	fstp	DWORD PTR [eax+24]

; 89   : 	m_sphereID = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+8], 0

; 90   : 	m_dwMarker = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 91   : 	m_bInCP = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+29], 0

; 92   : 	m_sphereID = CreateSphere(&vecPos, radius);

	push	ecx
	fld	DWORD PTR _radius$[ebp]
	fstp	DWORD PTR [esp]
	lea	eax, DWORD PTR _vecPos$[ebp]
	push	eax
	call	?CreateSphere@@YAEPAUVector3@@M@Z	; CreateSphere
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+8], al

; 93   : 	ScriptCommand(&create_icon_marker_without_sphere, vecPos.X, vecPos.Y, vecPos.Z, 0, &m_dwMarker);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	push	0
	fld	DWORD PTR _vecPos$[ebp+8]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	fld	DWORD PTR _vecPos$[ebp+4]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	fld	DWORD PTR _vecPos$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET _create_icon_marker_without_sphere
	call	?ScriptCommand@@YAHPBUSCRIPT_COMMAND@@ZZ ; ScriptCommand
	add	esp, 36					; 00000024H

; 94   : 	ScriptCommand(&set_marker_color, m_dwMarker, 5);

	push	5
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	OFFSET _set_marker_color
	call	?ScriptCommand@@YAHPBUSCRIPT_COMMAND@@ZZ ; ScriptCommand
	add	esp, 12					; 0000000cH

; 95   : 	pGame->SetMarkerColor(m_dwMarker, 5);

	push	5
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR ?pGame@@3PAVCGame@@A	; pGame
	call	?SetMarkerColor@CGame@@QAEXHH@Z		; CGame::SetMarkerColor

; 96   : 	pGame->ShowMarker(m_dwMarker, 2);

	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR ?pGame@@3PAVCGame@@A	; pGame
	call	?ShowMarker@CGame@@QAEXHH@Z		; CGame::ShowMarker

; 97   : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
??0CCheckpoint@@QAE@EUVector3@@EM@Z ENDP		; CCheckpoint::CCheckpoint
_TEXT	ENDS
PUBLIC	??1CCheckpoint@@QAE@XZ				; CCheckpoint::~CCheckpoint
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1CCheckpoint@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1CCheckpoint@@QAE@XZ PROC				; CCheckpoint::~CCheckpoint, COMDAT
; _this$ = ecx

; 100  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 101  : 	GetSphereFromIndex(m_sphereID)->byteInUse = 0;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+8]
	push	ecx
	call	?GetSphereFromIndex@@YAPAUSPHERE_TYPE@@E@Z ; GetSphereFromIndex
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 102  : 	if(m_dwMarker != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN2@CCheckpoin

; 103  : 	{
; 104  : 		ScriptCommand(&disable_marker, m_dwMarker);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	OFFSET _disable_marker
	call	?ScriptCommand@@YAHPBUSCRIPT_COMMAND@@ZZ ; ScriptCommand
	add	esp, 8
$LN2@CCheckpoin:

; 105  : 	}
; 106  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1CCheckpoint@@QAE@XZ ENDP				; CCheckpoint::~CCheckpoint
_TEXT	ENDS
PUBLIC	?GetRPC4@CNetworkManager@@QAEPAVRPC4@RakNet@@XZ	; CNetworkManager::GetRPC4
PUBLIC	??_C@_0BA@KEGPEPAN@CheckpointEvent?$AA@		; `string'
PUBLIC	??0AddressOrGUID@RakNet@@QAE@ABUSystemAddress@1@@Z ; RakNet::AddressOrGUID::AddressOrGUID
PUBLIC	??$Write@_N@BitStream@RakNet@@QAEXAB_N@Z	; RakNet::BitStream::Write<bool>
PUBLIC	??$Write@E@BitStream@RakNet@@QAEXABE@Z		; RakNet::BitStream::Write<unsigned char>
PUBLIC	?FindPlayerPed@CGame@@QAEPAVCPlayerPed@@XZ	; CGame::FindPlayerPed
PUBLIC	__$ArrayPad$
PUBLIC	?Process@CCheckpoint@@QAEXXZ			; CCheckpoint::Process
EXTRN	??1BitStream@RakNet@@QAE@XZ:PROC		; RakNet::BitStream::~BitStream
EXTRN	?Call@RPC4@RakNet@@QAEXPBDPAVBitStream@2@W4PacketPriority@@W4PacketReliability@@DUAddressOrGUID@2@_N@Z:PROC ; RakNet::RPC4::Call
EXTRN	?pNetowkManager@@3PAVCNetworkManager@@A:DWORD	; pNetowkManager
EXTRN	??0BitStream@RakNet@@QAE@XZ:PROC		; RakNet::BitStream::BitStream
EXTRN	?GetPosition@CEntity@@QAEXPAUVector3@@@Z:PROC	; CEntity::GetPosition
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
;	COMDAT ??_C@_0BA@KEGPEPAN@CheckpointEvent?$AA@
CONST	SEGMENT
??_C@_0BA@KEGPEPAN@CheckpointEvent?$AA@ DB 'CheckpointEvent', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Process@CCheckpoint@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Process@CCheckpoint@@QAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Process@CCheckpoint@@QAEXXZ$1
__ehfuncinfo$?Process@CCheckpoint@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?Process@CCheckpoint@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCsu /ZI
xdata$x	ENDS
;	COMDAT ?Process@CCheckpoint@@QAEXXZ
_TEXT	SEGMENT
$T209447 = -861						; size = 1
$T209448 = -852						; size = 4
$T209449 = -837						; size = 1
$T209450 = -828						; size = 4
_bsSend$209324 = -624					; size = 276
_bsSend$209315 = -340					; size = 276
_vecPos$ = -56						; size = 12
_pPlayer$ = -36						; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?Process@CCheckpoint@@QAEXXZ PROC			; CCheckpoint::Process, COMDAT
; _this$ = ecx

; 109  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Process@CCheckpoint@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 856				; 00000358H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-868]
	mov	ecx, 214				; 000000d6H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 110  : 	CPlayerPed * pPlayer = pGame->FindPlayerPed();

	mov	ecx, DWORD PTR ?pGame@@3PAVCGame@@A	; pGame
	call	?FindPlayerPed@CGame@@QAEPAVCPlayerPed@@XZ ; CGame::FindPlayerPed
	mov	DWORD PTR _pPlayer$[ebp], eax

; 111  : 	Vector3 vecPos;

	lea	ecx, DWORD PTR _vecPos$[ebp]
	call	??0Vector3@@QAE@XZ			; Vector3::Vector3

; 112  : 	pPlayer->GetPosition(&vecPos);

	lea	eax, DWORD PTR _vecPos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetPosition@CEntity@@QAEXPAUVector3@@@Z ; CEntity::GetPosition

; 113  : 
; 114  : 	if(GetDistanceBetweenPoints3D(vecPos.X, vecPos.Y, vecPos.Z, m_vecPos.X, m_vecPos.Y, m_vecPos.Z) < m_fRadius)

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [eax+20]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [ecx+16]
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [edx+12]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _vecPos$[ebp+8]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _vecPos$[ebp+4]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _vecPos$[ebp]
	fstp	DWORD PTR [esp]
	call	?GetDistanceBetweenPoints3D@@YAMMMMMMM@Z ; GetDistanceBetweenPoints3D
	add	esp, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+24]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$LN4@Process

; 115  : 	{
; 116  : 		if(!m_bInCP)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+29]
	test	ecx, ecx
	jne	$LN3@Process

; 117  : 		{
; 118  : 			BitStream bsSend;

	lea	ecx, DWORD PTR _bsSend$209315[ebp]
	call	??0BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::BitStream
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 119  : 			bsSend.Write(m_iID);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR _bsSend$209315[ebp]
	call	??$Write@E@BitStream@RakNet@@QAEXABE@Z	; RakNet::BitStream::Write<unsigned char>

; 120  : 			bsSend.Write(true);

	mov	BYTE PTR $T209447[ebp], 1
	lea	eax, DWORD PTR $T209447[ebp]
	push	eax
	lea	ecx, DWORD PTR _bsSend$209315[ebp]
	call	??$Write@_N@BitStream@RakNet@@QAEXAB_N@Z ; RakNet::BitStream::Write<bool>

; 121  : 			pNetowkManager->GetRPC4()->Call("CheckpointEvent", &bsSend, HIGH_PRIORITY, RELIABLE, 0, UNASSIGNED_SYSTEM_ADDRESS, true);

	push	1
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	mov	DWORD PTR $T209448[ebp], esp
	push	OFFSET _UNASSIGNED_SYSTEM_ADDRESS
	call	??0AddressOrGUID@RakNet@@QAE@ABUSystemAddress@1@@Z ; RakNet::AddressOrGUID::AddressOrGUID
	push	0
	push	2
	push	1
	lea	eax, DWORD PTR _bsSend$209315[ebp]
	push	eax
	push	OFFSET ??_C@_0BA@KEGPEPAN@CheckpointEvent?$AA@
	mov	ecx, DWORD PTR ?pNetowkManager@@3PAVCNetworkManager@@A ; pNetowkManager
	call	?GetRPC4@CNetworkManager@@QAEPAVRPC4@RakNet@@XZ ; CNetworkManager::GetRPC4
	mov	ecx, eax
	call	?Call@RPC4@RakNet@@QAEXPBDPAVBitStream@2@W4PacketPriority@@W4PacketReliability@@DUAddressOrGUID@2@_N@Z ; RakNet::RPC4::Call

; 122  : 			m_bInCP = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+29], 1

; 123  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _bsSend$209315[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
$LN3@Process:

; 124  : 	}
; 125  : 	else

	jmp	$LN1@Process
$LN4@Process:

; 126  : 	{
; 127  : 		if(m_bInCP)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+29]
	test	ecx, ecx
	je	$LN1@Process

; 128  : 		{
; 129  : 			BitStream bsSend;

	lea	ecx, DWORD PTR _bsSend$209324[ebp]
	call	??0BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::BitStream
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 130  : 			bsSend.Write(m_iID);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR _bsSend$209324[ebp]
	call	??$Write@E@BitStream@RakNet@@QAEXABE@Z	; RakNet::BitStream::Write<unsigned char>

; 131  : 			bsSend.Write(false);

	mov	BYTE PTR $T209449[ebp], 0
	lea	eax, DWORD PTR $T209449[ebp]
	push	eax
	lea	ecx, DWORD PTR _bsSend$209324[ebp]
	call	??$Write@_N@BitStream@RakNet@@QAEXAB_N@Z ; RakNet::BitStream::Write<bool>

; 132  : 			pNetowkManager->GetRPC4()->Call("CheckpointEvent", &bsSend, HIGH_PRIORITY, RELIABLE, 0, UNASSIGNED_SYSTEM_ADDRESS, true);

	push	1
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	mov	DWORD PTR $T209450[ebp], esp
	push	OFFSET _UNASSIGNED_SYSTEM_ADDRESS
	call	??0AddressOrGUID@RakNet@@QAE@ABUSystemAddress@1@@Z ; RakNet::AddressOrGUID::AddressOrGUID
	push	0
	push	2
	push	1
	lea	eax, DWORD PTR _bsSend$209324[ebp]
	push	eax
	push	OFFSET ??_C@_0BA@KEGPEPAN@CheckpointEvent?$AA@
	mov	ecx, DWORD PTR ?pNetowkManager@@3PAVCNetworkManager@@A ; pNetowkManager
	call	?GetRPC4@CNetworkManager@@QAEPAVRPC4@RakNet@@XZ ; CNetworkManager::GetRPC4
	mov	ecx, eax
	call	?Call@RPC4@RakNet@@QAEXPBDPAVBitStream@2@W4PacketPriority@@W4PacketReliability@@DUAddressOrGUID@2@_N@Z ; RakNet::RPC4::Call

; 133  : 			m_bInCP = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+29], 0

; 134  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _bsSend$209324[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
$LN1@Process:

; 135  : 	}
; 136  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN14@Process
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 868				; 00000364H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN14@Process:
	DD	3
	DD	$LN13@Process
$LN13@Process:
	DD	-56					; ffffffc8H
	DD	12					; 0000000cH
	DD	$LN9@Process
	DD	-340					; fffffeacH
	DD	276					; 00000114H
	DD	$LN10@Process
	DD	-624					; fffffd90H
	DD	276					; 00000114H
	DD	$LN11@Process
$LN11@Process:
	DB	98					; 00000062H
	DB	115					; 00000073H
	DB	83					; 00000053H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	0
$LN10@Process:
	DB	98					; 00000062H
	DB	115					; 00000073H
	DB	83					; 00000053H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	0
$LN9@Process:
	DB	118					; 00000076H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	80					; 00000050H
	DB	111					; 0000006fH
	DB	115					; 00000073H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Process@CCheckpoint@@QAEXXZ$0:
	lea	ecx, DWORD PTR _bsSend$209315[ebp]
	jmp	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
__unwindfunclet$?Process@CCheckpoint@@QAEXXZ$1:
	lea	ecx, DWORD PTR _bsSend$209324[ebp]
	jmp	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
__ehhandler$?Process@CCheckpoint@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-872]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Process@CCheckpoint@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Process@CCheckpoint@@QAEXXZ ENDP			; CCheckpoint::Process
PUBLIC	??0CCheckpoints@@QAE@XZ				; CCheckpoints::CCheckpoints
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0CCheckpoints@@QAE@XZ
_TEXT	SEGMENT
_id$209330 = -17					; size = 1
_this$ = -8						; size = 4
??0CCheckpoints@@QAE@XZ PROC				; CCheckpoints::CCheckpoints, COMDAT
; _this$ = ecx

; 139  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 	for(EntityId id = 0; id < MAX_CPS; id++)

	mov	BYTE PTR _id$209330[ebp], 0
	jmp	SHORT $LN3@CCheckpoin@2
$LN2@CCheckpoin@2:
	mov	al, BYTE PTR _id$209330[ebp]
	add	al, 1
	mov	BYTE PTR _id$209330[ebp], al
$LN3@CCheckpoin@2:
	movzx	eax, BYTE PTR _id$209330[ebp]
	cmp	eax, 16					; 00000010H
	jge	SHORT $LN4@CCheckpoin@2

; 141  : 	{
; 142  : 		m_Checkpoints[id] = NULL;

	movzx	eax, BYTE PTR _id$209330[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4], 0

; 143  : 		m_bSlotState[id] = false;

	movzx	eax, BYTE PTR _id$209330[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+eax+64], 0
	jmp	SHORT $LN2@CCheckpoin@2
$LN4@CCheckpoin@2:

; 144  : 	}
; 145  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CCheckpoints@@QAE@XZ ENDP				; CCheckpoints::CCheckpoints
_TEXT	ENDS
PUBLIC	??1CCheckpoints@@QAE@XZ				; CCheckpoints::~CCheckpoints
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1CCheckpoints@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1CCheckpoints@@QAE@XZ PROC				; CCheckpoints::~CCheckpoints, COMDAT
; _this$ = ecx

; 148  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 149  : 	
; 150  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1CCheckpoints@@QAE@XZ ENDP				; CCheckpoints::~CCheckpoints
_TEXT	ENDS
PUBLIC	?Delete@CCheckpoints@@QAEXE@Z			; CCheckpoints::Delete
PUBLIC	?GetSlotState@CCheckpoints@@QAE_NE@Z		; CCheckpoints::GetSlotState
PUBLIC	?New@CCheckpoints@@QAEXEUVector3@@EM@Z		; CCheckpoints::New
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??2@YAPAXI@Z:PROC				; operator new
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?New@CCheckpoints@@QAEXEUVector3@@EM@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?New@CCheckpoints@@QAEXEUVector3@@EM@Z$0
__ehfuncinfo$?New@CCheckpoints@@QAEXEUVector3@@EM@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?New@CCheckpoints@@QAEXEUVector3@@EM@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCsu /ZI
xdata$x	ENDS
;	COMDAT ?New@CCheckpoints@@QAEXEUVector3@@EM@Z
_TEXT	SEGMENT
tv85 = -244						; size = 4
$T209476 = -236						; size = 4
$T209477 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
_id$ = 8						; size = 1
_vecPos$ = 12						; size = 12
_type$ = 24						; size = 1
_radius$ = 28						; size = 4
?New@CCheckpoints@@QAEXEUVector3@@EM@Z PROC		; CCheckpoints::New, COMDAT
; _this$ = ecx

; 153  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?New@CCheckpoints@@QAEXEUVector3@@EM@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 154  : 	if(GetSlotState(id) == true) 

	movzx	eax, BYTE PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSlotState@CCheckpoints@@QAE_NE@Z	; CCheckpoints::GetSlotState
	movzx	ecx, al
	cmp	ecx, 1
	jne	SHORT $LN2@New

; 155  : 	{
; 156  : 		Delete(id);

	movzx	eax, BYTE PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Delete@CCheckpoints@@QAEXE@Z		; CCheckpoints::Delete
$LN2@New:

; 157  : 	}
; 158  : 
; 159  : 	m_Checkpoints[id] = new CCheckpoint(id, vecPos, type, radius);

	push	32					; 00000020H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T209477[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T209477[ebp], 0
	je	SHORT $LN5@New
	push	ecx
	fld	DWORD PTR _radius$[ebp]
	fstp	DWORD PTR [esp]
	movzx	eax, BYTE PTR _type$[ebp]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR _vecPos$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _vecPos$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _vecPos$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	movzx	eax, BYTE PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T209477[ebp]
	call	??0CCheckpoint@@QAE@EUVector3@@EM@Z	; CCheckpoint::CCheckpoint
	mov	DWORD PTR tv85[ebp], eax
	jmp	SHORT $LN6@New
$LN5@New:
	mov	DWORD PTR tv85[ebp], 0
$LN6@New:
	mov	ecx, DWORD PTR tv85[ebp]
	mov	DWORD PTR $T209476[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	movzx	edx, BYTE PTR _id$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T209476[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 160  : 	if(m_Checkpoints[id])

	movzx	eax, BYTE PTR _id$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	je	SHORT $LN1@New

; 161  : 	{
; 162  : 		m_bSlotState[id] = true;

	movzx	eax, BYTE PTR _id$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+eax+64], 1
$LN1@New:

; 163  : 	}
; 164  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?New@CCheckpoints@@QAEXEUVector3@@EM@Z$0:
	mov	eax, DWORD PTR $T209477[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?New@CCheckpoints@@QAEXEUVector3@@EM@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-248]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?New@CCheckpoints@@QAEXEUVector3@@EM@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?New@CCheckpoints@@QAEXEUVector3@@EM@Z ENDP		; CCheckpoints::New
PUBLIC	??_GCCheckpoint@@QAEPAXI@Z			; CCheckpoint::`scalar deleting destructor'
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?Delete@CCheckpoints@@QAEXE@Z
_TEXT	SEGMENT
tv76 = -232						; size = 4
$T209489 = -224						; size = 4
$T209490 = -212						; size = 4
_this$ = -8						; size = 4
_id$ = 8						; size = 1
?Delete@CCheckpoints@@QAEXE@Z PROC			; CCheckpoints::Delete, COMDAT
; _this$ = ecx

; 167  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 168  : 	if(m_bSlotState[id] == false) return;

	movzx	eax, BYTE PTR _id$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+64]
	test	edx, edx
	jne	SHORT $LN1@Delete
	jmp	SHORT $LN2@Delete
$LN1@Delete:

; 169  : 	delete m_Checkpoints[id];

	movzx	eax, BYTE PTR _id$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T209490[ebp], edx
	mov	eax, DWORD PTR $T209490[ebp]
	mov	DWORD PTR $T209489[ebp], eax
	cmp	DWORD PTR $T209489[ebp], 0
	je	SHORT $LN4@Delete
	push	1
	mov	ecx, DWORD PTR $T209489[ebp]
	call	??_GCCheckpoint@@QAEPAXI@Z
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN5@Delete
$LN4@Delete:
	mov	DWORD PTR tv76[ebp], 0
$LN5@Delete:

; 170  : 	m_Checkpoints[id] = NULL;

	movzx	eax, BYTE PTR _id$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4], 0

; 171  : 	m_bSlotState[id] = false;

	movzx	eax, BYTE PTR _id$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+eax+64], 0
$LN2@Delete:

; 172  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Delete@CCheckpoints@@QAEXE@Z ENDP			; CCheckpoints::Delete
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ??_GCCheckpoint@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_GCCheckpoint@@QAEPAXI@Z PROC				; CCheckpoint::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CCheckpoint@@QAE@XZ			; CCheckpoint::~CCheckpoint
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCCheckpoint@@QAEPAXI@Z ENDP				; CCheckpoint::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?Process@CCheckpoints@@QAEXXZ			; CCheckpoints::Process
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?Process@CCheckpoints@@QAEXXZ
_TEXT	SEGMENT
_id$209364 = -17					; size = 1
_this$ = -8						; size = 4
?Process@CCheckpoints@@QAEXXZ PROC			; CCheckpoints::Process, COMDAT
; _this$ = ecx

; 175  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 176  : 	for(EntityId id = 0; id < MAX_CPS; id++)

	mov	BYTE PTR _id$209364[ebp], 0
	jmp	SHORT $LN4@Process@2
$LN3@Process@2:
	mov	al, BYTE PTR _id$209364[ebp]
	add	al, 1
	mov	BYTE PTR _id$209364[ebp], al
$LN4@Process@2:
	movzx	eax, BYTE PTR _id$209364[ebp]
	cmp	eax, 16					; 00000010H
	jge	SHORT $LN5@Process@2

; 177  : 	{
; 178  : 		if(!GetSlotState(id)) continue;

	movzx	eax, BYTE PTR _id$209364[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSlotState@CCheckpoints@@QAE_NE@Z	; CCheckpoints::GetSlotState
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@Process@2
	jmp	SHORT $LN3@Process@2
$LN1@Process@2:

; 179  : 		m_Checkpoints[id]->Process();

	movzx	eax, BYTE PTR _id$209364[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]
	call	?Process@CCheckpoint@@QAEXXZ		; CCheckpoint::Process
	jmp	SHORT $LN3@Process@2
$LN5@Process@2:

; 180  : 	}
; 181  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Process@CCheckpoints@@QAEXXZ ENDP			; CCheckpoints::Process
_TEXT	ENDS
PUBLIC	?DoEndianSwap@BitStream@RakNet@@SA_NXZ		; RakNet::BitStream::DoEndianSwap
EXTRN	?ReverseBytes@BitStream@RakNet@@SAXPAE0I@Z:PROC	; RakNet::BitStream::ReverseBytes
EXTRN	?WriteBits@BitStream@RakNet@@QAEXPBEI_N@Z:PROC	; RakNet::BitStream::WriteBits
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\vice-players-master\raknet\bitstream.h
;	COMDAT ??$Write@E@BitStream@RakNet@@QAEXABE@Z
_TEXT	SEGMENT
_output$209377 = -17					; size = 1
_this$ = -8						; size = 4
_inTemplateVar$ = 8					; size = 4
??$Write@E@BitStream@RakNet@@QAEXABE@Z PROC		; RakNet::BitStream::Write<unsigned char>, COMDAT
; _this$ = ecx

; 1055 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1056 : #ifdef _MSC_VER
; 1057 : #pragma warning(disable:4127)   // conditional expression is constant
; 1058 : #endif
; 1059 : 		if (sizeof(inTemplateVar)==1)

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN4@Write

; 1060 : 			WriteBits( ( unsigned char* ) & inTemplateVar, sizeof( templateType ) * 8, true );

	push	1
	push	8
	mov	eax, DWORD PTR _inTemplateVar$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteBits@BitStream@RakNet@@QAEXPBEI_N@Z ; RakNet::BitStream::WriteBits

; 1061 : 		else

	jmp	SHORT $LN5@Write
$LN4@Write:

; 1062 : 		{
; 1063 : #ifndef __BITSTREAM_NATIVE_END
; 1064 : 			if (DoEndianSwap())

	call	?DoEndianSwap@BitStream@RakNet@@SA_NXZ	; RakNet::BitStream::DoEndianSwap
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Write

; 1065 : 			{
; 1066 : 				unsigned char output[sizeof(templateType)];
; 1067 : 				ReverseBytes((unsigned char*)&inTemplateVar, output, sizeof(templateType));

	push	1
	lea	eax, DWORD PTR _output$209377[ebp]
	push	eax
	mov	ecx, DWORD PTR _inTemplateVar$[ebp]
	push	ecx
	call	?ReverseBytes@BitStream@RakNet@@SAXPAE0I@Z ; RakNet::BitStream::ReverseBytes
	add	esp, 12					; 0000000cH

; 1068 : 				WriteBits( ( unsigned char* ) output, sizeof(templateType) * 8, true );

	push	1
	push	8
	lea	eax, DWORD PTR _output$209377[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteBits@BitStream@RakNet@@QAEXPBEI_N@Z ; RakNet::BitStream::WriteBits

; 1069 : 			}
; 1070 : 			else

	jmp	SHORT $LN5@Write
$LN2@Write:

; 1071 : #endif
; 1072 : 				WriteBits( ( unsigned char* ) & inTemplateVar, sizeof(templateType) * 8, true );

	push	1
	push	8
	mov	eax, DWORD PTR _inTemplateVar$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteBits@BitStream@RakNet@@QAEXPBEI_N@Z ; RakNet::BitStream::WriteBits
$LN5@Write:

; 1073 : 		}
; 1074 : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@Write
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN9@Write:
	DD	1
	DD	$LN8@Write
$LN8@Write:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN7@Write
$LN7@Write:
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	112					; 00000070H
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	0
??$Write@E@BitStream@RakNet@@QAEXABE@Z ENDP		; RakNet::BitStream::Write<unsigned char>
_TEXT	ENDS
PUBLIC	_sqrtf
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\math.h
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?sqrt@@YAMM@Z PROC					; sqrt, COMDAT

; 534  :         {return (sqrtf(_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	ecx
	fld	DWORD PTR __X$[ebp]
	fstp	DWORD PTR [esp]
	call	_sqrtf
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?sqrt@@YAMM@Z ENDP					; sqrt
_TEXT	ENDS
EXTRN	_sqrt:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv73 = -196						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC						; COMDAT

; 423  :         {return ((float)sqrt((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	fld	DWORD PTR __X$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR tv73[ebp]
	fld	DWORD PTR tv73[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_sqrtf	ENDP
_TEXT	ENDS
PUBLIC	__real@00000000
;	COMDAT __real@00000000
; File d:\vice-players-master\client\game\common.h
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ??0Vector3@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0Vector3@@QAE@XZ PROC					; Vector3::Vector3, COMDAT
; _this$ = ecx

; 34   : 	Vector3()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 	{
; 36   : 		X = Y = Z = 0;

	mov	eax, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [edx]

; 37   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector3@@QAE@XZ ENDP					; Vector3::Vector3
_TEXT	ENDS
EXTRN	??0CPlayerPed@@QAE@XZ:PROC			; CPlayerPed::CPlayerPed
;	COMDAT xdata$x
; File d:\vice-players-master\client\game\cgame.h
xdata$x	SEGMENT
__unwindtable$?FindPlayerPed@CGame@@QAEPAVCPlayerPed@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FindPlayerPed@CGame@@QAEPAVCPlayerPed@@XZ$0
__ehfuncinfo$?FindPlayerPed@CGame@@QAEPAVCPlayerPed@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?FindPlayerPed@CGame@@QAEPAVCPlayerPed@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCsu /ZI
xdata$x	ENDS
;	COMDAT ?FindPlayerPed@CGame@@QAEPAVCPlayerPed@@XZ
_TEXT	SEGMENT
tv74 = -244						; size = 4
$T209512 = -236						; size = 4
$T209513 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?FindPlayerPed@CGame@@QAEPAVCPlayerPed@@XZ PROC		; CGame::FindPlayerPed, COMDAT
; _this$ = ecx

; 101  : 	CPlayerPed  *FindPlayerPed() {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?FindPlayerPed@CGame@@QAEPAVCPlayerPed@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 102  : 		if(m_pInternalPlayer==NULL)	m_pInternalPlayer = new CPlayerPed();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN1@FindPlayer
	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T209513[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T209513[ebp], 0
	je	SHORT $LN4@FindPlayer
	mov	ecx, DWORD PTR $T209513[ebp]
	call	??0CPlayerPed@@QAE@XZ			; CPlayerPed::CPlayerPed
	mov	DWORD PTR tv74[ebp], eax
	jmp	SHORT $LN5@FindPlayer
$LN4@FindPlayer:
	mov	DWORD PTR tv74[ebp], 0
$LN5@FindPlayer:
	mov	eax, DWORD PTR tv74[ebp]
	mov	DWORD PTR $T209512[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T209512[ebp]
	mov	DWORD PTR [ecx+4], edx
$LN1@FindPlayer:

; 103  : 		return m_pInternalPlayer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 104  : 	};

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FindPlayerPed@CGame@@QAEPAVCPlayerPed@@XZ$0:
	mov	eax, DWORD PTR $T209513[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?FindPlayerPed@CGame@@QAEPAVCPlayerPed@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-248]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?FindPlayerPed@CGame@@QAEPAVCPlayerPed@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?FindPlayerPed@CGame@@QAEPAVCPlayerPed@@XZ ENDP		; CGame::FindPlayerPed
PUBLIC	??4SystemAddress@RakNet@@QAEAAU01@ABU01@@Z	; RakNet::SystemAddress::operator=
PUBLIC	??4RakNetGUID@RakNet@@QAEAAU01@ABU01@@Z		; RakNet::RakNetGUID::operator=
PUBLIC	??0RakNetGUID@RakNet@@QAE@XZ			; RakNet::RakNetGUID::RakNetGUID
EXTRN	??0SystemAddress@RakNet@@QAE@XZ:PROC		; RakNet::SystemAddress::SystemAddress
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\vice-players-master\raknet\raknettypes.h
;	COMDAT ??0AddressOrGUID@RakNet@@QAE@ABUSystemAddress@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_input$ = 8						; size = 4
??0AddressOrGUID@RakNet@@QAE@ABUSystemAddress@1@@Z PROC	; RakNet::AddressOrGUID::AddressOrGUID, COMDAT
; _this$ = ecx

; 220  : 	AddressOrGUID( const SystemAddress& input )

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0RakNetGUID@RakNet@@QAE@XZ		; RakNet::RakNetGUID::RakNetGUID
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??0SystemAddress@RakNet@@QAE@XZ		; RakNet::SystemAddress::SystemAddress

; 221  : 	{
; 222  : 		rakNetGuid=UNASSIGNED_RAKNET_GUID;

	push	OFFSET _UNASSIGNED_RAKNET_GUID
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4RakNetGUID@RakNet@@QAEAAU01@ABU01@@Z	; RakNet::RakNetGUID::operator=

; 223  : 		systemAddress=input;

	mov	eax, DWORD PTR _input$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??4SystemAddress@RakNet@@QAEAAU01@ABU01@@Z ; RakNet::SystemAddress::operator=

; 224  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0AddressOrGUID@RakNet@@QAE@ABUSystemAddress@1@@Z ENDP	; RakNet::AddressOrGUID::AddressOrGUID
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ??4SystemAddress@RakNet@@QAEAAU01@ABU01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_input$ = 8						; size = 4
??4SystemAddress@RakNet@@QAEAAU01@ABU01@@Z PROC		; RakNet::SystemAddress::operator=, COMDAT
; _this$ = ecx

; 139  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		binaryAddress = input.binaryAddress;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _input$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 141  : 		port = input.port;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _input$[ebp]
	mov	dx, WORD PTR [ecx+4]
	mov	WORD PTR [eax+4], dx

; 142  : 		systemIndex = input.systemIndex;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _input$[ebp]
	mov	dx, WORD PTR [ecx+6]
	mov	WORD PTR [eax+6], dx

; 143  : 		return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 144  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4SystemAddress@RakNet@@QAEAAU01@ABU01@@Z ENDP		; RakNet::SystemAddress::operator=
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ??0RakNetGUID@RakNet@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0RakNetGUID@RakNet@@QAE@XZ PROC			; RakNet::RakNetGUID::RakNetGUID, COMDAT
; _this$ = ecx

; 156  : 	RakNetGUID() {systemIndex=(SystemIndex)-1;}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+8], ax
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0RakNetGUID@RakNet@@QAE@XZ ENDP			; RakNet::RakNetGUID::RakNetGUID
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ??4RakNetGUID@RakNet@@QAEAAU01@ABU01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_input$ = 8						; size = 4
??4RakNetGUID@RakNet@@QAEAAU01@ABU01@@Z PROC		; RakNet::RakNetGUID::operator=, COMDAT
; _this$ = ecx

; 174  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 175  : 		g=input.g;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _input$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx

; 176  : 		systemIndex=input.systemIndex;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _input$[ebp]
	mov	dx, WORD PTR [ecx+8]
	mov	WORD PTR [eax+8], dx

; 177  : 		return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 178  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4RakNetGUID@RakNet@@QAEAAU01@ABU01@@Z ENDP		; RakNet::RakNetGUID::operator=
_TEXT	ENDS
PUBLIC	?IsNetworkOrder@BitStream@RakNet@@SA_NXZ	; RakNet::BitStream::IsNetworkOrder
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\vice-players-master\raknet\bitstream.h
;	COMDAT ?DoEndianSwap@BitStream@RakNet@@SA_NXZ
_TEXT	SEGMENT
?DoEndianSwap@BitStream@RakNet@@SA_NXZ PROC		; RakNet::BitStream::DoEndianSwap, COMDAT

; 863  : 		inline static bool DoEndianSwap(void) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 864  : #ifndef __BITSTREAM_NATIVE_END
; 865  : 			return IsNetworkOrder()==false;

	call	?IsNetworkOrder@BitStream@RakNet@@SA_NXZ ; RakNet::BitStream::IsNetworkOrder
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 866  : #else
; 867  : 			return false;
; 868  : #endif
; 869  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DoEndianSwap@BitStream@RakNet@@SA_NXZ ENDP		; RakNet::BitStream::DoEndianSwap
_TEXT	ENDS
PUBLIC	?r@?1??IsNetworkOrder@BitStream@RakNet@@SA_NXZ@4_NB ; `RakNet::BitStream::IsNetworkOrder'::`2'::r
PUBLIC	??_B?1??IsNetworkOrder@BitStream@RakNet@@SA_NXZ@51 ; `RakNet::BitStream::IsNetworkOrder'::`2'::`local static guard'
EXTRN	?IsNetworkOrderInternal@BitStream@RakNet@@SA_NXZ:PROC ; RakNet::BitStream::IsNetworkOrderInternal
;	COMDAT ?r@?1??IsNetworkOrder@BitStream@RakNet@@SA_NXZ@4_NB
_BSS	SEGMENT
?r@?1??IsNetworkOrder@BitStream@RakNet@@SA_NXZ@4_NB DB 01H DUP (?) ; `RakNet::BitStream::IsNetworkOrder'::`2'::r
_BSS	ENDS
;	COMDAT ??_B?1??IsNetworkOrder@BitStream@RakNet@@SA_NXZ@51
_BSS	SEGMENT
??_B?1??IsNetworkOrder@BitStream@RakNet@@SA_NXZ@51 DD 01H DUP (?) ; `RakNet::BitStream::IsNetworkOrder'::`2'::`local static guard'
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?IsNetworkOrder@BitStream@RakNet@@SA_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?IsNetworkOrder@BitStream@RakNet@@SA_NXZ$0
__ehfuncinfo$?IsNetworkOrder@BitStream@RakNet@@SA_NXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?IsNetworkOrder@BitStream@RakNet@@SA_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCsu /ZI
xdata$x	ENDS
;	COMDAT ?IsNetworkOrder@BitStream@RakNet@@SA_NXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
?IsNetworkOrder@BitStream@RakNet@@SA_NXZ PROC		; RakNet::BitStream::IsNetworkOrder, COMDAT

; 874  : 		inline static bool IsNetworkOrder(void) {static const bool r = IsNetworkOrderInternal(); return r;}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?IsNetworkOrder@BitStream@RakNet@@SA_NXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR ??_B?1??IsNetworkOrder@BitStream@RakNet@@SA_NXZ@51
	and	eax, 1
	jne	SHORT $LN1@IsNetworkO
	mov	eax, DWORD PTR ??_B?1??IsNetworkOrder@BitStream@RakNet@@SA_NXZ@51
	or	eax, 1
	mov	DWORD PTR ??_B?1??IsNetworkOrder@BitStream@RakNet@@SA_NXZ@51, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	?IsNetworkOrderInternal@BitStream@RakNet@@SA_NXZ ; RakNet::BitStream::IsNetworkOrderInternal
	mov	BYTE PTR ?r@?1??IsNetworkOrder@BitStream@RakNet@@SA_NXZ@4_NB, al ; `RakNet::BitStream::IsNetworkOrder'::`2'::r
	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN1@IsNetworkO:
	mov	al, BYTE PTR ?r@?1??IsNetworkOrder@BitStream@RakNet@@SA_NXZ@4_NB ; `RakNet::BitStream::IsNetworkOrder'::`2'::r
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?IsNetworkOrder@BitStream@RakNet@@SA_NXZ$0:
	mov	eax, DWORD PTR ??_B?1??IsNetworkOrder@BitStream@RakNet@@SA_NXZ@51
	and	eax, -2					; fffffffeH
	mov	DWORD PTR ??_B?1??IsNetworkOrder@BitStream@RakNet@@SA_NXZ@51, eax
	ret	0
__ehhandler$?IsNetworkOrder@BitStream@RakNet@@SA_NXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?IsNetworkOrder@BitStream@RakNet@@SA_NXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?IsNetworkOrder@BitStream@RakNet@@SA_NXZ ENDP		; RakNet::BitStream::IsNetworkOrder
EXTRN	?Write0@BitStream@RakNet@@QAEXXZ:PROC		; RakNet::BitStream::Write0
EXTRN	?Write1@BitStream@RakNet@@QAEXXZ:PROC		; RakNet::BitStream::Write1
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??$Write@_N@BitStream@RakNet@@QAEXAB_N@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_inTemplateVar$ = 8					; size = 4
??$Write@_N@BitStream@RakNet@@QAEXAB_N@Z PROC		; RakNet::BitStream::Write<bool>, COMDAT
; _this$ = ecx

; 1103 : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1104 : 			if ( inTemplateVar )

	mov	eax, DWORD PTR _inTemplateVar$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN2@Write@2

; 1105 : 				Write1();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Write1@BitStream@RakNet@@QAEXXZ	; RakNet::BitStream::Write1

; 1106 : 			else

	jmp	SHORT $LN3@Write@2
$LN2@Write@2:

; 1107 : 				Write0();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Write0@BitStream@RakNet@@QAEXXZ	; RakNet::BitStream::Write0
$LN3@Write@2:

; 1108 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$Write@_N@BitStream@RakNet@@QAEXAB_N@Z ENDP		; RakNet::BitStream::Write<bool>
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\vice-players-master\client\net\ccheckpoints.h
_TEXT	ENDS
;	COMDAT ?GetSlotState@CCheckpoints@@QAE_NE@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_cpId$ = 8						; size = 1
?GetSlotState@CCheckpoints@@QAE_NE@Z PROC		; CCheckpoints::GetSlotState, COMDAT
; _this$ = ecx

; 43   : 	bool GetSlotState(EntityId cpId) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 44   : 		if(cpId > MAX_CPS) { return false; }

	movzx	eax, BYTE PTR _cpId$[ebp]
	cmp	eax, 16					; 00000010H
	jle	SHORT $LN1@GetSlotSta
	xor	al, al
	jmp	SHORT $LN2@GetSlotSta
$LN1@GetSlotSta:

; 45   : 		return m_bSlotState[cpId];

	movzx	eax, BYTE PTR _cpId$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [ecx+eax+64]
$LN2@GetSlotSta:

; 46   : 	};

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetSlotState@CCheckpoints@@QAE_NE@Z ENDP		; CCheckpoints::GetSlotState
_TEXT	ENDS
EXTRN	?m_pRPC4@CNetworkManager@@0PAVRPC4@RakNet@@A:DWORD ; CNetworkManager::m_pRPC4
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\vice-players-master\client\net\cnetworkmanager.h
;	COMDAT ?GetRPC4@CNetworkManager@@QAEPAVRPC4@RakNet@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetRPC4@CNetworkManager@@QAEPAVRPC4@RakNet@@XZ PROC	; CNetworkManager::GetRPC4, COMDAT
; _this$ = ecx

; 86   : 	RPC4 * GetRPC4() { return m_pRPC4; };

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ?m_pRPC4@CNetworkManager@@0PAVRPC4@RakNet@@A ; CNetworkManager::m_pRPC4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetRPC4@CNetworkManager@@QAEPAVRPC4@RakNet@@XZ ENDP	; CNetworkManager::GetRPC4
_TEXT	ENDS
EXTRN	??0SystemAddress@RakNet@@QAE@IG@Z:PROC		; RakNet::SystemAddress::SystemAddress
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\vice-players-master\raknet\raknettypes.h
;	COMDAT ??__EUNASSIGNED_SYSTEM_ADDRESS@RakNet@@YAXXZ
text$yc	SEGMENT
??__EUNASSIGNED_SYSTEM_ADDRESS@RakNet@@YAXXZ PROC	; RakNet::`dynamic initializer for 'UNASSIGNED_SYSTEM_ADDRESS'', COMDAT

; 196  : const SystemAddress UNASSIGNED_SYSTEM_ADDRESS(0xFFFFFFFF, 0xFFFF);

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	65535					; 0000ffffH
	push	-1
	mov	ecx, OFFSET _UNASSIGNED_SYSTEM_ADDRESS
	call	??0SystemAddress@RakNet@@QAE@IG@Z	; RakNet::SystemAddress::SystemAddress
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__EUNASSIGNED_SYSTEM_ADDRESS@RakNet@@YAXXZ ENDP	; RakNet::`dynamic initializer for 'UNASSIGNED_SYSTEM_ADDRESS''
text$yc	ENDS
PUBLIC	??0RakNetGUID@RakNet@@QAE@_K@Z			; RakNet::RakNetGUID::RakNetGUID
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??__EUNASSIGNED_RAKNET_GUID@RakNet@@YAXXZ
text$yc	SEGMENT
??__EUNASSIGNED_RAKNET_GUID@RakNet@@YAXXZ PROC		; RakNet::`dynamic initializer for 'UNASSIGNED_RAKNET_GUID'', COMDAT

; 197  : const RakNetGUID UNASSIGNED_RAKNET_GUID((uint64_t)-1);

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	-1
	push	-1
	mov	ecx, OFFSET _UNASSIGNED_RAKNET_GUID
	call	??0RakNetGUID@RakNet@@QAE@_K@Z		; RakNet::RakNetGUID::RakNetGUID
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__EUNASSIGNED_RAKNET_GUID@RakNet@@YAXXZ ENDP		; RakNet::`dynamic initializer for 'UNASSIGNED_RAKNET_GUID''
; Function compile flags: /Odtp /RTCsu /ZI
text$yc	ENDS
;	COMDAT ??0RakNetGUID@RakNet@@QAE@_K@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__g$ = 8						; size = 8
??0RakNetGUID@RakNet@@QAE@_K@Z PROC			; RakNet::RakNetGUID::RakNetGUID, COMDAT
; _this$ = ecx

; 157  : 	explicit RakNetGUID(uint64_t _g) {g=_g; systemIndex=(SystemIndex)-1;}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __g$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __g$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+8], ax
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0RakNetGUID@RakNet@@QAE@_K@Z ENDP			; RakNet::RakNetGUID::RakNetGUID
_TEXT	ENDS
_BSS	SEGMENT
_UNASSIGNED_SYSTEM_ADDRESS DQ 01H DUP (?)
_UNASSIGNED_RAKNET_GUID DB 010H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_UNASSIGNED_SYSTEM_ADDRESS$initializer$ DD FLAT:??__EUNASSIGNED_SYSTEM_ADDRESS@RakNet@@YAXXZ
_UNASSIGNED_RAKNET_GUID$initializer$ DD FLAT:??__EUNASSIGNED_RAKNET_GUID@RakNet@@YAXXZ
CRT$XCU	ENDS
END
