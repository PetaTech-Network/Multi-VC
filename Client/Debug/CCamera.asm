; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\vice-players-master\Client\game\CCamera.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	??0CCamera@@QAE@XZ				; CCamera::CCamera
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT rtc$TMZ
; File d:\vice-players-master\client\game\ccamera.cpp
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu /ZI
rtc$IMZ	ENDS
;	COMDAT ??0CCamera@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0CCamera@@QAE@XZ PROC					; CCamera::CCamera, COMDAT
; _this$ = ecx

; 18   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 19   : 	m_pCamera = (CAMERA_TYPE *)VAR_Camera;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 8275592		; 007e4688H

; 20   : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CCamera@@QAE@XZ ENDP					; CCamera::CCamera
_TEXT	ENDS
PUBLIC	??1CCamera@@QAE@XZ				; CCamera::~CCamera
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1CCamera@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1CCamera@@QAE@XZ PROC					; CCamera::~CCamera, COMDAT
; _this$ = ecx

; 25   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 26   : 	
; 27   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1CCamera@@QAE@XZ ENDP					; CCamera::~CCamera
_TEXT	ENDS
PUBLIC	?SetCamera@CCamera@@QAEXPAU_CAMERA_TYPE@@@Z	; CCamera::SetCamera
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?SetCamera@CCamera@@QAEXPAU_CAMERA_TYPE@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pCamera$ = 8						; size = 4
?SetCamera@CCamera@@QAEXPAU_CAMERA_TYPE@@@Z PROC	; CCamera::SetCamera, COMDAT
; _this$ = ecx

; 32   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 33   : 	m_pCamera = pCamera;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pCamera$[ebp]
	mov	DWORD PTR [eax], ecx

; 34   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetCamera@CCamera@@QAEXPAU_CAMERA_TYPE@@@Z ENDP	; CCamera::SetCamera
_TEXT	ENDS
PUBLIC	?GetCamera@CCamera@@QAEPAU_CAMERA_TYPE@@XZ	; CCamera::GetCamera
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?GetCamera@CCamera@@QAEPAU_CAMERA_TYPE@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetCamera@CCamera@@QAEPAU_CAMERA_TYPE@@XZ PROC		; CCamera::GetCamera, COMDAT
; _this$ = ecx

; 39   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 40   : 	return m_pCamera;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 41   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCamera@CCamera@@QAEPAU_CAMERA_TYPE@@XZ ENDP		; CCamera::GetCamera
_TEXT	ENDS
PUBLIC	?SetBehindPlayer@CCamera@@QAEXXZ		; CCamera::SetBehindPlayer
EXTRN	__RTC_CheckEsp:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?SetBehindPlayer@CCamera@@QAEXXZ
_TEXT	SEGMENT
_dwFunc$209264 = -32					; size = 4
_pCamera$ = -20						; size = 4
_this$ = -8						; size = 4
?SetBehindPlayer@CCamera@@QAEXXZ PROC			; CCamera::SetBehindPlayer, COMDAT
; _this$ = ecx

; 46   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 	CAMERA_TYPE * pCamera = m_pCamera;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pCamera$[ebp], ecx

; 48   : 
; 49   : 	if(pCamera)

	cmp	DWORD PTR _pCamera$[ebp], 0
	je	SHORT $LN2@SetBehindP

; 50   : 	{
; 51   : 		DWORD dwFunc = FUNC_CCamera__PutBehindPlayer;

	mov	DWORD PTR _dwFunc$209264[ebp], 4635358	; 0046badeH

; 52   : 		_asm
; 53   : 		{
; 54   : 			mov ecx, pCamera

	mov	ecx, DWORD PTR _pCamera$[ebp]

; 55   : 				call dwFunc

	call	DWORD PTR _dwFunc$209264[ebp]
$LN2@SetBehindP:

; 56   : 		}
; 57   : 	}
; 58   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?SetBehindPlayer@CCamera@@QAEXXZ ENDP			; CCamera::SetBehindPlayer
_TEXT	ENDS
PUBLIC	?SetInFreeMode@CCamera@@QAEX_N@Z		; CCamera::SetInFreeMode
PUBLIC	?SetPosition@CCamera@@QAEXUVector3@@@Z		; CCamera::SetPosition
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?SetPosition@CCamera@@QAEXUVector3@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_vecPosition$ = 8					; size = 12
?SetPosition@CCamera@@QAEXUVector3@@@Z PROC		; CCamera::SetPosition, COMDAT
; _this$ = ecx

; 63   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 64   : 	if(m_pCamera)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@SetPositio

; 65   : 	{
; 66   : 		memcpy(&m_pCamera->vecPosition, &vecPosition, sizeof(Vector3));

	push	12					; 0000000cH
	lea	eax, DWORD PTR _vecPosition$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1852				; 0000073cH
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 67   : 		SetInFreeMode(false);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetInFreeMode@CCamera@@QAEX_N@Z	; CCamera::SetInFreeMode
$LN2@SetPositio:

; 68   : 	}
; 69   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetPosition@CCamera@@QAEXUVector3@@@Z ENDP		; CCamera::SetPosition
_TEXT	ENDS
PUBLIC	?SetRotation@CCamera@@QAEXUVector3@@@Z		; CCamera::SetRotation
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?SetRotation@CCamera@@QAEXUVector3@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_vecRotation$ = 8					; size = 12
?SetRotation@CCamera@@QAEXUVector3@@@Z PROC		; CCamera::SetRotation, COMDAT
; _this$ = ecx

; 74   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 75   : 	if(m_pCamera)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@SetRotatio

; 76   : 	{
; 77   : 		memcpy(&m_pCamera->vecRotation, &vecRotation, sizeof(Vector3));

	push	12					; 0000000cH
	lea	eax, DWORD PTR _vecRotation$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1864				; 00000748H
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 78   : 		SetInFreeMode(false);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetInFreeMode@CCamera@@QAEX_N@Z	; CCamera::SetInFreeMode
$LN2@SetRotatio:

; 79   : 	}
; 80   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetRotation@CCamera@@QAEXUVector3@@@Z ENDP		; CCamera::SetRotation
_TEXT	ENDS
PUBLIC	?LookAtPoint@CCamera@@QAEXUVector3@@H@Z		; CCamera::LookAtPoint
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?LookAtPoint@CCamera@@QAEXUVector3@@H@Z
_TEXT	SEGMENT
_dwFunc$209285 = -44					; size = 4
_pPoint$209284 = -32					; size = 4
_pCamera$ = -20						; size = 4
_this$ = -8						; size = 4
_vecPoint$ = 8						; size = 12
_iType$ = 20						; size = 4
?LookAtPoint@CCamera@@QAEXUVector3@@H@Z PROC		; CCamera::LookAtPoint, COMDAT
; _this$ = ecx

; 85   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 86   : 	CAMERA_TYPE * pCamera = m_pCamera;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pCamera$[ebp], ecx

; 87   : 
; 88   : 	if(pCamera)

	cmp	DWORD PTR _pCamera$[ebp], 0
	je	SHORT $LN2@LookAtPoin

; 89   : 	{
; 90   : 		/*if(fZ < -100.0) { // min ground point
; 91   : 			fZ = FindGroundForZCoord
; 92   : 		}*/
; 93   : 		Vector3 * pPoint = &vecPoint;

	lea	eax, DWORD PTR _vecPoint$[ebp]
	mov	DWORD PTR _pPoint$209284[ebp], eax

; 94   : 		DWORD dwFunc = FUNC_CCamera__SetTargetPoint;

	mov	DWORD PTR _dwFunc$209285[ebp], 4629652	; 0046a494H

; 95   : 		_asm
; 96   : 		{
; 97   : 			push 1

	push	1

; 98   : 			push iType

	push	DWORD PTR _iType$[ebp]

; 99   : 			push pPoint

	push	DWORD PTR _pPoint$209284[ebp]

; 100  : 			mov ecx, pCamera

	mov	ecx, DWORD PTR _pCamera$[ebp]

; 101  : 			call dwFunc

	call	DWORD PTR _dwFunc$209285[ebp]
$LN2@LookAtPoin:

; 102  : 		}
; 103  : 	}
; 104  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?LookAtPoint@CCamera@@QAEXUVector3@@H@Z ENDP		; CCamera::LookAtPoint
_TEXT	ENDS
PUBLIC	?Restore@CCamera@@QAEXXZ			; CCamera::Restore
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?Restore@CCamera@@QAEXXZ
_TEXT	SEGMENT
_dwFunc$209291 = -32					; size = 4
_pCamera$ = -20						; size = 4
_this$ = -8						; size = 4
?Restore@CCamera@@QAEXXZ PROC				; CCamera::Restore, COMDAT
; _this$ = ecx

; 109  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 110  : 	CAMERA_TYPE * pCamera = m_pCamera;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pCamera$[ebp], ecx

; 111  : 
; 112  : 	if(pCamera)

	cmp	DWORD PTR _pCamera$[ebp], 0
	je	SHORT $LN2@Restore

; 113  : 	{
; 114  : 		DWORD dwFunc = FUNC_CCamera__Restore;

	mov	DWORD PTR _dwFunc$209291[ebp], 4635773	; 0046bc7dH

; 115  : 		_asm
; 116  : 		{
; 117  : 			mov ecx, pCamera

	mov	ecx, DWORD PTR _pCamera$[ebp]

; 118  : 			call dwFunc

	call	DWORD PTR _dwFunc$209291[ebp]
$LN2@Restore:

; 119  : 		}
; 120  : 	}
; 121  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Restore@CCamera@@QAEXXZ ENDP				; CCamera::Restore
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ?SetInFreeMode@CCamera@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_bFreeMode$ = 8						; size = 1
?SetInFreeMode@CCamera@@QAEX_N@Z PROC			; CCamera::SetInFreeMode, COMDAT
; _this$ = ecx

; 126  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 127  : 	if(m_pCamera)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@SetInFreeM

; 128  : 	{
; 129  : 		m_pCamera->byteInFreeMode = bFreeMode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	dl, BYTE PTR _bFreeMode$[ebp]
	mov	BYTE PTR [ecx+2152], dl
$LN2@SetInFreeM:

; 130  : 	}
; 131  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetInFreeMode@CCamera@@QAEX_N@Z ENDP			; CCamera::SetInFreeMode
_TEXT	ENDS
PUBLIC	?IsInFreeMode@CCamera@@QAE_NXZ			; CCamera::IsInFreeMode
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?IsInFreeMode@CCamera@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?IsInFreeMode@CCamera@@QAE_NXZ PROC			; CCamera::IsInFreeMode, COMDAT
; _this$ = ecx

; 136  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 137  : 	if(m_pCamera)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@IsInFreeMo

; 138  : 	{
; 139  : 		return (m_pCamera->byteInFreeMode != 0);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	eax, BYTE PTR [ecx+2152]
	neg	eax
	sbb	eax, eax
	neg	eax
	jmp	SHORT $LN2@IsInFreeMo
$LN1@IsInFreeMo:

; 140  : 	}
; 141  : 
; 142  : 	return false;

	xor	al, al
$LN2@IsInFreeMo:

; 143  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsInFreeMode@CCamera@@QAE_NXZ ENDP			; CCamera::IsInFreeMode
_TEXT	ENDS
PUBLIC	?SetDriveByLeft@CCamera@@QAEXE@Z		; CCamera::SetDriveByLeft
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?SetDriveByLeft@CCamera@@QAEXE@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_byteDriveByLeft$ = 8					; size = 1
?SetDriveByLeft@CCamera@@QAEXE@Z PROC			; CCamera::SetDriveByLeft, COMDAT
; _this$ = ecx

; 148  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 149  : 	if(m_pCamera)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@SetDriveBy

; 150  : 	{
; 151  : 		m_pCamera->byteDriveByLeft = byteDriveByLeft;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	dl, BYTE PTR _byteDriveByLeft$[ebp]
	mov	BYTE PTR [ecx+400], dl
$LN2@SetDriveBy:

; 152  : 	}
; 153  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetDriveByLeft@CCamera@@QAEXE@Z ENDP			; CCamera::SetDriveByLeft
_TEXT	ENDS
PUBLIC	?GetDriveByLeft@CCamera@@QAEEXZ			; CCamera::GetDriveByLeft
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?GetDriveByLeft@CCamera@@QAEEXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetDriveByLeft@CCamera@@QAEEXZ PROC			; CCamera::GetDriveByLeft, COMDAT
; _this$ = ecx

; 158  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 159  : 	if(m_pCamera)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@GetDriveBy

; 160  : 	{
; 161  : 		return m_pCamera->byteDriveByLeft;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	al, BYTE PTR [ecx+400]
	jmp	SHORT $LN2@GetDriveBy
$LN1@GetDriveBy:

; 162  : 	}
; 163  : 
; 164  : 	return 0;

	xor	al, al
$LN2@GetDriveBy:

; 165  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDriveByLeft@CCamera@@QAEEXZ ENDP			; CCamera::GetDriveByLeft
_TEXT	ENDS
PUBLIC	?SetDriveByRight@CCamera@@QAEXE@Z		; CCamera::SetDriveByRight
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?SetDriveByRight@CCamera@@QAEXE@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_byteDriveByRight$ = 8					; size = 1
?SetDriveByRight@CCamera@@QAEXE@Z PROC			; CCamera::SetDriveByRight, COMDAT
; _this$ = ecx

; 170  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 171  : 	if(m_pCamera)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@SetDriveBy@2

; 172  : 	{
; 173  : 		m_pCamera->byteDriveByRight = byteDriveByRight;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	dl, BYTE PTR _byteDriveByRight$[ebp]
	mov	BYTE PTR [ecx+401], dl
$LN2@SetDriveBy@2:

; 174  : 	}
; 175  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetDriveByRight@CCamera@@QAEXE@Z ENDP			; CCamera::SetDriveByRight
_TEXT	ENDS
PUBLIC	?GetDriveByRight@CCamera@@QAEEXZ		; CCamera::GetDriveByRight
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?GetDriveByRight@CCamera@@QAEEXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetDriveByRight@CCamera@@QAEEXZ PROC			; CCamera::GetDriveByRight, COMDAT
; _this$ = ecx

; 180  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 181  : 	if(m_pCamera)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@GetDriveBy@2

; 182  : 	{
; 183  : 		return m_pCamera->byteDriveByRight;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	al, BYTE PTR [ecx+401]
	jmp	SHORT $LN2@GetDriveBy@2
$LN1@GetDriveBy@2:

; 184  : 	}
; 185  : 
; 186  : 	return 0;

	xor	al, al
$LN2@GetDriveBy@2:

; 187  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDriveByRight@CCamera@@QAEEXZ ENDP			; CCamera::GetDriveByRight
_TEXT	ENDS
PUBLIC	?SetAim@CCamera@@QAEXPAU_CAMERA_AIM@@@Z		; CCamera::SetAim
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?SetAim@CCamera@@QAEXPAU_CAMERA_AIM@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pAim$ = 8						; size = 4
?SetAim@CCamera@@QAEXPAU_CAMERA_AIM@@@Z PROC		; CCamera::SetAim, COMDAT
; _this$ = ecx

; 192  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 193  : 	if(m_pCamera)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@SetAim

; 194  : 	{
; 195  : 		memcpy(&m_pCamera->aim, pAim, sizeof(CAMERA_AIM));

	push	48					; 00000030H
	mov	eax, DWORD PTR _pAim$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 752				; 000002f0H
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN2@SetAim:

; 196  : 	}
; 197  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SetAim@CCamera@@QAEXPAU_CAMERA_AIM@@@Z ENDP		; CCamera::SetAim
_TEXT	ENDS
PUBLIC	?GetAim@CCamera@@QAEPAU_CAMERA_AIM@@XZ		; CCamera::GetAim
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?GetAim@CCamera@@QAEPAU_CAMERA_AIM@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetAim@CCamera@@QAEPAU_CAMERA_AIM@@XZ PROC		; CCamera::GetAim, COMDAT
; _this$ = ecx

; 202  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 203  : 	if(m_pCamera)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@GetAim

; 204  : 	{
; 205  : 		return &m_pCamera->aim;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	add	eax, 752				; 000002f0H
	jmp	SHORT $LN2@GetAim
$LN1@GetAim:

; 206  : 	}
; 207  : 
; 208  : 	return NULL;

	xor	eax, eax
$LN2@GetAim:

; 209  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAim@CCamera@@QAEPAU_CAMERA_AIM@@XZ ENDP		; CCamera::GetAim
_TEXT	ENDS
END
